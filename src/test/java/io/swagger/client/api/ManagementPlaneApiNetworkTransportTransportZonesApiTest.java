/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api;

import io.swagger.client.ApiException;
import io.swagger.client.model.ApiError;
import io.swagger.client.model.TransportZone;
import io.swagger.client.model.TransportZoneListResult;
import io.swagger.client.model.TransportZoneStatus;
import org.junit.Test;
import org.junit.Ignore;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for ManagementPlaneApiNetworkTransportTransportZonesApi
 */
@Ignore
public class ManagementPlaneApiNetworkTransportTransportZonesApiTest {

    private final ManagementPlaneApiNetworkTransportTransportZonesApi api = new ManagementPlaneApiNetworkTransportTransportZonesApi();

    /**
     * Create a Transport Zone
     *
     * Creates a new transport zone. The required parameters are host_switch_name and transport_type (OVERLAY or VLAN). The optional parameters are description and display_name. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void createTransportZoneTest() throws ApiException {
        TransportZone body = null;
        TransportZone response = api.createTransportZone(body);

        // TODO: test validations
    }
    /**
     * Delete a Transport Zone
     *
     * Deletes an existing transport zone.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void deleteTransportZoneTest() throws ApiException {
        String zoneId = null;
        api.deleteTransportZone(zoneId);

        // TODO: test validations
    }
    /**
     * Get a Transport Zone
     *
     * Returns information about a single transport zone.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getTransportZoneTest() throws ApiException {
        String zoneId = null;
        TransportZone response = api.getTransportZone(zoneId);

        // TODO: test validations
    }
    /**
     * Get a Transport Zone&#x27;s Current Runtime Status Information
     *
     * Returns information about a specified transport zone, including the number of logical switches in the transport zone, number of logical spitch ports assigned to the transport zone, and number of transport nodes in the transport zone. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getTransportZoneStatusTest() throws ApiException {
        String zoneId = null;
        TransportZoneStatus response = api.getTransportZoneStatus(zoneId);

        // TODO: test validations
    }
    /**
     * List Transport Zones
     *
     * Returns information about configured transport zones. NSX requires at least one transport zone. NSX uses transport zones to provide connectivity based on the topology of the underlying network, trust zones, or organizational separations. For example, you might have hypervisors that use one network for management traffic and a different network for VM traffic. This architecture would require two transport zones. The combination of transport zones plus transport connectors enables NSX to form tunnels between hypervisors. Transport zones define which interfaces on the hypervisors can communicate with which other interfaces on other hypervisors to establish overlay tunnels or provide connectivity to a VLAN. A logical switch can be in one (and only one) transport zone. This means that all of a switch&#x27;s interfaces must be in the same transport zone. However, each hypervisor virtual switch (OVS or VDS) has multiple interfaces (connectors), and each connector can be attached to a different logical switch. For example, on a single hypervisor with two connectors, connector A can be attached to logical switch 1 in transport zone A, while connector B is attached to logical switch 2 in transport zone B. In this way, a single hypervisor can participate in multiple transport zones. The API for creating a transport zone requires that a single host switch be specified for each transport zone, and multiple transport zones can share the same host switch. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void listTransportZonesTest() throws ApiException {
        String cursor = null;
        String includedFields = null;
        Boolean isDefault = null;
        Long pageSize = null;
        Boolean sortAscending = null;
        String sortBy = null;
        String transportType = null;
        String uplinkTeamingPolicyName = null;
        TransportZoneListResult response = api.listTransportZones(cursor, includedFields, isDefault, pageSize, sortAscending, sortBy, transportType, uplinkTeamingPolicyName);

        // TODO: test validations
    }
    /**
     * Update a Transport Zone
     *
     * Updates an existing transport zone. Modifiable parameters are transport_type (VLAN or OVERLAY), description, and display_name. The request must include the existing host_switch_name. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void updateTransportZoneTest() throws ApiException {
        TransportZone body = null;
        String zoneId = null;
        TransportZone response = api.updateTransportZone(body, zoneId);

        // TODO: test validations
    }
}
