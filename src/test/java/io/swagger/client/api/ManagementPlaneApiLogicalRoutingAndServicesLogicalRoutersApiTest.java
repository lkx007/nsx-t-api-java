/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api;

import io.swagger.client.ApiException;
import io.swagger.client.model.ApiError;
import io.swagger.client.model.BgpNeighborRouteDetails;
import io.swagger.client.model.BgpNeighborRouteDetailsInCsvFormat;
import io.swagger.client.model.BgpNeighborsStatusListResult;
import io.swagger.client.model.LogicalRouter;
import io.swagger.client.model.LogicalRouterListResult;
import io.swagger.client.model.LogicalRouterRouteTable;
import io.swagger.client.model.LogicalRouterRouteTableInCsvFormat;
import io.swagger.client.model.LogicalRouterState;
import io.swagger.client.model.LogicalRouterStatus;
import io.swagger.client.model.LogicalServiceRouterClusterState;
import io.swagger.client.model.ServiceRouterAllocationConfig;
import org.junit.Test;
import org.junit.Ignore;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for ManagementPlaneApiLogicalRoutingAndServicesLogicalRoutersApi
 */
@Ignore
public class ManagementPlaneApiLogicalRoutingAndServicesLogicalRoutersApiTest {

    private final ManagementPlaneApiLogicalRoutingAndServicesLogicalRoutersApi api = new ManagementPlaneApiLogicalRoutingAndServicesLogicalRoutersApi();

    /**
     * Create a Logical Router
     *
     * Creates a logical router. The required parameters are router_type (TIER0 or TIER1) and edge_cluster_id (TIER0 only). Optional parameters include internal and external transit network addresses. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void createLogicalRouterTest() throws ApiException {
        LogicalRouter body = null;
        LogicalRouter response = api.createLogicalRouter(body);

        // TODO: test validations
    }
    /**
     * Delete a Logical Router
     *
     * Deletes the specified logical router. You must delete associated logical router ports before you can delete a logical router. Otherwise use force delete which will delete all related ports and other entities associated with that LR. To force delete logical router pass force&#x3D;true in query param. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void deleteLogicalRouterTest() throws ApiException {
        String logicalRouterId = null;
        Boolean cascadeDeleteLinkedPorts = null;
        Boolean force = null;
        api.deleteLogicalRouter(logicalRouterId, cascadeDeleteLinkedPorts, force);

        // TODO: test validations
    }
    /**
     * Get BGP neighbor advertised routes
     *
     * Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled. It always returns realtime response. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getBgpNeighborAdvertisedRoutesTest() throws ApiException {
        String logicalRouterId = null;
        String neighborId = null;
        BgpNeighborRouteDetails response = api.getBgpNeighborAdvertisedRoutes(logicalRouterId, neighborId);

        // TODO: test validations
    }
    /**
     * Get BGP neighbor advertised routes in CSV format 
     *
     * Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled in CSV format. It always returns realtime response. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getBgpNeighborAdvertisedRoutesInCsvFormatCsvTest() throws ApiException {
        String logicalRouterId = null;
        String neighborId = null;
        BgpNeighborRouteDetailsInCsvFormat response = api.getBgpNeighborAdvertisedRoutesInCsvFormatCsv(logicalRouterId, neighborId);

        // TODO: test validations
    }
    /**
     * Get BGP neighbor learned routes
     *
     * Returns routes learned by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled. It always returns realtime response. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getBgpNeighborRoutesTest() throws ApiException {
        String logicalRouterId = null;
        String neighborId = null;
        BgpNeighborRouteDetails response = api.getBgpNeighborRoutes(logicalRouterId, neighborId);

        // TODO: test validations
    }
    /**
     * Get BGP neighbor learned routes in CSV format 
     *
     * Returns routes learned by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled in CSV format. It always returns realtime response. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getBgpNeighborRoutesInCsvFormatCsvTest() throws ApiException {
        String logicalRouterId = null;
        String neighborId = null;
        BgpNeighborRouteDetailsInCsvFormat response = api.getBgpNeighborRoutesInCsvFormatCsv(logicalRouterId, neighborId);

        // TODO: test validations
    }
    /**
     * Get the status of all the BGP neighbors for the Logical Router of the given id
     *
     * Returns the status of all the BGP neighbors for the Logical Router of the given id. To get BGP neighbors status for the logical router from particular node, parameter \&quot;transport_node_id&#x3D;&lt;transportnode_id&gt;\&quot; needs to be specified. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getBgpNeighborsStatusTest() throws ApiException {
        String logicalRouterId = null;
        String cursor = null;
        String includedFields = null;
        Long pageSize = null;
        Boolean sortAscending = null;
        String sortBy = null;
        String source = null;
        String transportNodeId = null;
        BgpNeighborsStatusListResult response = api.getBgpNeighborsStatus(logicalRouterId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId);

        // TODO: test validations
    }
    /**
     * Get FIB table on a specified node for a logical router
     *
     * Returns the FIB for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. To filter the result by network address, paramter \&quot;network_prefix&#x3D;&lt;a.b.c.d/mask&gt;\&quot; needs to be specified. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getLogicalRouterForwardingTableTest() throws ApiException {
        String logicalRouterId = null;
        String transportNodeId = null;
        String cursor = null;
        String includedFields = null;
        String networkPrefix = null;
        Long pageSize = null;
        Boolean sortAscending = null;
        String sortBy = null;
        String source = null;
        LogicalRouterRouteTable response = api.getLogicalRouterForwardingTable(logicalRouterId, transportNodeId, cursor, includedFields, networkPrefix, pageSize, sortAscending, sortBy, source);

        // TODO: test validations
    }
    /**
     * Get FIB table on a specified node for a logical router
     *
     * Returns the FIB table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. To filter the result by network address, paramter \&quot;network_prefix&#x3D;&lt;a.b.c.d/mask&gt;\&quot; needs to be specified. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getLogicalRouterForwardingTableInCsvFormatCsvTest() throws ApiException {
        String logicalRouterId = null;
        String transportNodeId = null;
        String networkPrefix = null;
        String source = null;
        LogicalRouterRouteTableInCsvFormat response = api.getLogicalRouterForwardingTableInCsvFormatCsv(logicalRouterId, transportNodeId, networkPrefix, source);

        // TODO: test validations
    }
    /**
     * Get route table on a given node for a logical router
     *
     * Deprecated - Please use /logical-routers/&lt;logical-router-id&gt;/routing/routing-table for RIB and /logical-routers/&lt;logical-router-id&gt;/routing/forwarding-table for FIB. Returns the route table for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getLogicalRouterRouteTableTest() throws ApiException {
        String logicalRouterId = null;
        String transportNodeId = null;
        String cursor = null;
        String includedFields = null;
        Long pageSize = null;
        Boolean sortAscending = null;
        String sortBy = null;
        String source = null;
        LogicalRouterRouteTable response = api.getLogicalRouterRouteTable(logicalRouterId, transportNodeId, cursor, includedFields, pageSize, sortAscending, sortBy, source);

        // TODO: test validations
    }
    /**
     * Get route table on a node for a logical router
     *
     * Deprecated - Please use /logical-routers/&lt;logical-router-id&gt;/routing/routing-table for RIB and /logical-routers/&lt;logical-router-id&gt;/routing/forwarding-table for FIB. Returns the route table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getLogicalRouterRouteTableInCsvFormatCsvTest() throws ApiException {
        String logicalRouterId = null;
        String transportNodeId = null;
        String source = null;
        LogicalRouterRouteTableInCsvFormat response = api.getLogicalRouterRouteTableInCsvFormatCsv(logicalRouterId, transportNodeId, source);

        // TODO: test validations
    }
    /**
     * Get RIB table on a specified node for a logical router
     *
     * Returns the route table(RIB) for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. To filter the result by network address, parameter \&quot;network_prefix&#x3D;&lt;a.b.c.d/mask&gt;\&quot; needs to be specified. To filter the result by route source, parameter \&quot;route_source&#x3D;&lt;source_type&gt;\&quot; needs to be specified where source_type can be BGP, STATIC, CONNECTED, NSX_STATIC, TIER1_NAT or TIER0_NAT. It is also possible to filter the RIB table using both network address and route source filter together. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getLogicalRouterRoutingTableTest() throws ApiException {
        String logicalRouterId = null;
        String transportNodeId = null;
        String cursor = null;
        String includedFields = null;
        String networkPrefix = null;
        Long pageSize = null;
        String routeSource = null;
        Boolean sortAscending = null;
        String sortBy = null;
        String source = null;
        LogicalRouterRouteTable response = api.getLogicalRouterRoutingTable(logicalRouterId, transportNodeId, cursor, includedFields, networkPrefix, pageSize, routeSource, sortAscending, sortBy, source);

        // TODO: test validations
    }
    /**
     * Get RIB table on a specified node for a logical router
     *
     * Returns the route table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. To filter the result by network address, paramter \&quot;network_prefix&#x3D;&lt;a.b.c.d/mask&gt;\&quot; needs to be specified. To filter the result by route source, parameter \&quot;route_source&#x3D;&lt;source_type&gt;\&quot; needs to be specified where source_type can be BGP, STATIC, CONNECTED, NSX_STATIC, TIER1_NAT or TIER0_NAT. It is also possible to filter the RIB table using both network address and route source filter together. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getLogicalRouterRoutingTableInCsvFormatCsvTest() throws ApiException {
        String logicalRouterId = null;
        String transportNodeId = null;
        String networkPrefix = null;
        String routeSource = null;
        String source = null;
        LogicalRouterRouteTableInCsvFormat response = api.getLogicalRouterRoutingTableInCsvFormatCsv(logicalRouterId, transportNodeId, networkPrefix, routeSource, source);

        // TODO: test validations
    }
    /**
     * Get the Realized State of a Logical Router
     *
     * Return realized state information of a logical router. Any configuration update that affects the logical router can use this API to get its realized state by passing a request_id returned by the configuration change operation. e.g. Update configuration of logical router, static routes, etc. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getLogicalRouterStateTest() throws ApiException {
        String logicalRouterId = null;
        Long barrierId = null;
        String requestId = null;
        LogicalRouterState response = api.getLogicalRouterState(logicalRouterId, barrierId, requestId);

        // TODO: test validations
    }
    /**
     * Get the status for the Logical Router of the given id
     *
     * Returns status for the Logical Router of the given id.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getLogicalRouterStatusTest() throws ApiException {
        String logicalRouterId = null;
        String source = null;
        LogicalRouterStatus response = api.getLogicalRouterStatus(logicalRouterId, source);

        // TODO: test validations
    }
    /**
     * Get the Realized State of a Logical Service Router Cluster
     *
     * Return realized state information of a logical service router cluster. Any configuration update that affects the logical service router cluster can use this API to get its realized state by passing a request_id returned by the configuration change operation. e.g. Update configuration of nat, bgp, bfd, etc. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getLogicalServiceRouterClusterStateTest() throws ApiException {
        String logicalRouterId = null;
        Long barrierId = null;
        String requestId = null;
        LogicalServiceRouterClusterState response = api.getLogicalServiceRouterClusterState(logicalRouterId, barrierId, requestId);

        // TODO: test validations
    }
    /**
     * List Logical Routers
     *
     * Returns information about all logical routers, including the UUID, internal and external transit network addresses, and the router type (TIER0 or TIER1). You can get information for only TIER0 routers or only the TIER1 routers by including the router_type query parameter. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void listLogicalRoutersTest() throws ApiException {
        String cursor = null;
        String includedFields = null;
        Long pageSize = null;
        String routerType = null;
        Boolean sortAscending = null;
        String sortBy = null;
        LogicalRouterListResult response = api.listLogicalRouters(cursor, includedFields, pageSize, routerType, sortAscending, sortBy);

        // TODO: test validations
    }
    /**
     * Re allocate edge node placement of TIER1 service routers
     *
     * API to re allocate edge node placement for TIER1 logical router. You can re-allocate service routers of TIER1 in same edge cluster or different edge cluster. You can also place edge nodes manually and provide maximum two indices for HA mode ACTIVE_STANDBY. To re-allocate on new edge cluster you must have existing edge cluster for TIER1 logical router. This will be disruptive operation and all existing statistics of logical router will be remove. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void reAllocateServiceRoutersReallocateTest() throws ApiException {
        ServiceRouterAllocationConfig body = null;
        String logicalRouterId = null;
        LogicalRouter response = api.reAllocateServiceRoutersReallocate(body, logicalRouterId);

        // TODO: test validations
    }
    /**
     * Reprocesses a logical router configuration and publish updates to controller
     *
     * Reprocess logical router configuration and configuration of related entities like logical router ports, static routing, etc. Any missing Updates are published to controller. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void reProcessLogicalRouterReprocessTest() throws ApiException {
        String logicalRouterId = null;
        api.reProcessLogicalRouterReprocess(logicalRouterId);

        // TODO: test validations
    }
    /**
     * Read Logical Router
     *
     * Returns information about the specified logical router.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void readLogicalRouterTest() throws ApiException {
        String logicalRouterId = null;
        LogicalRouter response = api.readLogicalRouter(logicalRouterId);

        // TODO: test validations
    }
    /**
     * Update a Logical Router
     *
     * Modifies the specified logical router. Modifiable attributes include the internal_transit_network, external_transit_networks, and edge_cluster_id (for TIER0 routers). 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void updateLogicalRouterTest() throws ApiException {
        LogicalRouter body = null;
        String logicalRouterId = null;
        LogicalRouter response = api.updateLogicalRouter(body, logicalRouterId);

        // TODO: test validations
    }
}
