/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.LbSslProfile;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * LbServerSslProfile
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class LbServerSslProfile extends LbSslProfile {
  @SerializedName("session_cache_enabled")
  private Boolean sessionCacheEnabled = true;

  @SerializedName("is_fips")
  private Boolean isFips = null;

  /**
   * It is a label of cipher group which is mostly consumed by GUI. 
   */
  @JsonAdapter(CipherGroupLabelEnum.Adapter.class)
  public enum CipherGroupLabelEnum {
    BALANCED("BALANCED"),
    HIGH_SECURITY("HIGH_SECURITY"),
    HIGH_COMPATIBILITY("HIGH_COMPATIBILITY"),
    CUSTOM("CUSTOM");

    private String value;

    CipherGroupLabelEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static CipherGroupLabelEnum fromValue(String text) {
      for (CipherGroupLabelEnum b : CipherGroupLabelEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<CipherGroupLabelEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CipherGroupLabelEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CipherGroupLabelEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return CipherGroupLabelEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("cipher_group_label")
  private CipherGroupLabelEnum cipherGroupLabel = null;

  @SerializedName("is_secure")
  private Boolean isSecure = null;

  /**
   * SSL cipher
   */
  @JsonAdapter(CiphersEnum.Adapter.class)
  public enum CiphersEnum {
    ECDHE_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"),
    ECDHE_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"),
    ECDHE_RSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"),
    ECDHE_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"),
    ECDH_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA"),
    ECDH_RSA_WITH_AES_256_CBC_SHA("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA"),
    RSA_WITH_AES_256_CBC_SHA("TLS_RSA_WITH_AES_256_CBC_SHA"),
    RSA_WITH_AES_128_CBC_SHA("TLS_RSA_WITH_AES_128_CBC_SHA"),
    RSA_WITH_3DES_EDE_CBC_SHA("TLS_RSA_WITH_3DES_EDE_CBC_SHA"),
    ECDHE_RSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"),
    ECDHE_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"),
    ECDHE_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384"),
    RSA_WITH_AES_128_CBC_SHA256("TLS_RSA_WITH_AES_128_CBC_SHA256"),
    RSA_WITH_AES_128_GCM_SHA256("TLS_RSA_WITH_AES_128_GCM_SHA256"),
    RSA_WITH_AES_256_CBC_SHA256("TLS_RSA_WITH_AES_256_CBC_SHA256"),
    RSA_WITH_AES_256_GCM_SHA384("TLS_RSA_WITH_AES_256_GCM_SHA384"),
    ECDHE_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"),
    ECDHE_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"),
    ECDHE_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"),
    ECDHE_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384"),
    ECDHE_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"),
    ECDH_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA"),
    ECDH_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256"),
    ECDH_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256"),
    ECDH_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384"),
    ECDH_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384"),
    ECDH_RSA_WITH_AES_128_CBC_SHA("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA"),
    ECDH_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256"),
    ECDH_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256"),
    ECDH_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384"),
    ECDH_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384");

    private String value;

    CiphersEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static CiphersEnum fromValue(String text) {
      for (CiphersEnum b : CiphersEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<CiphersEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CiphersEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CiphersEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return CiphersEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("ciphers")
  private List<CiphersEnum> ciphers = null;

  /**
   * SSL protocol
   */
  @JsonAdapter(ProtocolsEnum.Adapter.class)
  public enum ProtocolsEnum {
    SSL_V2("SSL_V2"),
    SSL_V3("SSL_V3"),
    TLS_V1("TLS_V1"),
    TLS_V1_1("TLS_V1_1"),
    TLS_V1_2("TLS_V1_2");

    private String value;

    ProtocolsEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ProtocolsEnum fromValue(String text) {
      for (ProtocolsEnum b : ProtocolsEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ProtocolsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProtocolsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProtocolsEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ProtocolsEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("protocols")
  private List<ProtocolsEnum> protocols = null;

  public LbServerSslProfile sessionCacheEnabled(Boolean sessionCacheEnabled) {
    this.sessionCacheEnabled = sessionCacheEnabled;
    return this;
  }

   /**
   * SSL session caching allows SSL client and server to reuse previously negotiated security parameters avoiding the expensive public key operation during handshake. 
   * @return sessionCacheEnabled
  **/
  @Schema(description = "SSL session caching allows SSL client and server to reuse previously negotiated security parameters avoiding the expensive public key operation during handshake. ")
  public Boolean isSessionCacheEnabled() {
    return sessionCacheEnabled;
  }

  public void setSessionCacheEnabled(Boolean sessionCacheEnabled) {
    this.sessionCacheEnabled = sessionCacheEnabled;
  }

   /**
   * This flag is set to true when all the ciphers and protocols are FIPS compliant. It is set to false when one of the ciphers or protocols are not FIPS compliant. 
   * @return isFips
  **/
  @Schema(description = "This flag is set to true when all the ciphers and protocols are FIPS compliant. It is set to false when one of the ciphers or protocols are not FIPS compliant. ")
  public Boolean isIsFips() {
    return isFips;
  }

  public LbServerSslProfile cipherGroupLabel(CipherGroupLabelEnum cipherGroupLabel) {
    this.cipherGroupLabel = cipherGroupLabel;
    return this;
  }

   /**
   * It is a label of cipher group which is mostly consumed by GUI. 
   * @return cipherGroupLabel
  **/
  @Schema(description = "It is a label of cipher group which is mostly consumed by GUI. ")
  public CipherGroupLabelEnum getCipherGroupLabel() {
    return cipherGroupLabel;
  }

  public void setCipherGroupLabel(CipherGroupLabelEnum cipherGroupLabel) {
    this.cipherGroupLabel = cipherGroupLabel;
  }

   /**
   * This flag is set to true when all the ciphers and protocols are secure. It is set to false when one of the ciphers or protocols is insecure. 
   * @return isSecure
  **/
  @Schema(description = "This flag is set to true when all the ciphers and protocols are secure. It is set to false when one of the ciphers or protocols is insecure. ")
  public Boolean isIsSecure() {
    return isSecure;
  }

  public LbServerSslProfile ciphers(List<CiphersEnum> ciphers) {
    this.ciphers = ciphers;
    return this;
  }

  public LbServerSslProfile addCiphersItem(CiphersEnum ciphersItem) {
    if (this.ciphers == null) {
      this.ciphers = new ArrayList<CiphersEnum>();
    }
    this.ciphers.add(ciphersItem);
    return this;
  }

   /**
   * supported SSL cipher list to client side
   * @return ciphers
  **/
  @Schema(description = "supported SSL cipher list to client side")
  public List<CiphersEnum> getCiphers() {
    return ciphers;
  }

  public void setCiphers(List<CiphersEnum> ciphers) {
    this.ciphers = ciphers;
  }

  public LbServerSslProfile protocols(List<ProtocolsEnum> protocols) {
    this.protocols = protocols;
    return this;
  }

  public LbServerSslProfile addProtocolsItem(ProtocolsEnum protocolsItem) {
    if (this.protocols == null) {
      this.protocols = new ArrayList<ProtocolsEnum>();
    }
    this.protocols.add(protocolsItem);
    return this;
  }

   /**
   * SSL versions TLS1.1 and TLS1.2 are supported and enabled by default. SSLv2, SSLv3, and TLS1.0 are supported, but disabled by default. 
   * @return protocols
  **/
  @Schema(description = "SSL versions TLS1.1 and TLS1.2 are supported and enabled by default. SSLv2, SSLv3, and TLS1.0 are supported, but disabled by default. ")
  public List<ProtocolsEnum> getProtocols() {
    return protocols;
  }

  public void setProtocols(List<ProtocolsEnum> protocols) {
    this.protocols = protocols;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LbServerSslProfile lbServerSslProfile = (LbServerSslProfile) o;
    return Objects.equals(this.sessionCacheEnabled, lbServerSslProfile.sessionCacheEnabled) &&
        Objects.equals(this.isFips, lbServerSslProfile.isFips) &&
        Objects.equals(this.cipherGroupLabel, lbServerSslProfile.cipherGroupLabel) &&
        Objects.equals(this.isSecure, lbServerSslProfile.isSecure) &&
        Objects.equals(this.ciphers, lbServerSslProfile.ciphers) &&
        Objects.equals(this.protocols, lbServerSslProfile.protocols) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(sessionCacheEnabled, isFips, cipherGroupLabel, isSecure, ciphers, protocols, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LbServerSslProfile {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    sessionCacheEnabled: ").append(toIndentedString(sessionCacheEnabled)).append("\n");
    sb.append("    isFips: ").append(toIndentedString(isFips)).append("\n");
    sb.append("    cipherGroupLabel: ").append(toIndentedString(cipherGroupLabel)).append("\n");
    sb.append("    isSecure: ").append(toIndentedString(isSecure)).append("\n");
    sb.append("    ciphers: ").append(toIndentedString(ciphers)).append("\n");
    sb.append("    protocols: ").append(toIndentedString(protocols)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
