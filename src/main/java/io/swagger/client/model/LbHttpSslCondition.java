/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.LbClientCertificateIssuerDnCondition;
import io.swagger.client.model.LbClientCertificateSubjectDnCondition;
import io.swagger.client.model.LbRuleCondition;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * This condition is used to match SSL handshake and SSL connection at all phases.If multiple properties are configured, the rule is considered a match when all the configured properties are matched. 
 */
@Schema(description = "This condition is used to match SSL handshake and SSL connection at all phases.If multiple properties are configured, the rule is considered a match when all the configured properties are matched. ")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class LbHttpSslCondition extends LbRuleCondition {
  /**
   * SSL cipher
   */
  @JsonAdapter(ClientSupportedSslCiphersEnum.Adapter.class)
  public enum ClientSupportedSslCiphersEnum {
    ECDHE_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"),
    ECDHE_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"),
    ECDHE_RSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"),
    ECDHE_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"),
    ECDH_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA"),
    ECDH_RSA_WITH_AES_256_CBC_SHA("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA"),
    RSA_WITH_AES_256_CBC_SHA("TLS_RSA_WITH_AES_256_CBC_SHA"),
    RSA_WITH_AES_128_CBC_SHA("TLS_RSA_WITH_AES_128_CBC_SHA"),
    RSA_WITH_3DES_EDE_CBC_SHA("TLS_RSA_WITH_3DES_EDE_CBC_SHA"),
    ECDHE_RSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"),
    ECDHE_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"),
    ECDHE_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384"),
    RSA_WITH_AES_128_CBC_SHA256("TLS_RSA_WITH_AES_128_CBC_SHA256"),
    RSA_WITH_AES_128_GCM_SHA256("TLS_RSA_WITH_AES_128_GCM_SHA256"),
    RSA_WITH_AES_256_CBC_SHA256("TLS_RSA_WITH_AES_256_CBC_SHA256"),
    RSA_WITH_AES_256_GCM_SHA384("TLS_RSA_WITH_AES_256_GCM_SHA384"),
    ECDHE_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"),
    ECDHE_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"),
    ECDHE_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"),
    ECDHE_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384"),
    ECDHE_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"),
    ECDH_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA"),
    ECDH_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256"),
    ECDH_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256"),
    ECDH_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384"),
    ECDH_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384"),
    ECDH_RSA_WITH_AES_128_CBC_SHA("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA"),
    ECDH_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256"),
    ECDH_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256"),
    ECDH_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384"),
    ECDH_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384");

    private String value;

    ClientSupportedSslCiphersEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ClientSupportedSslCiphersEnum fromValue(String text) {
      for (ClientSupportedSslCiphersEnum b : ClientSupportedSslCiphersEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ClientSupportedSslCiphersEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ClientSupportedSslCiphersEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ClientSupportedSslCiphersEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ClientSupportedSslCiphersEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("client_supported_ssl_ciphers")
  private List<ClientSupportedSslCiphersEnum> clientSupportedSslCiphers = null;

  @SerializedName("client_certificate_issuer_dn")
  private LbClientCertificateIssuerDnCondition clientCertificateIssuerDn = null;

  @SerializedName("client_certificate_subject_dn")
  private LbClientCertificateSubjectDnCondition clientCertificateSubjectDn = null;

  /**
   * Cipher used for an established SSL connection
   */
  @JsonAdapter(UsedSslCipherEnum.Adapter.class)
  public enum UsedSslCipherEnum {
    ECDHE_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"),
    ECDHE_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"),
    ECDHE_RSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"),
    ECDHE_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"),
    ECDH_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA"),
    ECDH_RSA_WITH_AES_256_CBC_SHA("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA"),
    RSA_WITH_AES_256_CBC_SHA("TLS_RSA_WITH_AES_256_CBC_SHA"),
    RSA_WITH_AES_128_CBC_SHA("TLS_RSA_WITH_AES_128_CBC_SHA"),
    RSA_WITH_3DES_EDE_CBC_SHA("TLS_RSA_WITH_3DES_EDE_CBC_SHA"),
    ECDHE_RSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"),
    ECDHE_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"),
    ECDHE_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384"),
    RSA_WITH_AES_128_CBC_SHA256("TLS_RSA_WITH_AES_128_CBC_SHA256"),
    RSA_WITH_AES_128_GCM_SHA256("TLS_RSA_WITH_AES_128_GCM_SHA256"),
    RSA_WITH_AES_256_CBC_SHA256("TLS_RSA_WITH_AES_256_CBC_SHA256"),
    RSA_WITH_AES_256_GCM_SHA384("TLS_RSA_WITH_AES_256_GCM_SHA384"),
    ECDHE_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"),
    ECDHE_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"),
    ECDHE_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"),
    ECDHE_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384"),
    ECDHE_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"),
    ECDH_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA"),
    ECDH_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256"),
    ECDH_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256"),
    ECDH_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384"),
    ECDH_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384"),
    ECDH_RSA_WITH_AES_128_CBC_SHA("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA"),
    ECDH_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256"),
    ECDH_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256"),
    ECDH_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384"),
    ECDH_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384");

    private String value;

    UsedSslCipherEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static UsedSslCipherEnum fromValue(String text) {
      for (UsedSslCipherEnum b : UsedSslCipherEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<UsedSslCipherEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final UsedSslCipherEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public UsedSslCipherEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return UsedSslCipherEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("used_ssl_cipher")
  private UsedSslCipherEnum usedSslCipher = null;

  /**
   * The type of SSL session reused
   */
  @JsonAdapter(SessionReusedEnum.Adapter.class)
  public enum SessionReusedEnum {
    IGNORE("IGNORE"),
    REUSED("REUSED"),
    NEW("NEW");

    private String value;

    SessionReusedEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static SessionReusedEnum fromValue(String text) {
      for (SessionReusedEnum b : SessionReusedEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<SessionReusedEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SessionReusedEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SessionReusedEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return SessionReusedEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("session_reused")
  private SessionReusedEnum sessionReused = SessionReusedEnum.IGNORE;

  /**
   * Protocol of an established SSL connection
   */
  @JsonAdapter(UsedProtocolEnum.Adapter.class)
  public enum UsedProtocolEnum {
    SSL_V2("SSL_V2"),
    SSL_V3("SSL_V3"),
    TLS_V1("TLS_V1"),
    TLS_V1_1("TLS_V1_1"),
    TLS_V1_2("TLS_V1_2");

    private String value;

    UsedProtocolEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static UsedProtocolEnum fromValue(String text) {
      for (UsedProtocolEnum b : UsedProtocolEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<UsedProtocolEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final UsedProtocolEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public UsedProtocolEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return UsedProtocolEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("used_protocol")
  private UsedProtocolEnum usedProtocol = null;

  public LbHttpSslCondition clientSupportedSslCiphers(List<ClientSupportedSslCiphersEnum> clientSupportedSslCiphers) {
    this.clientSupportedSslCiphers = clientSupportedSslCiphers;
    return this;
  }

  public LbHttpSslCondition addClientSupportedSslCiphersItem(ClientSupportedSslCiphersEnum clientSupportedSslCiphersItem) {
    if (this.clientSupportedSslCiphers == null) {
      this.clientSupportedSslCiphers = new ArrayList<ClientSupportedSslCiphersEnum>();
    }
    this.clientSupportedSslCiphers.add(clientSupportedSslCiphersItem);
    return this;
  }

   /**
   * Cipher list which supported by client
   * @return clientSupportedSslCiphers
  **/
  @Schema(description = "Cipher list which supported by client")
  public List<ClientSupportedSslCiphersEnum> getClientSupportedSslCiphers() {
    return clientSupportedSslCiphers;
  }

  public void setClientSupportedSslCiphers(List<ClientSupportedSslCiphersEnum> clientSupportedSslCiphers) {
    this.clientSupportedSslCiphers = clientSupportedSslCiphers;
  }

  public LbHttpSslCondition clientCertificateIssuerDn(LbClientCertificateIssuerDnCondition clientCertificateIssuerDn) {
    this.clientCertificateIssuerDn = clientCertificateIssuerDn;
    return this;
  }

   /**
   * Get clientCertificateIssuerDn
   * @return clientCertificateIssuerDn
  **/
  @Schema(description = "")
  public LbClientCertificateIssuerDnCondition getClientCertificateIssuerDn() {
    return clientCertificateIssuerDn;
  }

  public void setClientCertificateIssuerDn(LbClientCertificateIssuerDnCondition clientCertificateIssuerDn) {
    this.clientCertificateIssuerDn = clientCertificateIssuerDn;
  }

  public LbHttpSslCondition clientCertificateSubjectDn(LbClientCertificateSubjectDnCondition clientCertificateSubjectDn) {
    this.clientCertificateSubjectDn = clientCertificateSubjectDn;
    return this;
  }

   /**
   * Get clientCertificateSubjectDn
   * @return clientCertificateSubjectDn
  **/
  @Schema(description = "")
  public LbClientCertificateSubjectDnCondition getClientCertificateSubjectDn() {
    return clientCertificateSubjectDn;
  }

  public void setClientCertificateSubjectDn(LbClientCertificateSubjectDnCondition clientCertificateSubjectDn) {
    this.clientCertificateSubjectDn = clientCertificateSubjectDn;
  }

  public LbHttpSslCondition usedSslCipher(UsedSslCipherEnum usedSslCipher) {
    this.usedSslCipher = usedSslCipher;
    return this;
  }

   /**
   * Cipher used for an established SSL connection
   * @return usedSslCipher
  **/
  @Schema(description = "Cipher used for an established SSL connection")
  public UsedSslCipherEnum getUsedSslCipher() {
    return usedSslCipher;
  }

  public void setUsedSslCipher(UsedSslCipherEnum usedSslCipher) {
    this.usedSslCipher = usedSslCipher;
  }

  public LbHttpSslCondition sessionReused(SessionReusedEnum sessionReused) {
    this.sessionReused = sessionReused;
    return this;
  }

   /**
   * The type of SSL session reused
   * @return sessionReused
  **/
  @Schema(description = "The type of SSL session reused")
  public SessionReusedEnum getSessionReused() {
    return sessionReused;
  }

  public void setSessionReused(SessionReusedEnum sessionReused) {
    this.sessionReused = sessionReused;
  }

  public LbHttpSslCondition usedProtocol(UsedProtocolEnum usedProtocol) {
    this.usedProtocol = usedProtocol;
    return this;
  }

   /**
   * Protocol of an established SSL connection
   * @return usedProtocol
  **/
  @Schema(description = "Protocol of an established SSL connection")
  public UsedProtocolEnum getUsedProtocol() {
    return usedProtocol;
  }

  public void setUsedProtocol(UsedProtocolEnum usedProtocol) {
    this.usedProtocol = usedProtocol;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LbHttpSslCondition lbHttpSslCondition = (LbHttpSslCondition) o;
    return Objects.equals(this.clientSupportedSslCiphers, lbHttpSslCondition.clientSupportedSslCiphers) &&
        Objects.equals(this.clientCertificateIssuerDn, lbHttpSslCondition.clientCertificateIssuerDn) &&
        Objects.equals(this.clientCertificateSubjectDn, lbHttpSslCondition.clientCertificateSubjectDn) &&
        Objects.equals(this.usedSslCipher, lbHttpSslCondition.usedSslCipher) &&
        Objects.equals(this.sessionReused, lbHttpSslCondition.sessionReused) &&
        Objects.equals(this.usedProtocol, lbHttpSslCondition.usedProtocol) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(clientSupportedSslCiphers, clientCertificateIssuerDn, clientCertificateSubjectDn, usedSslCipher, sessionReused, usedProtocol, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LbHttpSslCondition {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    clientSupportedSslCiphers: ").append(toIndentedString(clientSupportedSslCiphers)).append("\n");
    sb.append("    clientCertificateIssuerDn: ").append(toIndentedString(clientCertificateIssuerDn)).append("\n");
    sb.append("    clientCertificateSubjectDn: ").append(toIndentedString(clientCertificateSubjectDn)).append("\n");
    sb.append("    usedSslCipher: ").append(toIndentedString(usedSslCipher)).append("\n");
    sb.append("    sessionReused: ").append(toIndentedString(sessionReused)).append("\n");
    sb.append("    usedProtocol: ").append(toIndentedString(usedProtocol)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
