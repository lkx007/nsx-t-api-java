/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * PacketData
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")

public class PacketData {
  @SerializedName("routed")
  private Boolean routed = null;

  /**
   * transport type of the traceflow packet
   */
  @JsonAdapter(TransportTypeEnum.Adapter.class)
  public enum TransportTypeEnum {
    BROADCAST("BROADCAST"),
    UNICAST("UNICAST"),
    MULTICAST("MULTICAST"),
    UNKNOWN("UNKNOWN");

    private String value;

    TransportTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TransportTypeEnum fromValue(String text) {
      for (TransportTypeEnum b : TransportTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TransportTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TransportTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TransportTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return TransportTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("transport_type")
  private TransportTypeEnum transportType = TransportTypeEnum.UNICAST;

  /**
   * Packet configuration
   */
  @JsonAdapter(ResourceTypeEnum.Adapter.class)
  public enum ResourceTypeEnum {
    BINARYPACKETDATA("BinaryPacketData"),
    FIELDSPACKETDATA("FieldsPacketData");

    private String value;

    ResourceTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ResourceTypeEnum fromValue(String text) {
      for (ResourceTypeEnum b : ResourceTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ResourceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ResourceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ResourceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ResourceTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("resource_type")
  private ResourceTypeEnum resourceType = null;

  @SerializedName("frame_size")
  private Long frameSize = 128l;

  public PacketData() {
    this.resource_type = this.getClass().getSimpleName();
  }
  public PacketData routed(Boolean routed) {
    this.routed = routed;
    return this;
  }

   /**
   * A flag, when set true, indicates that the traceflow packet is of L3 routing.
   * @return routed
  **/
  @Schema(description = "A flag, when set true, indicates that the traceflow packet is of L3 routing.")
  public Boolean isRouted() {
    return routed;
  }

  public void setRouted(Boolean routed) {
    this.routed = routed;
  }

  public PacketData transportType(TransportTypeEnum transportType) {
    this.transportType = transportType;
    return this;
  }

   /**
   * transport type of the traceflow packet
   * @return transportType
  **/
  @Schema(description = "transport type of the traceflow packet")
  public TransportTypeEnum getTransportType() {
    return transportType;
  }

  public void setTransportType(TransportTypeEnum transportType) {
    this.transportType = transportType;
  }

  public PacketData resourceType(ResourceTypeEnum resourceType) {
    this.resourceType = resourceType;
    return this;
  }

   /**
   * Packet configuration
   * @return resourceType
  **/
  @Schema(required = true, description = "Packet configuration")
  public ResourceTypeEnum getResourceType() {
    return resourceType;
  }

  public void setResourceType(ResourceTypeEnum resourceType) {
    this.resourceType = resourceType;
  }

  public PacketData frameSize(Long frameSize) {
    this.frameSize = frameSize;
    return this;
  }

   /**
   * If the requested frame_size is too small (given the payload and traceflow metadata requirement of 16 bytes), the traceflow request will fail with an appropriate message.  The frame will be zero padded to the requested size.
   * minimum: 60
   * maximum: 1000
   * @return frameSize
  **/
  @Schema(description = "If the requested frame_size is too small (given the payload and traceflow metadata requirement of 16 bytes), the traceflow request will fail with an appropriate message.  The frame will be zero padded to the requested size.")
  public Long getFrameSize() {
    return frameSize;
  }

  public void setFrameSize(Long frameSize) {
    this.frameSize = frameSize;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PacketData packetData = (PacketData) o;
    return Objects.equals(this.routed, packetData.routed) &&
        Objects.equals(this.transportType, packetData.transportType) &&
        Objects.equals(this.resourceType, packetData.resourceType) &&
        Objects.equals(this.frameSize, packetData.frameSize);
  }

  @Override
  public int hashCode() {
    return Objects.hash(routed, transportType, resourceType, frameSize);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PacketData {\n");
    
    sb.append("    routed: ").append(toIndentedString(routed)).append("\n");
    sb.append("    transportType: ").append(toIndentedString(transportType)).append("\n");
    sb.append("    resourceType: ").append(toIndentedString(resourceType)).append("\n");
    sb.append("    frameSize: ").append(toIndentedString(frameSize)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
