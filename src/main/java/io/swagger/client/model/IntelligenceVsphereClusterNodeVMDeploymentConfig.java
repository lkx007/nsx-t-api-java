/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.IPSubnet;
import io.swagger.client.model.IntelligenceClusterNodeVMDeploymentConfig;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * The Vsphere deployment configuration determines where to deploy the NSX-Intelligence cluster node VM through a vCenter server. It contains settings that are applied during install time. If using DHCP, the following fields must be left unset - dns_servers, management_port_subnets, and default_gateway_addresses 
 */
@Schema(description = "The Vsphere deployment configuration determines where to deploy the NSX-Intelligence cluster node VM through a vCenter server. It contains settings that are applied during install time. If using DHCP, the following fields must be left unset - dns_servers, management_port_subnets, and default_gateway_addresses ")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class IntelligenceVsphereClusterNodeVMDeploymentConfig extends IntelligenceClusterNodeVMDeploymentConfig {
  @SerializedName("ovf_url")
  private String ovfUrl = null;

  @SerializedName("dns_servers")
  private List<String> dnsServers = null;

  @SerializedName("display_name")
  private String displayName = null;

  @SerializedName("ntp_servers")
  private List<String> ntpServers = null;

  @SerializedName("hostname")
  private String hostname = null;

  @SerializedName("enable_ssh")
  private Boolean enableSsh = false;

  @SerializedName("allow_ssh_root_login")
  private Boolean allowSshRootLogin = false;

  @SerializedName("compute_id")
  private String computeId = null;

  @SerializedName("vc_id")
  private String vcId = null;

  @SerializedName("storage_id")
  private String storageId = null;

  @SerializedName("default_gateway_addresses")
  private List<String> defaultGatewayAddresses = null;

  @SerializedName("management_port_subnets")
  private List<IPSubnet> managementPortSubnets = null;

  @SerializedName("host_id")
  private String hostId = null;

  @SerializedName("management_network_id")
  private String managementNetworkId = null;

  public IntelligenceVsphereClusterNodeVMDeploymentConfig ovfUrl(String ovfUrl) {
    this.ovfUrl = ovfUrl;
    return this;
  }

   /**
   * The NSX-Intelligence cluster node VM OVF URL to download and install the OVF file. 
   * @return ovfUrl
  **/
  @Schema(required = true, description = "The NSX-Intelligence cluster node VM OVF URL to download and install the OVF file. ")
  public String getOvfUrl() {
    return ovfUrl;
  }

  public void setOvfUrl(String ovfUrl) {
    this.ovfUrl = ovfUrl;
  }

  public IntelligenceVsphereClusterNodeVMDeploymentConfig dnsServers(List<String> dnsServers) {
    this.dnsServers = dnsServers;
    return this;
  }

  public IntelligenceVsphereClusterNodeVMDeploymentConfig addDnsServersItem(String dnsServersItem) {
    if (this.dnsServers == null) {
      this.dnsServers = new ArrayList<String>();
    }
    this.dnsServers.add(dnsServersItem);
    return this;
  }

   /**
   * List of DNS servers. If DHCP is used, the default DNS servers associated with the DHCP server will be used instead. Required if using static IP. 
   * @return dnsServers
  **/
  @Schema(description = "List of DNS servers. If DHCP is used, the default DNS servers associated with the DHCP server will be used instead. Required if using static IP. ")
  public List<String> getDnsServers() {
    return dnsServers;
  }

  public void setDnsServers(List<String> dnsServers) {
    this.dnsServers = dnsServers;
  }

  public IntelligenceVsphereClusterNodeVMDeploymentConfig displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

   /**
   * Desired display name for NSX-Intelligence VM to be deployed 
   * @return displayName
  **/
  @Schema(description = "Desired display name for NSX-Intelligence VM to be deployed ")
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }

  public IntelligenceVsphereClusterNodeVMDeploymentConfig ntpServers(List<String> ntpServers) {
    this.ntpServers = ntpServers;
    return this;
  }

  public IntelligenceVsphereClusterNodeVMDeploymentConfig addNtpServersItem(String ntpServersItem) {
    if (this.ntpServers == null) {
      this.ntpServers = new ArrayList<String>();
    }
    this.ntpServers.add(ntpServersItem);
    return this;
  }

   /**
   * List of NTP servers. To use hostnames, a DNS server must be defined. If not using DHCP, a DNS server should be specified under dns_servers. 
   * @return ntpServers
  **/
  @Schema(description = "List of NTP servers. To use hostnames, a DNS server must be defined. If not using DHCP, a DNS server should be specified under dns_servers. ")
  public List<String> getNtpServers() {
    return ntpServers;
  }

  public void setNtpServers(List<String> ntpServers) {
    this.ntpServers = ntpServers;
  }

  public IntelligenceVsphereClusterNodeVMDeploymentConfig hostname(String hostname) {
    this.hostname = hostname;
    return this;
  }

   /**
   * Desired host name/FQDN for the VM to be deployed 
   * @return hostname
  **/
  @Schema(required = true, description = "Desired host name/FQDN for the VM to be deployed ")
  public String getHostname() {
    return hostname;
  }

  public void setHostname(String hostname) {
    this.hostname = hostname;
  }

  public IntelligenceVsphereClusterNodeVMDeploymentConfig enableSsh(Boolean enableSsh) {
    this.enableSsh = enableSsh;
    return this;
  }

   /**
   * If true, the SSH service will automatically be started on the VM. Enabling SSH service is not recommended for security reasons. 
   * @return enableSsh
  **/
  @Schema(description = "If true, the SSH service will automatically be started on the VM. Enabling SSH service is not recommended for security reasons. ")
  public Boolean isEnableSsh() {
    return enableSsh;
  }

  public void setEnableSsh(Boolean enableSsh) {
    this.enableSsh = enableSsh;
  }

  public IntelligenceVsphereClusterNodeVMDeploymentConfig allowSshRootLogin(Boolean allowSshRootLogin) {
    this.allowSshRootLogin = allowSshRootLogin;
    return this;
  }

   /**
   * If true, the root user will be allowed to log into the VM. Allowing root SSH logins is not recommended for security reasons. 
   * @return allowSshRootLogin
  **/
  @Schema(description = "If true, the root user will be allowed to log into the VM. Allowing root SSH logins is not recommended for security reasons. ")
  public Boolean isAllowSshRootLogin() {
    return allowSshRootLogin;
  }

  public void setAllowSshRootLogin(Boolean allowSshRootLogin) {
    this.allowSshRootLogin = allowSshRootLogin;
  }

  public IntelligenceVsphereClusterNodeVMDeploymentConfig computeId(String computeId) {
    this.computeId = computeId;
    return this;
  }

   /**
   * The NSX-Intelligence cluster node VM will be deployed on the specified cluster or resourcepool for specified VC server. 
   * @return computeId
  **/
  @Schema(required = true, description = "The NSX-Intelligence cluster node VM will be deployed on the specified cluster or resourcepool for specified VC server. ")
  public String getComputeId() {
    return computeId;
  }

  public void setComputeId(String computeId) {
    this.computeId = computeId;
  }

  public IntelligenceVsphereClusterNodeVMDeploymentConfig vcId(String vcId) {
    this.vcId = vcId;
    return this;
  }

   /**
   * The VC-specific identifiers will be resolved on this VC, so all other identifiers specified in the config must belong to this vCenter server. 
   * @return vcId
  **/
  @Schema(required = true, description = "The VC-specific identifiers will be resolved on this VC, so all other identifiers specified in the config must belong to this vCenter server. ")
  public String getVcId() {
    return vcId;
  }

  public void setVcId(String vcId) {
    this.vcId = vcId;
  }

  public IntelligenceVsphereClusterNodeVMDeploymentConfig storageId(String storageId) {
    this.storageId = storageId;
    return this;
  }

   /**
   * The NSX-Intelligence cluster node VM will be deployed on the specified datastore in the specified VC server. User must ensure that storage is accessible by the specified cluster/host. 
   * @return storageId
  **/
  @Schema(required = true, description = "The NSX-Intelligence cluster node VM will be deployed on the specified datastore in the specified VC server. User must ensure that storage is accessible by the specified cluster/host. ")
  public String getStorageId() {
    return storageId;
  }

  public void setStorageId(String storageId) {
    this.storageId = storageId;
  }

  public IntelligenceVsphereClusterNodeVMDeploymentConfig defaultGatewayAddresses(List<String> defaultGatewayAddresses) {
    this.defaultGatewayAddresses = defaultGatewayAddresses;
    return this;
  }

  public IntelligenceVsphereClusterNodeVMDeploymentConfig addDefaultGatewayAddressesItem(String defaultGatewayAddressesItem) {
    if (this.defaultGatewayAddresses == null) {
      this.defaultGatewayAddresses = new ArrayList<String>();
    }
    this.defaultGatewayAddresses.add(defaultGatewayAddressesItem);
    return this;
  }

   /**
   * The default gateway for the VM to be deployed must be specified if all the other VMs it communicates with are not in the same subnet. Do not specify this field and management_port_subnets to use DHCP. Note: only single IPv4 default gateway address is supported and it must belong to management network. IMPORTANT: VMs deployed using DHCP are currently not supported, so this parameter should be specified. 
   * @return defaultGatewayAddresses
  **/
  @Schema(description = "The default gateway for the VM to be deployed must be specified if all the other VMs it communicates with are not in the same subnet. Do not specify this field and management_port_subnets to use DHCP. Note: only single IPv4 default gateway address is supported and it must belong to management network. IMPORTANT: VMs deployed using DHCP are currently not supported, so this parameter should be specified. ")
  public List<String> getDefaultGatewayAddresses() {
    return defaultGatewayAddresses;
  }

  public void setDefaultGatewayAddresses(List<String> defaultGatewayAddresses) {
    this.defaultGatewayAddresses = defaultGatewayAddresses;
  }

  public IntelligenceVsphereClusterNodeVMDeploymentConfig managementPortSubnets(List<IPSubnet> managementPortSubnets) {
    this.managementPortSubnets = managementPortSubnets;
    return this;
  }

  public IntelligenceVsphereClusterNodeVMDeploymentConfig addManagementPortSubnetsItem(IPSubnet managementPortSubnetsItem) {
    if (this.managementPortSubnets == null) {
      this.managementPortSubnets = new ArrayList<IPSubnet>();
    }
    this.managementPortSubnets.add(managementPortSubnetsItem);
    return this;
  }

   /**
   * IP Address and subnet configuration for the management port. Do not specify this field and default_gateway_addresses to use DHCP. Note: only one IPv4 address is supported for the management port. IMPORTANT: VMs deployed using DHCP are currently not supported, so this parameter should be specified. 
   * @return managementPortSubnets
  **/
  @Schema(description = "IP Address and subnet configuration for the management port. Do not specify this field and default_gateway_addresses to use DHCP. Note: only one IPv4 address is supported for the management port. IMPORTANT: VMs deployed using DHCP are currently not supported, so this parameter should be specified. ")
  public List<IPSubnet> getManagementPortSubnets() {
    return managementPortSubnets;
  }

  public void setManagementPortSubnets(List<IPSubnet> managementPortSubnets) {
    this.managementPortSubnets = managementPortSubnets;
  }

  public IntelligenceVsphereClusterNodeVMDeploymentConfig hostId(String hostId) {
    this.hostId = hostId;
    return this;
  }

   /**
   * The NSX-Intelligence cluster node VM will be deployed on the specified host in the specified VC server within the cluster if host_id is specified. Note: User must ensure that storage and specified networks are accessible by this host. 
   * @return hostId
  **/
  @Schema(description = "The NSX-Intelligence cluster node VM will be deployed on the specified host in the specified VC server within the cluster if host_id is specified. Note: User must ensure that storage and specified networks are accessible by this host. ")
  public String getHostId() {
    return hostId;
  }

  public void setHostId(String hostId) {
    this.hostId = hostId;
  }

  public IntelligenceVsphereClusterNodeVMDeploymentConfig managementNetworkId(String managementNetworkId) {
    this.managementNetworkId = managementNetworkId;
    return this;
  }

   /**
   * Distributed portgroup identifier to which the management vnic of NSX-Intelligence cluster node VM will be connected. 
   * @return managementNetworkId
  **/
  @Schema(required = true, description = "Distributed portgroup identifier to which the management vnic of NSX-Intelligence cluster node VM will be connected. ")
  public String getManagementNetworkId() {
    return managementNetworkId;
  }

  public void setManagementNetworkId(String managementNetworkId) {
    this.managementNetworkId = managementNetworkId;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IntelligenceVsphereClusterNodeVMDeploymentConfig intelligenceVsphereClusterNodeVMDeploymentConfig = (IntelligenceVsphereClusterNodeVMDeploymentConfig) o;
    return Objects.equals(this.ovfUrl, intelligenceVsphereClusterNodeVMDeploymentConfig.ovfUrl) &&
        Objects.equals(this.dnsServers, intelligenceVsphereClusterNodeVMDeploymentConfig.dnsServers) &&
        Objects.equals(this.displayName, intelligenceVsphereClusterNodeVMDeploymentConfig.displayName) &&
        Objects.equals(this.ntpServers, intelligenceVsphereClusterNodeVMDeploymentConfig.ntpServers) &&
        Objects.equals(this.hostname, intelligenceVsphereClusterNodeVMDeploymentConfig.hostname) &&
        Objects.equals(this.enableSsh, intelligenceVsphereClusterNodeVMDeploymentConfig.enableSsh) &&
        Objects.equals(this.allowSshRootLogin, intelligenceVsphereClusterNodeVMDeploymentConfig.allowSshRootLogin) &&
        Objects.equals(this.computeId, intelligenceVsphereClusterNodeVMDeploymentConfig.computeId) &&
        Objects.equals(this.vcId, intelligenceVsphereClusterNodeVMDeploymentConfig.vcId) &&
        Objects.equals(this.storageId, intelligenceVsphereClusterNodeVMDeploymentConfig.storageId) &&
        Objects.equals(this.defaultGatewayAddresses, intelligenceVsphereClusterNodeVMDeploymentConfig.defaultGatewayAddresses) &&
        Objects.equals(this.managementPortSubnets, intelligenceVsphereClusterNodeVMDeploymentConfig.managementPortSubnets) &&
        Objects.equals(this.hostId, intelligenceVsphereClusterNodeVMDeploymentConfig.hostId) &&
        Objects.equals(this.managementNetworkId, intelligenceVsphereClusterNodeVMDeploymentConfig.managementNetworkId) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(ovfUrl, dnsServers, displayName, ntpServers, hostname, enableSsh, allowSshRootLogin, computeId, vcId, storageId, defaultGatewayAddresses, managementPortSubnets, hostId, managementNetworkId, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IntelligenceVsphereClusterNodeVMDeploymentConfig {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    ovfUrl: ").append(toIndentedString(ovfUrl)).append("\n");
    sb.append("    dnsServers: ").append(toIndentedString(dnsServers)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    ntpServers: ").append(toIndentedString(ntpServers)).append("\n");
    sb.append("    hostname: ").append(toIndentedString(hostname)).append("\n");
    sb.append("    enableSsh: ").append(toIndentedString(enableSsh)).append("\n");
    sb.append("    allowSshRootLogin: ").append(toIndentedString(allowSshRootLogin)).append("\n");
    sb.append("    computeId: ").append(toIndentedString(computeId)).append("\n");
    sb.append("    vcId: ").append(toIndentedString(vcId)).append("\n");
    sb.append("    storageId: ").append(toIndentedString(storageId)).append("\n");
    sb.append("    defaultGatewayAddresses: ").append(toIndentedString(defaultGatewayAddresses)).append("\n");
    sb.append("    managementPortSubnets: ").append(toIndentedString(managementPortSubnets)).append("\n");
    sb.append("    hostId: ").append(toIndentedString(hostId)).append("\n");
    sb.append("    managementNetworkId: ").append(toIndentedString(managementNetworkId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
