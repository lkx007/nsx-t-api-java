/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.ManagedResource;
import io.swagger.client.model.Tag;
import io.swagger.client.model.TcpMssClamping;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.List;
/**
 * VPN session defines connection between local and peer endpoint. Untill VPN session is defined configuration is not realized.
 */
@Schema(description = "VPN session defines connection between local and peer endpoint. Untill VPN session is defined configuration is not realized.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")

public class IPSecVPNSession extends ManagedResource {
  @SerializedName("peer_endpoint_id")
  private String peerEndpointId = null;

  @SerializedName("ipsec_vpn_service_id")
  private String ipsecVpnServiceId = null;

  @SerializedName("local_endpoint_id")
  private String localEndpointId = null;

  @SerializedName("tcp_mss_clamping")
  private TcpMssClamping tcpMssClamping = null;

  @SerializedName("enabled")
  private Boolean enabled = true;

  /**
   * A Policy Based VPN requires to define protect rules that match   local and peer subnets. IPSec security associations is   negotiated for each pair of local and peer subnet. A Route Based VPN is more flexible, more powerful and recommended over   policy based VPN. IP Tunnel port is created and all traffic routed via   tunnel port is protected. Routes can be configured statically   or can be learned through BGP. A route based VPN is must for establishing   redundant VPN session to remote site. 
   */
  @JsonAdapter(ResourceTypeEnum.Adapter.class)
  public enum ResourceTypeEnum {
    POLICYBASEDIPSECVPNSESSION("PolicyBasedIPSecVPNSession"),
    ROUTEBASEDIPSECVPNSESSION("RouteBasedIPSecVPNSession");

    private String value;

    ResourceTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ResourceTypeEnum fromValue(String text) {
      for (ResourceTypeEnum b : ResourceTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ResourceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ResourceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ResourceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ResourceTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("resource_type")
  private ResourceTypeEnum resourceType = null;

  public IPSecVPNSession() {
    this.resource_type = this.getClass().getSimpleName();
  }
  public IPSecVPNSession peerEndpointId(String peerEndpointId) {
    this.peerEndpointId = peerEndpointId;
    return this;
  }

   /**
   * Peer endpoint identifier.
   * @return peerEndpointId
  **/
  @Schema(required = true, description = "Peer endpoint identifier.")
  public String getPeerEndpointId() {
    return peerEndpointId;
  }

  public void setPeerEndpointId(String peerEndpointId) {
    this.peerEndpointId = peerEndpointId;
  }

   /**
   * Identifier of VPN Service linked with local endpoint.
   * @return ipsecVpnServiceId
  **/
  @Schema(description = "Identifier of VPN Service linked with local endpoint.")
  public String getIpsecVpnServiceId() {
    return ipsecVpnServiceId;
  }

  public IPSecVPNSession localEndpointId(String localEndpointId) {
    this.localEndpointId = localEndpointId;
    return this;
  }

   /**
   * Local endpoint identifier.
   * @return localEndpointId
  **/
  @Schema(required = true, description = "Local endpoint identifier.")
  public String getLocalEndpointId() {
    return localEndpointId;
  }

  public void setLocalEndpointId(String localEndpointId) {
    this.localEndpointId = localEndpointId;
  }

  public IPSecVPNSession tcpMssClamping(TcpMssClamping tcpMssClamping) {
    this.tcpMssClamping = tcpMssClamping;
    return this;
  }

   /**
   * Get tcpMssClamping
   * @return tcpMssClamping
  **/
  @Schema(description = "")
  public TcpMssClamping getTcpMssClamping() {
    return tcpMssClamping;
  }

  public void setTcpMssClamping(TcpMssClamping tcpMssClamping) {
    this.tcpMssClamping = tcpMssClamping;
  }

  public IPSecVPNSession enabled(Boolean enabled) {
    this.enabled = enabled;
    return this;
  }

   /**
   * Enable/Disable IPSec VPN session.
   * @return enabled
  **/
  @Schema(description = "Enable/Disable IPSec VPN session.")
  public Boolean isEnabled() {
    return enabled;
  }

  public void setEnabled(Boolean enabled) {
    this.enabled = enabled;
  }

  public IPSecVPNSession resourceType(ResourceTypeEnum resourceType) {
    this.resourceType = resourceType;
    return this;
  }

   /**
   * A Policy Based VPN requires to define protect rules that match   local and peer subnets. IPSec security associations is   negotiated for each pair of local and peer subnet. A Route Based VPN is more flexible, more powerful and recommended over   policy based VPN. IP Tunnel port is created and all traffic routed via   tunnel port is protected. Routes can be configured statically   or can be learned through BGP. A route based VPN is must for establishing   redundant VPN session to remote site. 
   * @return resourceType
  **/
  @Schema(required = true, description = "A Policy Based VPN requires to define protect rules that match   local and peer subnets. IPSec security associations is   negotiated for each pair of local and peer subnet. A Route Based VPN is more flexible, more powerful and recommended over   policy based VPN. IP Tunnel port is created and all traffic routed via   tunnel port is protected. Routes can be configured statically   or can be learned through BGP. A route based VPN is must for establishing   redundant VPN session to remote site. ")
  public ResourceTypeEnum getResourceType() {
    return resourceType;
  }

  public void setResourceType(ResourceTypeEnum resourceType) {
    this.resourceType = resourceType;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IPSecVPNSession ipSecVPNSession = (IPSecVPNSession) o;
    return Objects.equals(this.peerEndpointId, ipSecVPNSession.peerEndpointId) &&
        Objects.equals(this.ipsecVpnServiceId, ipSecVPNSession.ipsecVpnServiceId) &&
        Objects.equals(this.localEndpointId, ipSecVPNSession.localEndpointId) &&
        Objects.equals(this.tcpMssClamping, ipSecVPNSession.tcpMssClamping) &&
        Objects.equals(this.enabled, ipSecVPNSession.enabled) &&
        Objects.equals(this.resourceType, ipSecVPNSession.resourceType) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(peerEndpointId, ipsecVpnServiceId, localEndpointId, tcpMssClamping, enabled, resourceType, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IPSecVPNSession {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    peerEndpointId: ").append(toIndentedString(peerEndpointId)).append("\n");
    sb.append("    ipsecVpnServiceId: ").append(toIndentedString(ipsecVpnServiceId)).append("\n");
    sb.append("    localEndpointId: ").append(toIndentedString(localEndpointId)).append("\n");
    sb.append("    tcpMssClamping: ").append(toIndentedString(tcpMssClamping)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    resourceType: ").append(toIndentedString(resourceType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
