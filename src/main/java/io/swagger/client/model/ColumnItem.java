/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.Label;
import io.swagger.client.model.RenderConfiguration;
import io.swagger.client.model.Tooltip;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * Represents a column of the Grid
 */
@Schema(description = "Represents a column of the Grid")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class ColumnItem {
  @SerializedName("sort_key")
  private String sortKey = null;

  /**
   * Data type of the field.
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    STRING("String"),
    NUMBER("Number"),
    DATE("Date");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TypeEnum fromValue(String text) {
      for (TypeEnum b : TypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return TypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("type")
  private TypeEnum type = TypeEnum.STRING;

  @SerializedName("tooltip")
  private List<Tooltip> tooltip = null;

  @SerializedName("label")
  private Label label = null;

  @SerializedName("field")
  private String field = null;

  @SerializedName("sort_ascending")
  private Boolean sortAscending = true;

  @SerializedName("drilldown_id")
  private String drilldownId = null;

  @SerializedName("hidden")
  private Boolean hidden = false;

  @SerializedName("navigation")
  private String navigation = null;

  @SerializedName("column_identifier")
  private String columnIdentifier = null;

  @SerializedName("render_configuration")
  private List<RenderConfiguration> renderConfiguration = null;

  public ColumnItem sortKey(String sortKey) {
    this.sortKey = sortKey;
    return this;
  }

   /**
   * Sorting on column is based on the sort_key. sort_key represents the field in the output data on which sort is requested.
   * @return sortKey
  **/
  @Schema(description = "Sorting on column is based on the sort_key. sort_key represents the field in the output data on which sort is requested.")
  public String getSortKey() {
    return sortKey;
  }

  public void setSortKey(String sortKey) {
    this.sortKey = sortKey;
  }

  public ColumnItem type(TypeEnum type) {
    this.type = type;
    return this;
  }

   /**
   * Data type of the field.
   * @return type
  **/
  @Schema(required = true, description = "Data type of the field.")
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }

  public ColumnItem tooltip(List<Tooltip> tooltip) {
    this.tooltip = tooltip;
    return this;
  }

  public ColumnItem addTooltipItem(Tooltip tooltipItem) {
    if (this.tooltip == null) {
      this.tooltip = new ArrayList<Tooltip>();
    }
    this.tooltip.add(tooltipItem);
    return this;
  }

   /**
   * Multi-line text to be shown on tooltip while hovering over a cell in the grid.
   * @return tooltip
  **/
  @Schema(description = "Multi-line text to be shown on tooltip while hovering over a cell in the grid.")
  public List<Tooltip> getTooltip() {
    return tooltip;
  }

  public void setTooltip(List<Tooltip> tooltip) {
    this.tooltip = tooltip;
  }

  public ColumnItem label(Label label) {
    this.label = label;
    return this;
  }

   /**
   * Get label
   * @return label
  **/
  @Schema(required = true, description = "")
  public Label getLabel() {
    return label;
  }

  public void setLabel(Label label) {
    this.label = label;
  }

  public ColumnItem field(String field) {
    this.field = field;
    return this;
  }

   /**
   * Field from which values of the column will be derived.
   * @return field
  **/
  @Schema(required = true, description = "Field from which values of the column will be derived.")
  public String getField() {
    return field;
  }

  public void setField(String field) {
    this.field = field;
  }

  public ColumnItem sortAscending(Boolean sortAscending) {
    this.sortAscending = sortAscending;
    return this;
  }

   /**
   * If true, the value of the column are sorted in ascending order. Otherwise, in descending order.
   * @return sortAscending
  **/
  @Schema(description = "If true, the value of the column are sorted in ascending order. Otherwise, in descending order.")
  public Boolean isSortAscending() {
    return sortAscending;
  }

  public void setSortAscending(Boolean sortAscending) {
    this.sortAscending = sortAscending;
  }

  public ColumnItem drilldownId(String drilldownId) {
    this.drilldownId = drilldownId;
    return this;
  }

   /**
   * Id of drilldown widget, if any. Id should be a valid id of an existing widget.
   * @return drilldownId
  **/
  @Schema(description = "Id of drilldown widget, if any. Id should be a valid id of an existing widget.")
  public String getDrilldownId() {
    return drilldownId;
  }

  public void setDrilldownId(String drilldownId) {
    this.drilldownId = drilldownId;
  }

  public ColumnItem hidden(Boolean hidden) {
    this.hidden = hidden;
    return this;
  }

   /**
   * If set to true, hides the column
   * @return hidden
  **/
  @Schema(description = "If set to true, hides the column")
  public Boolean isHidden() {
    return hidden;
  }

  public void setHidden(Boolean hidden) {
    this.hidden = hidden;
  }

  public ColumnItem navigation(String navigation) {
    this.navigation = navigation;
    return this;
  }

   /**
   * Hyperlink of the specified UI page that provides details. If drilldown_id is provided, then navigation cannot be used.
   * @return navigation
  **/
  @Schema(description = "Hyperlink of the specified UI page that provides details. If drilldown_id is provided, then navigation cannot be used.")
  public String getNavigation() {
    return navigation;
  }

  public void setNavigation(String navigation) {
    this.navigation = navigation;
  }

  public ColumnItem columnIdentifier(String columnIdentifier) {
    this.columnIdentifier = columnIdentifier;
    return this;
  }

   /**
   * Identifies the column and used for fetching content upon an user click or drilldown. If column identifier is not provided, the column&#x27;s data will not participate in searches and drilldowns.
   * @return columnIdentifier
  **/
  @Schema(description = "Identifies the column and used for fetching content upon an user click or drilldown. If column identifier is not provided, the column's data will not participate in searches and drilldowns.")
  public String getColumnIdentifier() {
    return columnIdentifier;
  }

  public void setColumnIdentifier(String columnIdentifier) {
    this.columnIdentifier = columnIdentifier;
  }

  public ColumnItem renderConfiguration(List<RenderConfiguration> renderConfiguration) {
    this.renderConfiguration = renderConfiguration;
    return this;
  }

  public ColumnItem addRenderConfigurationItem(RenderConfiguration renderConfigurationItem) {
    if (this.renderConfiguration == null) {
      this.renderConfiguration = new ArrayList<RenderConfiguration>();
    }
    this.renderConfiguration.add(renderConfigurationItem);
    return this;
  }

   /**
   * Render configuration to be applied, if any.
   * @return renderConfiguration
  **/
  @Schema(description = "Render configuration to be applied, if any.")
  public List<RenderConfiguration> getRenderConfiguration() {
    return renderConfiguration;
  }

  public void setRenderConfiguration(List<RenderConfiguration> renderConfiguration) {
    this.renderConfiguration = renderConfiguration;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ColumnItem columnItem = (ColumnItem) o;
    return Objects.equals(this.sortKey, columnItem.sortKey) &&
        Objects.equals(this.type, columnItem.type) &&
        Objects.equals(this.tooltip, columnItem.tooltip) &&
        Objects.equals(this.label, columnItem.label) &&
        Objects.equals(this.field, columnItem.field) &&
        Objects.equals(this.sortAscending, columnItem.sortAscending) &&
        Objects.equals(this.drilldownId, columnItem.drilldownId) &&
        Objects.equals(this.hidden, columnItem.hidden) &&
        Objects.equals(this.navigation, columnItem.navigation) &&
        Objects.equals(this.columnIdentifier, columnItem.columnIdentifier) &&
        Objects.equals(this.renderConfiguration, columnItem.renderConfiguration);
  }

  @Override
  public int hashCode() {
    return Objects.hash(sortKey, type, tooltip, label, field, sortAscending, drilldownId, hidden, navigation, columnIdentifier, renderConfiguration);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ColumnItem {\n");
    
    sb.append("    sortKey: ").append(toIndentedString(sortKey)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    tooltip: ").append(toIndentedString(tooltip)).append("\n");
    sb.append("    label: ").append(toIndentedString(label)).append("\n");
    sb.append("    field: ").append(toIndentedString(field)).append("\n");
    sb.append("    sortAscending: ").append(toIndentedString(sortAscending)).append("\n");
    sb.append("    drilldownId: ").append(toIndentedString(drilldownId)).append("\n");
    sb.append("    hidden: ").append(toIndentedString(hidden)).append("\n");
    sb.append("    navigation: ").append(toIndentedString(navigation)).append("\n");
    sb.append("    columnIdentifier: ").append(toIndentedString(columnIdentifier)).append("\n");
    sb.append("    renderConfiguration: ").append(toIndentedString(renderConfiguration)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
