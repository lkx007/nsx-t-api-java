/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.LbAppProfile;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * LbFastUdpProfile
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class LbFastUdpProfile extends LbAppProfile {
  @SerializedName("idle_timeout")
  private Long idleTimeout = 300l;

  @SerializedName("flow_mirroring_enabled")
  private Boolean flowMirroringEnabled = false;

  public LbFastUdpProfile idleTimeout(Long idleTimeout) {
    this.idleTimeout = idleTimeout;
    return this;
  }

   /**
   * Though UDP is a connectionless protocol, for the purposes of load balancing, all UDP packets with the same flow signature (source and destination IP/ports and IP protocol) received within the idle timeout period are considered to belong to the same connection and are sent to the same backend server. If no packets are received for idle timeout period, the connection (association between flow signature and the selected server) is cleaned up. 
   * minimum: 1
   * maximum: 2147483647
   * @return idleTimeout
  **/
  @Schema(description = "Though UDP is a connectionless protocol, for the purposes of load balancing, all UDP packets with the same flow signature (source and destination IP/ports and IP protocol) received within the idle timeout period are considered to belong to the same connection and are sent to the same backend server. If no packets are received for idle timeout period, the connection (association between flow signature and the selected server) is cleaned up. ")
  public Long getIdleTimeout() {
    return idleTimeout;
  }

  public void setIdleTimeout(Long idleTimeout) {
    this.idleTimeout = idleTimeout;
  }

  public LbFastUdpProfile flowMirroringEnabled(Boolean flowMirroringEnabled) {
    this.flowMirroringEnabled = flowMirroringEnabled;
    return this;
  }

   /**
   * If flow mirroring is enabled, all the flows to the bounded virtual server are mirrored to the standby node. 
   * @return flowMirroringEnabled
  **/
  @Schema(description = "If flow mirroring is enabled, all the flows to the bounded virtual server are mirrored to the standby node. ")
  public Boolean isFlowMirroringEnabled() {
    return flowMirroringEnabled;
  }

  public void setFlowMirroringEnabled(Boolean flowMirroringEnabled) {
    this.flowMirroringEnabled = flowMirroringEnabled;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LbFastUdpProfile lbFastUdpProfile = (LbFastUdpProfile) o;
    return Objects.equals(this.idleTimeout, lbFastUdpProfile.idleTimeout) &&
        Objects.equals(this.flowMirroringEnabled, lbFastUdpProfile.flowMirroringEnabled) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(idleTimeout, flowMirroringEnabled, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LbFastUdpProfile {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    idleTimeout: ").append(toIndentedString(idleTimeout)).append("\n");
    sb.append("    flowMirroringEnabled: ").append(toIndentedString(flowMirroringEnabled)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
