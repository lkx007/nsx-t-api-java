/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.ClusterNodeVMDeploymentConfig;
import io.swagger.client.model.IPSubnet;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * The Vsphere deployment configuration determines where to deploy the cluster node VM through a vCenter server. It contains settings that are applied during install time. If using DHCP, the following fields must be left unset - dns_servers, management_port_subnets, and default_gateway_addresses 
 */
@Schema(description = "The Vsphere deployment configuration determines where to deploy the cluster node VM through a vCenter server. It contains settings that are applied during install time. If using DHCP, the following fields must be left unset - dns_servers, management_port_subnets, and default_gateway_addresses ")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class VsphereClusterNodeVMDeploymentConfig extends ClusterNodeVMDeploymentConfig {
  @SerializedName("dns_servers")
  private List<String> dnsServers = null;

  @SerializedName("search_domains")
  private List<String> searchDomains = null;

  @SerializedName("management_network_id")
  private String managementNetworkId = null;

  @SerializedName("enable_ssh")
  private Boolean enableSsh = false;

  @SerializedName("allow_ssh_root_login")
  private Boolean allowSshRootLogin = false;

  @SerializedName("compute_id")
  private String computeId = null;

  @SerializedName("ntp_servers")
  private List<String> ntpServers = null;

  @SerializedName("vc_id")
  private String vcId = null;

  @SerializedName("storage_id")
  private String storageId = null;

  @SerializedName("default_gateway_addresses")
  private List<String> defaultGatewayAddresses = null;

  @SerializedName("management_port_subnets")
  private List<IPSubnet> managementPortSubnets = null;

  @SerializedName("host_id")
  private String hostId = null;

  @SerializedName("hostname")
  private String hostname = null;

  public VsphereClusterNodeVMDeploymentConfig dnsServers(List<String> dnsServers) {
    this.dnsServers = dnsServers;
    return this;
  }

  public VsphereClusterNodeVMDeploymentConfig addDnsServersItem(String dnsServersItem) {
    if (this.dnsServers == null) {
      this.dnsServers = new ArrayList<String>();
    }
    this.dnsServers.add(dnsServersItem);
    return this;
  }

   /**
   * List of DNS servers. If DHCP is used, the default DNS servers associated with the DHCP server will be used instead. Required if using static IP. 
   * @return dnsServers
  **/
  @Schema(description = "List of DNS servers. If DHCP is used, the default DNS servers associated with the DHCP server will be used instead. Required if using static IP. ")
  public List<String> getDnsServers() {
    return dnsServers;
  }

  public void setDnsServers(List<String> dnsServers) {
    this.dnsServers = dnsServers;
  }

  public VsphereClusterNodeVMDeploymentConfig searchDomains(List<String> searchDomains) {
    this.searchDomains = searchDomains;
    return this;
  }

  public VsphereClusterNodeVMDeploymentConfig addSearchDomainsItem(String searchDomainsItem) {
    if (this.searchDomains == null) {
      this.searchDomains = new ArrayList<String>();
    }
    this.searchDomains.add(searchDomainsItem);
    return this;
  }

   /**
   * List of domain names that are used to complete unqualified host names. 
   * @return searchDomains
  **/
  @Schema(description = "List of domain names that are used to complete unqualified host names. ")
  public List<String> getSearchDomains() {
    return searchDomains;
  }

  public void setSearchDomains(List<String> searchDomains) {
    this.searchDomains = searchDomains;
  }

  public VsphereClusterNodeVMDeploymentConfig managementNetworkId(String managementNetworkId) {
    this.managementNetworkId = managementNetworkId;
    return this;
  }

   /**
   * Distributed portgroup identifier to which the management vnic of cluster node VM will be connected. 
   * @return managementNetworkId
  **/
  @Schema(required = true, description = "Distributed portgroup identifier to which the management vnic of cluster node VM will be connected. ")
  public String getManagementNetworkId() {
    return managementNetworkId;
  }

  public void setManagementNetworkId(String managementNetworkId) {
    this.managementNetworkId = managementNetworkId;
  }

  public VsphereClusterNodeVMDeploymentConfig enableSsh(Boolean enableSsh) {
    this.enableSsh = enableSsh;
    return this;
  }

   /**
   * If true, the SSH service will automatically be started on the VM. Enabling SSH service is not recommended for security reasons. 
   * @return enableSsh
  **/
  @Schema(description = "If true, the SSH service will automatically be started on the VM. Enabling SSH service is not recommended for security reasons. ")
  public Boolean isEnableSsh() {
    return enableSsh;
  }

  public void setEnableSsh(Boolean enableSsh) {
    this.enableSsh = enableSsh;
  }

  public VsphereClusterNodeVMDeploymentConfig allowSshRootLogin(Boolean allowSshRootLogin) {
    this.allowSshRootLogin = allowSshRootLogin;
    return this;
  }

   /**
   * If true, the root user will be allowed to log into the VM. Allowing root SSH logins is not recommended for security reasons. 
   * @return allowSshRootLogin
  **/
  @Schema(description = "If true, the root user will be allowed to log into the VM. Allowing root SSH logins is not recommended for security reasons. ")
  public Boolean isAllowSshRootLogin() {
    return allowSshRootLogin;
  }

  public void setAllowSshRootLogin(Boolean allowSshRootLogin) {
    this.allowSshRootLogin = allowSshRootLogin;
  }

  public VsphereClusterNodeVMDeploymentConfig computeId(String computeId) {
    this.computeId = computeId;
    return this;
  }

   /**
   * The cluster node VM will be deployed on the specified cluster or resourcepool for specified VC server. 
   * @return computeId
  **/
  @Schema(required = true, description = "The cluster node VM will be deployed on the specified cluster or resourcepool for specified VC server. ")
  public String getComputeId() {
    return computeId;
  }

  public void setComputeId(String computeId) {
    this.computeId = computeId;
  }

  public VsphereClusterNodeVMDeploymentConfig ntpServers(List<String> ntpServers) {
    this.ntpServers = ntpServers;
    return this;
  }

  public VsphereClusterNodeVMDeploymentConfig addNtpServersItem(String ntpServersItem) {
    if (this.ntpServers == null) {
      this.ntpServers = new ArrayList<String>();
    }
    this.ntpServers.add(ntpServersItem);
    return this;
  }

   /**
   * List of NTP servers. To use hostnames, a DNS server must be defined. If not using DHCP, a DNS server should be specified under dns_servers. 
   * @return ntpServers
  **/
  @Schema(description = "List of NTP servers. To use hostnames, a DNS server must be defined. If not using DHCP, a DNS server should be specified under dns_servers. ")
  public List<String> getNtpServers() {
    return ntpServers;
  }

  public void setNtpServers(List<String> ntpServers) {
    this.ntpServers = ntpServers;
  }

  public VsphereClusterNodeVMDeploymentConfig vcId(String vcId) {
    this.vcId = vcId;
    return this;
  }

   /**
   * The VC-specific identifiers will be resolved on this VC, so all other identifiers specified in the config must belong to this vCenter server. 
   * @return vcId
  **/
  @Schema(required = true, description = "The VC-specific identifiers will be resolved on this VC, so all other identifiers specified in the config must belong to this vCenter server. ")
  public String getVcId() {
    return vcId;
  }

  public void setVcId(String vcId) {
    this.vcId = vcId;
  }

  public VsphereClusterNodeVMDeploymentConfig storageId(String storageId) {
    this.storageId = storageId;
    return this;
  }

   /**
   * The cluster node VM will be deployed on the specified datastore in the specified VC server. User must ensure that storage is accessible by the specified cluster/host. 
   * @return storageId
  **/
  @Schema(required = true, description = "The cluster node VM will be deployed on the specified datastore in the specified VC server. User must ensure that storage is accessible by the specified cluster/host. ")
  public String getStorageId() {
    return storageId;
  }

  public void setStorageId(String storageId) {
    this.storageId = storageId;
  }

  public VsphereClusterNodeVMDeploymentConfig defaultGatewayAddresses(List<String> defaultGatewayAddresses) {
    this.defaultGatewayAddresses = defaultGatewayAddresses;
    return this;
  }

  public VsphereClusterNodeVMDeploymentConfig addDefaultGatewayAddressesItem(String defaultGatewayAddressesItem) {
    if (this.defaultGatewayAddresses == null) {
      this.defaultGatewayAddresses = new ArrayList<String>();
    }
    this.defaultGatewayAddresses.add(defaultGatewayAddressesItem);
    return this;
  }

   /**
   * The default gateway for the VM to be deployed must be specified if all the other VMs it communicates with are not in the same subnet. Do not specify this field and management_port_subnets to use DHCP. Note: only single IPv4 default gateway address is supported and it must belong to management network. IMPORTANT: VMs deployed using DHCP are currently not supported, so this parameter should be specified. 
   * @return defaultGatewayAddresses
  **/
  @Schema(description = "The default gateway for the VM to be deployed must be specified if all the other VMs it communicates with are not in the same subnet. Do not specify this field and management_port_subnets to use DHCP. Note: only single IPv4 default gateway address is supported and it must belong to management network. IMPORTANT: VMs deployed using DHCP are currently not supported, so this parameter should be specified. ")
  public List<String> getDefaultGatewayAddresses() {
    return defaultGatewayAddresses;
  }

  public void setDefaultGatewayAddresses(List<String> defaultGatewayAddresses) {
    this.defaultGatewayAddresses = defaultGatewayAddresses;
  }

  public VsphereClusterNodeVMDeploymentConfig managementPortSubnets(List<IPSubnet> managementPortSubnets) {
    this.managementPortSubnets = managementPortSubnets;
    return this;
  }

  public VsphereClusterNodeVMDeploymentConfig addManagementPortSubnetsItem(IPSubnet managementPortSubnetsItem) {
    if (this.managementPortSubnets == null) {
      this.managementPortSubnets = new ArrayList<IPSubnet>();
    }
    this.managementPortSubnets.add(managementPortSubnetsItem);
    return this;
  }

   /**
   * IP Address and subnet configuration for the management port. Do not specify this field and default_gateway_addresses to use DHCP. Note: only one IPv4 address is supported for the management port. IMPORTANT: VMs deployed using DHCP are currently not supported, so this parameter should be specified. 
   * @return managementPortSubnets
  **/
  @Schema(description = "IP Address and subnet configuration for the management port. Do not specify this field and default_gateway_addresses to use DHCP. Note: only one IPv4 address is supported for the management port. IMPORTANT: VMs deployed using DHCP are currently not supported, so this parameter should be specified. ")
  public List<IPSubnet> getManagementPortSubnets() {
    return managementPortSubnets;
  }

  public void setManagementPortSubnets(List<IPSubnet> managementPortSubnets) {
    this.managementPortSubnets = managementPortSubnets;
  }

  public VsphereClusterNodeVMDeploymentConfig hostId(String hostId) {
    this.hostId = hostId;
    return this;
  }

   /**
   * The cluster node VM will be deployed on the specified host in the specified VC server within the cluster if host_id is specified. Note: User must ensure that storage and specified networks are accessible by this host. 
   * @return hostId
  **/
  @Schema(description = "The cluster node VM will be deployed on the specified host in the specified VC server within the cluster if host_id is specified. Note: User must ensure that storage and specified networks are accessible by this host. ")
  public String getHostId() {
    return hostId;
  }

  public void setHostId(String hostId) {
    this.hostId = hostId;
  }

  public VsphereClusterNodeVMDeploymentConfig hostname(String hostname) {
    this.hostname = hostname;
    return this;
  }

   /**
   * Desired host name/FQDN for the VM to be deployed
   * @return hostname
  **/
  @Schema(required = true, description = "Desired host name/FQDN for the VM to be deployed")
  public String getHostname() {
    return hostname;
  }

  public void setHostname(String hostname) {
    this.hostname = hostname;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VsphereClusterNodeVMDeploymentConfig vsphereClusterNodeVMDeploymentConfig = (VsphereClusterNodeVMDeploymentConfig) o;
    return Objects.equals(this.dnsServers, vsphereClusterNodeVMDeploymentConfig.dnsServers) &&
        Objects.equals(this.searchDomains, vsphereClusterNodeVMDeploymentConfig.searchDomains) &&
        Objects.equals(this.managementNetworkId, vsphereClusterNodeVMDeploymentConfig.managementNetworkId) &&
        Objects.equals(this.enableSsh, vsphereClusterNodeVMDeploymentConfig.enableSsh) &&
        Objects.equals(this.allowSshRootLogin, vsphereClusterNodeVMDeploymentConfig.allowSshRootLogin) &&
        Objects.equals(this.computeId, vsphereClusterNodeVMDeploymentConfig.computeId) &&
        Objects.equals(this.ntpServers, vsphereClusterNodeVMDeploymentConfig.ntpServers) &&
        Objects.equals(this.vcId, vsphereClusterNodeVMDeploymentConfig.vcId) &&
        Objects.equals(this.storageId, vsphereClusterNodeVMDeploymentConfig.storageId) &&
        Objects.equals(this.defaultGatewayAddresses, vsphereClusterNodeVMDeploymentConfig.defaultGatewayAddresses) &&
        Objects.equals(this.managementPortSubnets, vsphereClusterNodeVMDeploymentConfig.managementPortSubnets) &&
        Objects.equals(this.hostId, vsphereClusterNodeVMDeploymentConfig.hostId) &&
        Objects.equals(this.hostname, vsphereClusterNodeVMDeploymentConfig.hostname) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dnsServers, searchDomains, managementNetworkId, enableSsh, allowSshRootLogin, computeId, ntpServers, vcId, storageId, defaultGatewayAddresses, managementPortSubnets, hostId, hostname, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VsphereClusterNodeVMDeploymentConfig {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    dnsServers: ").append(toIndentedString(dnsServers)).append("\n");
    sb.append("    searchDomains: ").append(toIndentedString(searchDomains)).append("\n");
    sb.append("    managementNetworkId: ").append(toIndentedString(managementNetworkId)).append("\n");
    sb.append("    enableSsh: ").append(toIndentedString(enableSsh)).append("\n");
    sb.append("    allowSshRootLogin: ").append(toIndentedString(allowSshRootLogin)).append("\n");
    sb.append("    computeId: ").append(toIndentedString(computeId)).append("\n");
    sb.append("    ntpServers: ").append(toIndentedString(ntpServers)).append("\n");
    sb.append("    vcId: ").append(toIndentedString(vcId)).append("\n");
    sb.append("    storageId: ").append(toIndentedString(storageId)).append("\n");
    sb.append("    defaultGatewayAddresses: ").append(toIndentedString(defaultGatewayAddresses)).append("\n");
    sb.append("    managementPortSubnets: ").append(toIndentedString(managementPortSubnets)).append("\n");
    sb.append("    hostId: ").append(toIndentedString(hostId)).append("\n");
    sb.append("    hostname: ").append(toIndentedString(hostname)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
