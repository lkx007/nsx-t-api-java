/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * Source of the Alarm
 */
@Schema(description = "Source of the Alarm")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class AlarmSource {
  @SerializedName("thread_id")
  private String threadId = null;

  @SerializedName("interface_name")
  private String interfaceName = null;

  @SerializedName("quiesce_blocked_time")
  private Long quiesceBlockedTime = null;

  @SerializedName("local_ip")
  private String localIp = null;

  @SerializedName("id")
  private String id = null;

  /**
   * Ip address type v4, v6 etc.
   */
  @JsonAdapter(IpAddressTypeEnum.Adapter.class)
  public enum IpAddressTypeEnum {
    IPV4("IPV4"),
    IPV6("IPV6");

    private String value;

    IpAddressTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static IpAddressTypeEnum fromValue(String text) {
      for (IpAddressTypeEnum b : IpAddressTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<IpAddressTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final IpAddressTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public IpAddressTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return IpAddressTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("ip_address_type")
  private IpAddressTypeEnum ipAddressType = null;

  @SerializedName("process_name")
  private String processName = null;

  @SerializedName("ip_address")
  private String ipAddress = null;

  @SerializedName("mount")
  private String mount = null;

  @SerializedName("peer_ip")
  private String peerIp = null;

   /**
   * The datapath thread name ID
   * @return threadId
  **/
  @Schema(description = "The datapath thread name ID")
  public String getThreadId() {
    return threadId;
  }

   /**
   * The NIC interface name
   * @return interfaceName
  **/
  @Schema(description = "The NIC interface name")
  public String getInterfaceName() {
    return interfaceName;
  }

   /**
   * Time in milliseconds that elapsed in blocked state
   * @return quiesceBlockedTime
  **/
  @Schema(description = "Time in milliseconds that elapsed in blocked state")
  public Long getQuiesceBlockedTime() {
    return quiesceBlockedTime;
  }

   /**
   * VPN session/tunnel etc. local Ip(v4 or v6) address
   * @return localIp
  **/
  @Schema(description = "VPN session/tunnel etc. local Ip(v4 or v6) address")
  public String getLocalIp() {
    return localIp;
  }

   /**
   * Identifier of the Alarm source entity for e.g. Vpn session id, Vpn tunnel id etc.
   * @return id
  **/
  @Schema(description = "Identifier of the Alarm source entity for e.g. Vpn session id, Vpn tunnel id etc.")
  public String getId() {
    return id;
  }

   /**
   * Ip address type v4, v6 etc.
   * @return ipAddressType
  **/
  @Schema(description = "Ip address type v4, v6 etc.")
  public IpAddressTypeEnum getIpAddressType() {
    return ipAddressType;
  }

   /**
   * Name of the process which is blocked from entering quiesce state
   * @return processName
  **/
  @Schema(description = "Name of the process which is blocked from entering quiesce state")
  public String getProcessName() {
    return processName;
  }

   /**
   * Ip address
   * @return ipAddress
  **/
  @Schema(description = "Ip address")
  public String getIpAddress() {
    return ipAddress;
  }

   /**
   * Filesystem mount name
   * @return mount
  **/
  @Schema(description = "Filesystem mount name")
  public String getMount() {
    return mount;
  }

   /**
   * VPN session/tunnel etc. peer Ip(v4 or v6) address
   * @return peerIp
  **/
  @Schema(description = "VPN session/tunnel etc. peer Ip(v4 or v6) address")
  public String getPeerIp() {
    return peerIp;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AlarmSource alarmSource = (AlarmSource) o;
    return Objects.equals(this.threadId, alarmSource.threadId) &&
        Objects.equals(this.interfaceName, alarmSource.interfaceName) &&
        Objects.equals(this.quiesceBlockedTime, alarmSource.quiesceBlockedTime) &&
        Objects.equals(this.localIp, alarmSource.localIp) &&
        Objects.equals(this.id, alarmSource.id) &&
        Objects.equals(this.ipAddressType, alarmSource.ipAddressType) &&
        Objects.equals(this.processName, alarmSource.processName) &&
        Objects.equals(this.ipAddress, alarmSource.ipAddress) &&
        Objects.equals(this.mount, alarmSource.mount) &&
        Objects.equals(this.peerIp, alarmSource.peerIp);
  }

  @Override
  public int hashCode() {
    return Objects.hash(threadId, interfaceName, quiesceBlockedTime, localIp, id, ipAddressType, processName, ipAddress, mount, peerIp);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AlarmSource {\n");
    
    sb.append("    threadId: ").append(toIndentedString(threadId)).append("\n");
    sb.append("    interfaceName: ").append(toIndentedString(interfaceName)).append("\n");
    sb.append("    quiesceBlockedTime: ").append(toIndentedString(quiesceBlockedTime)).append("\n");
    sb.append("    localIp: ").append(toIndentedString(localIp)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    ipAddressType: ").append(toIndentedString(ipAddressType)).append("\n");
    sb.append("    processName: ").append(toIndentedString(processName)).append("\n");
    sb.append("    ipAddress: ").append(toIndentedString(ipAddress)).append("\n");
    sb.append("    mount: ").append(toIndentedString(mount)).append("\n");
    sb.append("    peerIp: ").append(toIndentedString(peerIp)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
