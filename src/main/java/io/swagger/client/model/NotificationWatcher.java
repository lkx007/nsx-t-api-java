/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.ManagedResource;
import io.swagger.client.model.NotificationAuthenticationScheme;
import io.swagger.client.model.Tag;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.List;
/**
 * NotificationWatcher
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class NotificationWatcher extends ManagedResource {
  @SerializedName("description")
  private String description = null;

  @SerializedName("send_timeout")
  private Long sendTimeout = 30l;

  @SerializedName("uri")
  private String uri = null;

  @SerializedName("id")
  private String id = null;

  @SerializedName("certificate_sha256_thumbprint")
  private String certificateSha256Thumbprint = null;

  /**
   * Type of method notification requests should be made on the specified server. The value must be set to POST.
   */
  @JsonAdapter(MethodEnum.Adapter.class)
  public enum MethodEnum {
    POST("POST");

    private String value;

    MethodEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static MethodEnum fromValue(String text) {
      for (MethodEnum b : MethodEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<MethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MethodEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return MethodEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("method")
  private MethodEnum method = null;

  @SerializedName("send_interval")
  private Long sendInterval = null;

  @SerializedName("max_send_uri_count")
  private Long maxSendUriCount = 5000l;

  @SerializedName("authentication_scheme")
  private NotificationAuthenticationScheme authenticationScheme = null;

  @SerializedName("server")
  private String server = null;

  @SerializedName("port")
  private Long port = null;

  @SerializedName("use_https")
  private Boolean useHttps = false;

  public NotificationWatcher description(String description) {
    this.description = description;
    return this;
  }

   /**
   * Optional description that can be associated with this NotificationWatcher.
   * @return description
  **/
  @Schema(description = "Optional description that can be associated with this NotificationWatcher.")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public NotificationWatcher sendTimeout(Long sendTimeout) {
    this.sendTimeout = sendTimeout;
    return this;
  }

   /**
   * Optional time duration (in seconds) to specify request timeout to notification watcher. If the send reaches the timeout, will try to send refresh_needed as true in the next time interval. The default value is 30 seconds.
   * minimum: 1
   * @return sendTimeout
  **/
  @Schema(description = "Optional time duration (in seconds) to specify request timeout to notification watcher. If the send reaches the timeout, will try to send refresh_needed as true in the next time interval. The default value is 30 seconds.")
  public Long getSendTimeout() {
    return sendTimeout;
  }

  public void setSendTimeout(Long sendTimeout) {
    this.sendTimeout = sendTimeout;
  }

  public NotificationWatcher uri(String uri) {
    this.uri = uri;
    return this;
  }

   /**
   * URI notification requests should be made on the specified server.
   * @return uri
  **/
  @Schema(required = true, description = "URI notification requests should be made on the specified server.")
  public String getUri() {
    return uri;
  }

  public void setUri(String uri) {
    this.uri = uri;
  }

   /**
   * System generated identifier to identify a notification watcher uniquely. 
   * @return id
  **/
  @Schema(description = "System generated identifier to identify a notification watcher uniquely. ")
  public String getId() {
    return id;
  }

  public NotificationWatcher certificateSha256Thumbprint(String certificateSha256Thumbprint) {
    this.certificateSha256Thumbprint = certificateSha256Thumbprint;
    return this;
  }

   /**
   * Contains the hex-encoded SHA256 thumbprint of the HTTPS certificate. It must be specified if use_https is set to true.
   * @return certificateSha256Thumbprint
  **/
  @Schema(description = "Contains the hex-encoded SHA256 thumbprint of the HTTPS certificate. It must be specified if use_https is set to true.")
  public String getCertificateSha256Thumbprint() {
    return certificateSha256Thumbprint;
  }

  public void setCertificateSha256Thumbprint(String certificateSha256Thumbprint) {
    this.certificateSha256Thumbprint = certificateSha256Thumbprint;
  }

  public NotificationWatcher method(MethodEnum method) {
    this.method = method;
    return this;
  }

   /**
   * Type of method notification requests should be made on the specified server. The value must be set to POST.
   * @return method
  **/
  @Schema(required = true, description = "Type of method notification requests should be made on the specified server. The value must be set to POST.")
  public MethodEnum getMethod() {
    return method;
  }

  public void setMethod(MethodEnum method) {
    this.method = method;
  }

  public NotificationWatcher sendInterval(Long sendInterval) {
    this.sendInterval = sendInterval;
    return this;
  }

   /**
   * Optional time interval (in seconds) for which notification URIs will be accumulated. At the end of the time interval the accumulated notification URIs will be sent to this NotificationWatcher in the form of zero (nothing accumulated) or more notification requests as soon as possible. If it is not specified, the NotificationWatcher should expected to receive notifications at any time.
   * minimum: 30
   * @return sendInterval
  **/
  @Schema(description = "Optional time interval (in seconds) for which notification URIs will be accumulated. At the end of the time interval the accumulated notification URIs will be sent to this NotificationWatcher in the form of zero (nothing accumulated) or more notification requests as soon as possible. If it is not specified, the NotificationWatcher should expected to receive notifications at any time.")
  public Long getSendInterval() {
    return sendInterval;
  }

  public void setSendInterval(Long sendInterval) {
    this.sendInterval = sendInterval;
  }

  public NotificationWatcher maxSendUriCount(Long maxSendUriCount) {
    this.maxSendUriCount = maxSendUriCount;
    return this;
  }

   /**
   * If the number of notification URIs accumulated in specified send_interval exceeds max_send_uri_count, then multiple notification requests (each with max_send_uri_count or less number of notification URIs) will be sent to this NotificationWatcher. The default value is 5000.
   * minimum: 1
   * maximum: 5000
   * @return maxSendUriCount
  **/
  @Schema(description = "If the number of notification URIs accumulated in specified send_interval exceeds max_send_uri_count, then multiple notification requests (each with max_send_uri_count or less number of notification URIs) will be sent to this NotificationWatcher. The default value is 5000.")
  public Long getMaxSendUriCount() {
    return maxSendUriCount;
  }

  public void setMaxSendUriCount(Long maxSendUriCount) {
    this.maxSendUriCount = maxSendUriCount;
  }

  public NotificationWatcher authenticationScheme(NotificationAuthenticationScheme authenticationScheme) {
    this.authenticationScheme = authenticationScheme;
    return this;
  }

   /**
   * Get authenticationScheme
   * @return authenticationScheme
  **/
  @Schema(required = true, description = "")
  public NotificationAuthenticationScheme getAuthenticationScheme() {
    return authenticationScheme;
  }

  public void setAuthenticationScheme(NotificationAuthenticationScheme authenticationScheme) {
    this.authenticationScheme = authenticationScheme;
  }

  public NotificationWatcher server(String server) {
    this.server = server;
    return this;
  }

   /**
   * IP address or fully qualified domain name of the partner/customer watcher.
   * @return server
  **/
  @Schema(required = true, description = "IP address or fully qualified domain name of the partner/customer watcher.")
  public String getServer() {
    return server;
  }

  public void setServer(String server) {
    this.server = server;
  }

  public NotificationWatcher port(Long port) {
    this.port = port;
    return this;
  }

   /**
   * Optional integer port value to specify a non-standard HTTP or HTTPS port.
   * minimum: 0
   * maximum: 65535
   * @return port
  **/
  @Schema(description = "Optional integer port value to specify a non-standard HTTP or HTTPS port.")
  public Long getPort() {
    return port;
  }

  public void setPort(Long port) {
    this.port = port;
  }

  public NotificationWatcher useHttps(Boolean useHttps) {
    this.useHttps = useHttps;
    return this;
  }

   /**
   * Optional field, when set to true indicates REST API server should use HTTPS.
   * @return useHttps
  **/
  @Schema(description = "Optional field, when set to true indicates REST API server should use HTTPS.")
  public Boolean isUseHttps() {
    return useHttps;
  }

  public void setUseHttps(Boolean useHttps) {
    this.useHttps = useHttps;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NotificationWatcher notificationWatcher = (NotificationWatcher) o;
    return Objects.equals(this.description, notificationWatcher.description) &&
        Objects.equals(this.sendTimeout, notificationWatcher.sendTimeout) &&
        Objects.equals(this.uri, notificationWatcher.uri) &&
        Objects.equals(this.id, notificationWatcher.id) &&
        Objects.equals(this.certificateSha256Thumbprint, notificationWatcher.certificateSha256Thumbprint) &&
        Objects.equals(this.method, notificationWatcher.method) &&
        Objects.equals(this.sendInterval, notificationWatcher.sendInterval) &&
        Objects.equals(this.maxSendUriCount, notificationWatcher.maxSendUriCount) &&
        Objects.equals(this.authenticationScheme, notificationWatcher.authenticationScheme) &&
        Objects.equals(this.server, notificationWatcher.server) &&
        Objects.equals(this.port, notificationWatcher.port) &&
        Objects.equals(this.useHttps, notificationWatcher.useHttps) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(description, sendTimeout, uri, id, certificateSha256Thumbprint, method, sendInterval, maxSendUriCount, authenticationScheme, server, port, useHttps, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NotificationWatcher {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    sendTimeout: ").append(toIndentedString(sendTimeout)).append("\n");
    sb.append("    uri: ").append(toIndentedString(uri)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    certificateSha256Thumbprint: ").append(toIndentedString(certificateSha256Thumbprint)).append("\n");
    sb.append("    method: ").append(toIndentedString(method)).append("\n");
    sb.append("    sendInterval: ").append(toIndentedString(sendInterval)).append("\n");
    sb.append("    maxSendUriCount: ").append(toIndentedString(maxSendUriCount)).append("\n");
    sb.append("    authenticationScheme: ").append(toIndentedString(authenticationScheme)).append("\n");
    sb.append("    server: ").append(toIndentedString(server)).append("\n");
    sb.append("    port: ").append(toIndentedString(port)).append("\n");
    sb.append("    useHttps: ").append(toIndentedString(useHttps)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
