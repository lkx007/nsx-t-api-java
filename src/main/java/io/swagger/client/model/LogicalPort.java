/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.ExtraConfig;
import io.swagger.client.model.LogicalPortAttachment;
import io.swagger.client.model.ManagedResource;
import io.swagger.client.model.PacketAddressClassifier;
import io.swagger.client.model.SwitchingProfileTypeIdEntry;
import io.swagger.client.model.Tag;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * LogicalPort
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class LogicalPort extends ManagedResource {
  @SerializedName("logical_switch_id")
  private String logicalSwitchId = null;

  /**
   * Set initial state when a new logical port is created. &#x27;UNBLOCKED_VLAN&#x27; means new port will be unblocked on traffic in creation, also VLAN will be set with corresponding logical switch setting. This port setting can only be configured at port creation (POST), and cannot be modified. 
   */
  @JsonAdapter(InitStateEnum.Adapter.class)
  public enum InitStateEnum {
    VLAN("UNBLOCKED_VLAN");

    private String value;

    InitStateEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static InitStateEnum fromValue(String text) {
      for (InitStateEnum b : InitStateEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<InitStateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final InitStateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public InitStateEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return InitStateEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("init_state")
  private InitStateEnum initState = null;

  @SerializedName("switching_profile_ids")
  private List<SwitchingProfileTypeIdEntry> switchingProfileIds = null;

  @SerializedName("attachment")
  private LogicalPortAttachment attachment = null;

  /**
   * Represents Desired state of the logical port
   */
  @JsonAdapter(AdminStateEnum.Adapter.class)
  public enum AdminStateEnum {
    UP("UP"),
    DOWN("DOWN");

    private String value;

    AdminStateEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static AdminStateEnum fromValue(String text) {
      for (AdminStateEnum b : AdminStateEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<AdminStateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AdminStateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AdminStateEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return AdminStateEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("admin_state")
  private AdminStateEnum adminState = null;

  @SerializedName("extra_configs")
  private List<ExtraConfig> extraConfigs = null;

  @SerializedName("address_bindings")
  private List<PacketAddressClassifier> addressBindings = null;

  @SerializedName("ignore_address_bindings")
  private List<PacketAddressClassifier> ignoreAddressBindings = null;

  public LogicalPort logicalSwitchId(String logicalSwitchId) {
    this.logicalSwitchId = logicalSwitchId;
    return this;
  }

   /**
   * Id of the Logical switch that this port belongs to.
   * @return logicalSwitchId
  **/
  @Schema(required = true, description = "Id of the Logical switch that this port belongs to.")
  public String getLogicalSwitchId() {
    return logicalSwitchId;
  }

  public void setLogicalSwitchId(String logicalSwitchId) {
    this.logicalSwitchId = logicalSwitchId;
  }

  public LogicalPort initState(InitStateEnum initState) {
    this.initState = initState;
    return this;
  }

   /**
   * Set initial state when a new logical port is created. &#x27;UNBLOCKED_VLAN&#x27; means new port will be unblocked on traffic in creation, also VLAN will be set with corresponding logical switch setting. This port setting can only be configured at port creation (POST), and cannot be modified. 
   * @return initState
  **/
  @Schema(description = "Set initial state when a new logical port is created. 'UNBLOCKED_VLAN' means new port will be unblocked on traffic in creation, also VLAN will be set with corresponding logical switch setting. This port setting can only be configured at port creation (POST), and cannot be modified. ")
  public InitStateEnum getInitState() {
    return initState;
  }

  public void setInitState(InitStateEnum initState) {
    this.initState = initState;
  }

  public LogicalPort switchingProfileIds(List<SwitchingProfileTypeIdEntry> switchingProfileIds) {
    this.switchingProfileIds = switchingProfileIds;
    return this;
  }

  public LogicalPort addSwitchingProfileIdsItem(SwitchingProfileTypeIdEntry switchingProfileIdsItem) {
    if (this.switchingProfileIds == null) {
      this.switchingProfileIds = new ArrayList<SwitchingProfileTypeIdEntry>();
    }
    this.switchingProfileIds.add(switchingProfileIdsItem);
    return this;
  }

   /**
   * Get switchingProfileIds
   * @return switchingProfileIds
  **/
  @Schema(description = "")
  public List<SwitchingProfileTypeIdEntry> getSwitchingProfileIds() {
    return switchingProfileIds;
  }

  public void setSwitchingProfileIds(List<SwitchingProfileTypeIdEntry> switchingProfileIds) {
    this.switchingProfileIds = switchingProfileIds;
  }

  public LogicalPort attachment(LogicalPortAttachment attachment) {
    this.attachment = attachment;
    return this;
  }

   /**
   * Get attachment
   * @return attachment
  **/
  @Schema(description = "")
  public LogicalPortAttachment getAttachment() {
    return attachment;
  }

  public void setAttachment(LogicalPortAttachment attachment) {
    this.attachment = attachment;
  }

  public LogicalPort adminState(AdminStateEnum adminState) {
    this.adminState = adminState;
    return this;
  }

   /**
   * Represents Desired state of the logical port
   * @return adminState
  **/
  @Schema(required = true, description = "Represents Desired state of the logical port")
  public AdminStateEnum getAdminState() {
    return adminState;
  }

  public void setAdminState(AdminStateEnum adminState) {
    this.adminState = adminState;
  }

  public LogicalPort extraConfigs(List<ExtraConfig> extraConfigs) {
    this.extraConfigs = extraConfigs;
    return this;
  }

  public LogicalPort addExtraConfigsItem(ExtraConfig extraConfigsItem) {
    if (this.extraConfigs == null) {
      this.extraConfigs = new ArrayList<ExtraConfig>();
    }
    this.extraConfigs.add(extraConfigsItem);
    return this;
  }

   /**
   * This property could be used for vendor specific configuration in key value string pairs. Logical port setting will override logical switch setting if the same key was set on both logical switch and logical port. 
   * @return extraConfigs
  **/
  @Schema(description = "This property could be used for vendor specific configuration in key value string pairs. Logical port setting will override logical switch setting if the same key was set on both logical switch and logical port. ")
  public List<ExtraConfig> getExtraConfigs() {
    return extraConfigs;
  }

  public void setExtraConfigs(List<ExtraConfig> extraConfigs) {
    this.extraConfigs = extraConfigs;
  }

  public LogicalPort addressBindings(List<PacketAddressClassifier> addressBindings) {
    this.addressBindings = addressBindings;
    return this;
  }

  public LogicalPort addAddressBindingsItem(PacketAddressClassifier addressBindingsItem) {
    if (this.addressBindings == null) {
      this.addressBindings = new ArrayList<PacketAddressClassifier>();
    }
    this.addressBindings.add(addressBindingsItem);
    return this;
  }

   /**
   * Each address binding must contain both an IPElement and MAC address. VLAN ID is optional. This binding configuration can be used by features such as spoof-guard and overrides any discovered bindings. Any non unique entries are deduplicated to generate a unique set of address bindings and then stored. For IPv6 addresses, a subnet address cannot have host bits set. A maximum of 128 unique address bindings is allowed per port. 
   * @return addressBindings
  **/
  @Schema(description = "Each address binding must contain both an IPElement and MAC address. VLAN ID is optional. This binding configuration can be used by features such as spoof-guard and overrides any discovered bindings. Any non unique entries are deduplicated to generate a unique set of address bindings and then stored. For IPv6 addresses, a subnet address cannot have host bits set. A maximum of 128 unique address bindings is allowed per port. ")
  public List<PacketAddressClassifier> getAddressBindings() {
    return addressBindings;
  }

  public void setAddressBindings(List<PacketAddressClassifier> addressBindings) {
    this.addressBindings = addressBindings;
  }

  public LogicalPort ignoreAddressBindings(List<PacketAddressClassifier> ignoreAddressBindings) {
    this.ignoreAddressBindings = ignoreAddressBindings;
    return this;
  }

  public LogicalPort addIgnoreAddressBindingsItem(PacketAddressClassifier ignoreAddressBindingsItem) {
    if (this.ignoreAddressBindings == null) {
      this.ignoreAddressBindings = new ArrayList<PacketAddressClassifier>();
    }
    this.ignoreAddressBindings.add(ignoreAddressBindingsItem);
    return this;
  }

   /**
   * IP Discovery module uses various mechanisms to discover address bindings being used on each port. If a user would like to ignore any specific discovered address bindings or prevent the discovery of a particular set of discovered bindings, then those address bindings can be provided here. Currently IP range in CIDR format is not supported. 
   * @return ignoreAddressBindings
  **/
  @Schema(description = "IP Discovery module uses various mechanisms to discover address bindings being used on each port. If a user would like to ignore any specific discovered address bindings or prevent the discovery of a particular set of discovered bindings, then those address bindings can be provided here. Currently IP range in CIDR format is not supported. ")
  public List<PacketAddressClassifier> getIgnoreAddressBindings() {
    return ignoreAddressBindings;
  }

  public void setIgnoreAddressBindings(List<PacketAddressClassifier> ignoreAddressBindings) {
    this.ignoreAddressBindings = ignoreAddressBindings;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LogicalPort logicalPort = (LogicalPort) o;
    return Objects.equals(this.logicalSwitchId, logicalPort.logicalSwitchId) &&
        Objects.equals(this.initState, logicalPort.initState) &&
        Objects.equals(this.switchingProfileIds, logicalPort.switchingProfileIds) &&
        Objects.equals(this.attachment, logicalPort.attachment) &&
        Objects.equals(this.adminState, logicalPort.adminState) &&
        Objects.equals(this.extraConfigs, logicalPort.extraConfigs) &&
        Objects.equals(this.addressBindings, logicalPort.addressBindings) &&
        Objects.equals(this.ignoreAddressBindings, logicalPort.ignoreAddressBindings) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(logicalSwitchId, initState, switchingProfileIds, attachment, adminState, extraConfigs, addressBindings, ignoreAddressBindings, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LogicalPort {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    logicalSwitchId: ").append(toIndentedString(logicalSwitchId)).append("\n");
    sb.append("    initState: ").append(toIndentedString(initState)).append("\n");
    sb.append("    switchingProfileIds: ").append(toIndentedString(switchingProfileIds)).append("\n");
    sb.append("    attachment: ").append(toIndentedString(attachment)).append("\n");
    sb.append("    adminState: ").append(toIndentedString(adminState)).append("\n");
    sb.append("    extraConfigs: ").append(toIndentedString(extraConfigs)).append("\n");
    sb.append("    addressBindings: ").append(toIndentedString(addressBindings)).append("\n");
    sb.append("    ignoreAddressBindings: ").append(toIndentedString(ignoreAddressBindings)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
