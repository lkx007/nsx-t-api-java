/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.ManagedResource;
import io.swagger.client.model.Tag;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * Defines if service running as server or client Also defines all the common properties for the multiple L2VpnSessions associated with this service.
 */
@Schema(description = "Defines if service running as server or client Also defines all the common properties for the multiple L2VpnSessions associated with this service.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class L2VpnService extends ManagedResource {
  @SerializedName("enable_full_mesh")
  private Boolean enableFullMesh = false;

  @SerializedName("enable_hub")
  private Boolean enableHub = false;

  @SerializedName("logical_router_id")
  private String logicalRouterId = null;

  /**
   * Specify an L2VPN service mode as SERVER or CLIENT. L2VPN service in SERVER mode requires user to configure L2VPN session explicitly. L2VPN service in CLIENT mode can use peercode generated from SERVER to configure L2VPN session. 
   */
  @JsonAdapter(ModeEnum.Adapter.class)
  public enum ModeEnum {
    SERVER("SERVER"),
    CLIENT("CLIENT");

    private String value;

    ModeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ModeEnum fromValue(String text) {
      for (ModeEnum b : ModeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ModeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ModeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("mode")
  private ModeEnum mode = ModeEnum.SERVER;

  @SerializedName("logical_tap_ip_pool")
  private List<String> logicalTapIpPool = null;

  public L2VpnService enableFullMesh(Boolean enableFullMesh) {
    this.enableFullMesh = enableFullMesh;
    return this;
  }

   /**
   * Full mesh topology auto disables traffic replication between connected peers. However, this property is deprecated. Please refer enable_hub property instead to control client to client forwarding via the server. The value of enable_full_mesh will not be used anymore. If enable_hub is not provided explicitly, the default value of it will be used. 
   * @return enableFullMesh
  **/
  @Schema(description = "Full mesh topology auto disables traffic replication between connected peers. However, this property is deprecated. Please refer enable_hub property instead to control client to client forwarding via the server. The value of enable_full_mesh will not be used anymore. If enable_hub is not provided explicitly, the default value of it will be used. ")
  public Boolean isEnableFullMesh() {
    return enableFullMesh;
  }

  public void setEnableFullMesh(Boolean enableFullMesh) {
    this.enableFullMesh = enableFullMesh;
  }

  public L2VpnService enableHub(Boolean enableHub) {
    this.enableHub = enableHub;
    return this;
  }

   /**
   * This property only applies in SERVER mode. If set to true, traffic from any client will be replicated to all other clients. If set to false, traffic received from clients is only replicated to the local VPN endpoint. 
   * @return enableHub
  **/
  @Schema(description = "This property only applies in SERVER mode. If set to true, traffic from any client will be replicated to all other clients. If set to false, traffic received from clients is only replicated to the local VPN endpoint. ")
  public Boolean isEnableHub() {
    return enableHub;
  }

  public void setEnableHub(Boolean enableHub) {
    this.enableHub = enableHub;
  }

  public L2VpnService logicalRouterId(String logicalRouterId) {
    this.logicalRouterId = logicalRouterId;
    return this;
  }

   /**
   * Logical router id
   * @return logicalRouterId
  **/
  @Schema(required = true, description = "Logical router id")
  public String getLogicalRouterId() {
    return logicalRouterId;
  }

  public void setLogicalRouterId(String logicalRouterId) {
    this.logicalRouterId = logicalRouterId;
  }

  public L2VpnService mode(ModeEnum mode) {
    this.mode = mode;
    return this;
  }

   /**
   * Specify an L2VPN service mode as SERVER or CLIENT. L2VPN service in SERVER mode requires user to configure L2VPN session explicitly. L2VPN service in CLIENT mode can use peercode generated from SERVER to configure L2VPN session. 
   * @return mode
  **/
  @Schema(description = "Specify an L2VPN service mode as SERVER or CLIENT. L2VPN service in SERVER mode requires user to configure L2VPN session explicitly. L2VPN service in CLIENT mode can use peercode generated from SERVER to configure L2VPN session. ")
  public ModeEnum getMode() {
    return mode;
  }

  public void setMode(ModeEnum mode) {
    this.mode = mode;
  }

  public L2VpnService logicalTapIpPool(List<String> logicalTapIpPool) {
    this.logicalTapIpPool = logicalTapIpPool;
    return this;
  }

  public L2VpnService addLogicalTapIpPoolItem(String logicalTapIpPoolItem) {
    if (this.logicalTapIpPool == null) {
      this.logicalTapIpPool = new ArrayList<String>();
    }
    this.logicalTapIpPool.add(logicalTapIpPoolItem);
    return this;
  }

   /**
   * IP Pool to allocate local and peer endpoint IPs for L2VpnSession logical Tap.
   * @return logicalTapIpPool
  **/
  @Schema(description = "IP Pool to allocate local and peer endpoint IPs for L2VpnSession logical Tap.")
  public List<String> getLogicalTapIpPool() {
    return logicalTapIpPool;
  }

  public void setLogicalTapIpPool(List<String> logicalTapIpPool) {
    this.logicalTapIpPool = logicalTapIpPool;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    L2VpnService l2VpnService = (L2VpnService) o;
    return Objects.equals(this.enableFullMesh, l2VpnService.enableFullMesh) &&
        Objects.equals(this.enableHub, l2VpnService.enableHub) &&
        Objects.equals(this.logicalRouterId, l2VpnService.logicalRouterId) &&
        Objects.equals(this.mode, l2VpnService.mode) &&
        Objects.equals(this.logicalTapIpPool, l2VpnService.logicalTapIpPool) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(enableFullMesh, enableHub, logicalRouterId, mode, logicalTapIpPool, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class L2VpnService {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    enableFullMesh: ").append(toIndentedString(enableFullMesh)).append("\n");
    sb.append("    enableHub: ").append(toIndentedString(enableHub)).append("\n");
    sb.append("    logicalRouterId: ").append(toIndentedString(logicalRouterId)).append("\n");
    sb.append("    mode: ").append(toIndentedString(mode)).append("\n");
    sb.append("    logicalTapIpPool: ").append(toIndentedString(logicalTapIpPool)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
