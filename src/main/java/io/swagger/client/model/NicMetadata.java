/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * Information on the Network interfaces present on the partner appliance that needs to be configured by the NSX Manager.
 */
@Schema(description = "Information on the Network interfaces present on the partner appliance that needs to be configured by the NSX Manager.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class NicMetadata {
  @SerializedName("interface_label")
  private String interfaceLabel = null;

  /**
   * Interface that needs to be configured on the partner appliance. Ex. MANAGEMENT, DATA1, DATA2, HA1, HA2, CONTROL.
   */
  @JsonAdapter(InterfaceTypeEnum.Adapter.class)
  public enum InterfaceTypeEnum {
    MANAGEMENT("MANAGEMENT"),
    DATA1("DATA1"),
    DATA2("DATA2"),
    HA1("HA1"),
    HA2("HA2"),
    CONTROL("CONTROL");

    private String value;

    InterfaceTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static InterfaceTypeEnum fromValue(String text) {
      for (InterfaceTypeEnum b : InterfaceTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<InterfaceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final InterfaceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public InterfaceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return InterfaceTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("interface_type")
  private InterfaceTypeEnum interfaceType = null;

  /**
   * Gets or Sets transports
   */
  @JsonAdapter(TransportsEnum.Adapter.class)
  public enum TransportsEnum {
    L2_BRIDGE("L2_BRIDGE"),
    L3_ROUTED("L3_ROUTED"),
    NSH("NSH");

    private String value;

    TransportsEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TransportsEnum fromValue(String text) {
      for (TransportsEnum b : TransportsEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TransportsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TransportsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TransportsEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return TransportsEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("transports")
  private List<TransportsEnum> transports = null;

  @SerializedName("user_configurable")
  private Boolean userConfigurable = null;

  @SerializedName("interface_index")
  private Long interfaceIndex = null;

  public NicMetadata interfaceLabel(String interfaceLabel) {
    this.interfaceLabel = interfaceLabel;
    return this;
  }

   /**
   * Network Interface label.
   * @return interfaceLabel
  **/
  @Schema(required = true, description = "Network Interface label.")
  public String getInterfaceLabel() {
    return interfaceLabel;
  }

  public void setInterfaceLabel(String interfaceLabel) {
    this.interfaceLabel = interfaceLabel;
  }

  public NicMetadata interfaceType(InterfaceTypeEnum interfaceType) {
    this.interfaceType = interfaceType;
    return this;
  }

   /**
   * Interface that needs to be configured on the partner appliance. Ex. MANAGEMENT, DATA1, DATA2, HA1, HA2, CONTROL.
   * @return interfaceType
  **/
  @Schema(required = true, description = "Interface that needs to be configured on the partner appliance. Ex. MANAGEMENT, DATA1, DATA2, HA1, HA2, CONTROL.")
  public InterfaceTypeEnum getInterfaceType() {
    return interfaceType;
  }

  public void setInterfaceType(InterfaceTypeEnum interfaceType) {
    this.interfaceType = interfaceType;
  }

  public NicMetadata transports(List<TransportsEnum> transports) {
    this.transports = transports;
    return this;
  }

  public NicMetadata addTransportsItem(TransportsEnum transportsItem) {
    if (this.transports == null) {
      this.transports = new ArrayList<TransportsEnum>();
    }
    this.transports.add(transportsItem);
    return this;
  }

   /**
   * Transport Type of the service, which is the mechanism of redirecting the traffic to the the partner appliance. Transport type is required if Service caters to any functionality other than EPP. Here, the transports array specifies the kinds of transport where this particular NIC is user configurable. If nothing is specified, and the \&quot;user_configurable\&quot; flag is true, then user configuration will be allowed for all transports. If any transport is/are specified, then it will be considered as user configurable for the specified transports only.\&quot;
   * @return transports
  **/
  @Schema(description = "Transport Type of the service, which is the mechanism of redirecting the traffic to the the partner appliance. Transport type is required if Service caters to any functionality other than EPP. Here, the transports array specifies the kinds of transport where this particular NIC is user configurable. If nothing is specified, and the \"user_configurable\" flag is true, then user configuration will be allowed for all transports. If any transport is/are specified, then it will be considered as user configurable for the specified transports only.\"")
  public List<TransportsEnum> getTransports() {
    return transports;
  }

  public void setTransports(List<TransportsEnum> transports) {
    this.transports = transports;
  }

  public NicMetadata userConfigurable(Boolean userConfigurable) {
    this.userConfigurable = userConfigurable;
    return this;
  }

   /**
   * Used to specify if the given interface needs configuration. Management nics will always need the configuration, for others it will be use case specific. For example, a DATA NIC may be user configurable if the appliance is deployed in certain mode, such as L3_ROUTED.
   * @return userConfigurable
  **/
  @Schema(description = "Used to specify if the given interface needs configuration. Management nics will always need the configuration, for others it will be use case specific. For example, a DATA NIC may be user configurable if the appliance is deployed in certain mode, such as L3_ROUTED.")
  public Boolean isUserConfigurable() {
    return userConfigurable;
  }

  public void setUserConfigurable(Boolean userConfigurable) {
    this.userConfigurable = userConfigurable;
  }

  public NicMetadata interfaceIndex(Long interfaceIndex) {
    this.interfaceIndex = interfaceIndex;
    return this;
  }

   /**
   * Network Interface index.
   * minimum: 0
   * @return interfaceIndex
  **/
  @Schema(required = true, description = "Network Interface index.")
  public Long getInterfaceIndex() {
    return interfaceIndex;
  }

  public void setInterfaceIndex(Long interfaceIndex) {
    this.interfaceIndex = interfaceIndex;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NicMetadata nicMetadata = (NicMetadata) o;
    return Objects.equals(this.interfaceLabel, nicMetadata.interfaceLabel) &&
        Objects.equals(this.interfaceType, nicMetadata.interfaceType) &&
        Objects.equals(this.transports, nicMetadata.transports) &&
        Objects.equals(this.userConfigurable, nicMetadata.userConfigurable) &&
        Objects.equals(this.interfaceIndex, nicMetadata.interfaceIndex);
  }

  @Override
  public int hashCode() {
    return Objects.hash(interfaceLabel, interfaceType, transports, userConfigurable, interfaceIndex);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NicMetadata {\n");
    
    sb.append("    interfaceLabel: ").append(toIndentedString(interfaceLabel)).append("\n");
    sb.append("    interfaceType: ").append(toIndentedString(interfaceType)).append("\n");
    sb.append("    transports: ").append(toIndentedString(transports)).append("\n");
    sb.append("    userConfigurable: ").append(toIndentedString(userConfigurable)).append("\n");
    sb.append("    interfaceIndex: ").append(toIndentedString(interfaceIndex)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
