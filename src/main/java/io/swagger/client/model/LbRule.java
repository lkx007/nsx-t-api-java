/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.LbRuleAction;
import io.swagger.client.model.LbRuleCondition;
import io.swagger.client.model.ManagedResource;
import io.swagger.client.model.Tag;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * Load balancer rules allow customization of load balancing behavior using match/action rules. Currently, load balancer rules are supported for only layer 7 virtual servers with application profile LbHttpProfile. Each application rule consists of one or more match conditions and one or more actions. Load balancer rules could be used by different load balancer services. 
 */
@Schema(description = "Load balancer rules allow customization of load balancing behavior using match/action rules. Currently, load balancer rules are supported for only layer 7 virtual servers with application profile LbHttpProfile. Each application rule consists of one or more match conditions and one or more actions. Load balancer rules could be used by different load balancer services. ")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class LbRule extends ManagedResource {
  /**
   * Each load balancer rule is used at a specific phase of load balancer processing. Currently three phases are supported, HTTP_REQUEST_REWRITE, HTTP_FORWARDING and HTTP_RESPONSE_REWRITE. When an HTTP request message is received by load balancer, all HTTP_REQUEST_REWRITE rules, if present are executed in the order they are applied to virtual server. And then if HTTP_FORWARDING rules present, only first matching rule&#x27;s action is executed, remaining rules are not checked. HTTP_FORWARDING rules can have only one action. If the request is forwarded to a backend server and the response goes back to load balancer, all HTTP_RESPONSE_REWRITE rules, if present, are executed in the order they are applied to the virtual server. 
   */
  @JsonAdapter(PhaseEnum.Adapter.class)
  public enum PhaseEnum {
    REQUEST_REWRITE("HTTP_REQUEST_REWRITE"),
    FORWARDING("HTTP_FORWARDING"),
    RESPONSE_REWRITE("HTTP_RESPONSE_REWRITE");

    private String value;

    PhaseEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static PhaseEnum fromValue(String text) {
      for (PhaseEnum b : PhaseEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<PhaseEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PhaseEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PhaseEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return PhaseEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("phase")
  private PhaseEnum phase = null;

  @SerializedName("match_conditions")
  private List<LbRuleCondition> matchConditions = null;

  @SerializedName("actions")
  private List<LbRuleAction> actions = new ArrayList<LbRuleAction>();

  /**
   * Strategy to define how load balancer rule is considered a match when multiple match conditions are specified in one rule. If match_stragety is set to ALL, then load balancer rule is considered a match only if all the conditions match. If match_strategy is set to ANY, then load balancer rule is considered a match if any one of the conditions match. 
   */
  @JsonAdapter(MatchStrategyEnum.Adapter.class)
  public enum MatchStrategyEnum {
    ALL("ALL"),
    ANY("ANY");

    private String value;

    MatchStrategyEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static MatchStrategyEnum fromValue(String text) {
      for (MatchStrategyEnum b : MatchStrategyEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<MatchStrategyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MatchStrategyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MatchStrategyEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return MatchStrategyEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("match_strategy")
  private MatchStrategyEnum matchStrategy = null;

  public LbRule phase(PhaseEnum phase) {
    this.phase = phase;
    return this;
  }

   /**
   * Each load balancer rule is used at a specific phase of load balancer processing. Currently three phases are supported, HTTP_REQUEST_REWRITE, HTTP_FORWARDING and HTTP_RESPONSE_REWRITE. When an HTTP request message is received by load balancer, all HTTP_REQUEST_REWRITE rules, if present are executed in the order they are applied to virtual server. And then if HTTP_FORWARDING rules present, only first matching rule&#x27;s action is executed, remaining rules are not checked. HTTP_FORWARDING rules can have only one action. If the request is forwarded to a backend server and the response goes back to load balancer, all HTTP_RESPONSE_REWRITE rules, if present, are executed in the order they are applied to the virtual server. 
   * @return phase
  **/
  @Schema(required = true, description = "Each load balancer rule is used at a specific phase of load balancer processing. Currently three phases are supported, HTTP_REQUEST_REWRITE, HTTP_FORWARDING and HTTP_RESPONSE_REWRITE. When an HTTP request message is received by load balancer, all HTTP_REQUEST_REWRITE rules, if present are executed in the order they are applied to virtual server. And then if HTTP_FORWARDING rules present, only first matching rule's action is executed, remaining rules are not checked. HTTP_FORWARDING rules can have only one action. If the request is forwarded to a backend server and the response goes back to load balancer, all HTTP_RESPONSE_REWRITE rules, if present, are executed in the order they are applied to the virtual server. ")
  public PhaseEnum getPhase() {
    return phase;
  }

  public void setPhase(PhaseEnum phase) {
    this.phase = phase;
  }

  public LbRule matchConditions(List<LbRuleCondition> matchConditions) {
    this.matchConditions = matchConditions;
    return this;
  }

  public LbRule addMatchConditionsItem(LbRuleCondition matchConditionsItem) {
    if (this.matchConditions == null) {
      this.matchConditions = new ArrayList<LbRuleCondition>();
    }
    this.matchConditions.add(matchConditionsItem);
    return this;
  }

   /**
   * A list of match conditions used to match application traffic. Multiple match conditions can be specified in one load balancer rule, each match condition defines a criterion to match application traffic. If no match conditions are specified, then the load balancer rule will always match and it is used typically to define default rules. If more than one match condition is specified, then match strategy determines if all conditions should match or any one condition should match for the load balancer rule to considered a match. 
   * @return matchConditions
  **/
  @Schema(description = "A list of match conditions used to match application traffic. Multiple match conditions can be specified in one load balancer rule, each match condition defines a criterion to match application traffic. If no match conditions are specified, then the load balancer rule will always match and it is used typically to define default rules. If more than one match condition is specified, then match strategy determines if all conditions should match or any one condition should match for the load balancer rule to considered a match. ")
  public List<LbRuleCondition> getMatchConditions() {
    return matchConditions;
  }

  public void setMatchConditions(List<LbRuleCondition> matchConditions) {
    this.matchConditions = matchConditions;
  }

  public LbRule actions(List<LbRuleAction> actions) {
    this.actions = actions;
    return this;
  }

  public LbRule addActionsItem(LbRuleAction actionsItem) {
    this.actions.add(actionsItem);
    return this;
  }

   /**
   * A list of actions to be executed at specified phase when load balancer rule matches. The actions are used to manipulate application traffic, such as rewrite URI of HTTP messages, redirect HTTP messages, etc. 
   * @return actions
  **/
  @Schema(required = true, description = "A list of actions to be executed at specified phase when load balancer rule matches. The actions are used to manipulate application traffic, such as rewrite URI of HTTP messages, redirect HTTP messages, etc. ")
  public List<LbRuleAction> getActions() {
    return actions;
  }

  public void setActions(List<LbRuleAction> actions) {
    this.actions = actions;
  }

  public LbRule matchStrategy(MatchStrategyEnum matchStrategy) {
    this.matchStrategy = matchStrategy;
    return this;
  }

   /**
   * Strategy to define how load balancer rule is considered a match when multiple match conditions are specified in one rule. If match_stragety is set to ALL, then load balancer rule is considered a match only if all the conditions match. If match_strategy is set to ANY, then load balancer rule is considered a match if any one of the conditions match. 
   * @return matchStrategy
  **/
  @Schema(required = true, description = "Strategy to define how load balancer rule is considered a match when multiple match conditions are specified in one rule. If match_stragety is set to ALL, then load balancer rule is considered a match only if all the conditions match. If match_strategy is set to ANY, then load balancer rule is considered a match if any one of the conditions match. ")
  public MatchStrategyEnum getMatchStrategy() {
    return matchStrategy;
  }

  public void setMatchStrategy(MatchStrategyEnum matchStrategy) {
    this.matchStrategy = matchStrategy;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LbRule lbRule = (LbRule) o;
    return Objects.equals(this.phase, lbRule.phase) &&
        Objects.equals(this.matchConditions, lbRule.matchConditions) &&
        Objects.equals(this.actions, lbRule.actions) &&
        Objects.equals(this.matchStrategy, lbRule.matchStrategy) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(phase, matchConditions, actions, matchStrategy, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LbRule {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    phase: ").append(toIndentedString(phase)).append("\n");
    sb.append("    matchConditions: ").append(toIndentedString(matchConditions)).append("\n");
    sb.append("    actions: ").append(toIndentedString(actions)).append("\n");
    sb.append("    matchStrategy: ").append(toIndentedString(matchStrategy)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
