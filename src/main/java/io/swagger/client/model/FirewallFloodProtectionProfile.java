/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.BaseFirewallProfile;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * A profile holding protection configuration for SYN flood, UDP flood, ICMP flood and other flood attack.
 */
@Schema(description = "A profile holding protection configuration for SYN flood, UDP flood, ICMP flood and other flood attack.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class FirewallFloodProtectionProfile extends BaseFirewallProfile {
  @SerializedName("icmp_active_flow_limit")
  private Long icmpActiveFlowLimit = null;

  @SerializedName("other_active_conn_limit")
  private Long otherActiveConnLimit = null;

  @SerializedName("enable_syncache")
  private Boolean enableSyncache = false;

  @SerializedName("udp_active_flow_limit")
  private Long udpActiveFlowLimit = null;

  @SerializedName("tcp_half_open_conn_limit")
  private Long tcpHalfOpenConnLimit = null;

  @SerializedName("enable_rst_spoofing")
  private Boolean enableRstSpoofing = false;

  public FirewallFloodProtectionProfile icmpActiveFlowLimit(Long icmpActiveFlowLimit) {
    this.icmpActiveFlowLimit = icmpActiveFlowLimit;
    return this;
  }

   /**
   * The maximum limit of active icmp connections. If this property is omitted, or set to null, then there is no limit on active icmp connections for those components if it&#x27;s applied to ESX components (such as segment, segment port, virtual machine, etc); on the other side, if it&#x27;s applied to EDGE components (such as, gateway), it will be set to default limit (10,000) on the specific components.
   * minimum: 1
   * maximum: 1000000
   * @return icmpActiveFlowLimit
  **/
  @Schema(description = "The maximum limit of active icmp connections. If this property is omitted, or set to null, then there is no limit on active icmp connections for those components if it's applied to ESX components (such as segment, segment port, virtual machine, etc); on the other side, if it's applied to EDGE components (such as, gateway), it will be set to default limit (10,000) on the specific components.")
  public Long getIcmpActiveFlowLimit() {
    return icmpActiveFlowLimit;
  }

  public void setIcmpActiveFlowLimit(Long icmpActiveFlowLimit) {
    this.icmpActiveFlowLimit = icmpActiveFlowLimit;
  }

  public FirewallFloodProtectionProfile otherActiveConnLimit(Long otherActiveConnLimit) {
    this.otherActiveConnLimit = otherActiveConnLimit;
    return this;
  }

   /**
   * The maximum limit of other active connections besides udp, icmp and half open tcp connections. If this property is omitted, or set to null, then there is no limit on other active connections besides udp, icmp and tcp half open connections for those components if it&#x27;s applied to ESX components (such as segment, segment port, virtual machine, etc); on the other side, if it&#x27;s applied to EDGE components (such as, gateway), it will be set to default limit (10,000) on the specific components.
   * minimum: 1
   * maximum: 1000000
   * @return otherActiveConnLimit
  **/
  @Schema(description = "The maximum limit of other active connections besides udp, icmp and half open tcp connections. If this property is omitted, or set to null, then there is no limit on other active connections besides udp, icmp and tcp half open connections for those components if it's applied to ESX components (such as segment, segment port, virtual machine, etc); on the other side, if it's applied to EDGE components (such as, gateway), it will be set to default limit (10,000) on the specific components.")
  public Long getOtherActiveConnLimit() {
    return otherActiveConnLimit;
  }

  public void setOtherActiveConnLimit(Long otherActiveConnLimit) {
    this.otherActiveConnLimit = otherActiveConnLimit;
  }

  public FirewallFloodProtectionProfile enableSyncache(Boolean enableSyncache) {
    this.enableSyncache = enableSyncache;
    return this;
  }

   /**
   * The flag to indicate syncache is enabled or not. This option does not apply to EDGE components.
   * @return enableSyncache
  **/
  @Schema(description = "The flag to indicate syncache is enabled or not. This option does not apply to EDGE components.")
  public Boolean isEnableSyncache() {
    return enableSyncache;
  }

  public void setEnableSyncache(Boolean enableSyncache) {
    this.enableSyncache = enableSyncache;
  }

  public FirewallFloodProtectionProfile udpActiveFlowLimit(Long udpActiveFlowLimit) {
    this.udpActiveFlowLimit = udpActiveFlowLimit;
    return this;
  }

   /**
   * The maximum limit of active udp connections. If this property is omitted, or set to null, then there is no limit on active udp connections for those components if it&#x27;s applied to ESX components (such as segment, segment port, virtual machine, etc); on the other side, if it&#x27;s applied to EDGE components (such as, gateway), it will be set to default limit (100,000) on the specific component.
   * minimum: 1
   * maximum: 1000000
   * @return udpActiveFlowLimit
  **/
  @Schema(description = "The maximum limit of active udp connections. If this property is omitted, or set to null, then there is no limit on active udp connections for those components if it's applied to ESX components (such as segment, segment port, virtual machine, etc); on the other side, if it's applied to EDGE components (such as, gateway), it will be set to default limit (100,000) on the specific component.")
  public Long getUdpActiveFlowLimit() {
    return udpActiveFlowLimit;
  }

  public void setUdpActiveFlowLimit(Long udpActiveFlowLimit) {
    this.udpActiveFlowLimit = udpActiveFlowLimit;
  }

  public FirewallFloodProtectionProfile tcpHalfOpenConnLimit(Long tcpHalfOpenConnLimit) {
    this.tcpHalfOpenConnLimit = tcpHalfOpenConnLimit;
    return this;
  }

   /**
   * The maximum limit of tcp half open connections. If this property is omitted, or set to null, then there is no limit on active tcp half open connections for those components if it&#x27;s applied to ESX components (such as segment, segment port, virtual machine, etc); on the other side, if it&#x27;s applied to EDGE components (such as, gateway), it will be set to default limit (1,000,000) on the specific components.
   * minimum: 1
   * maximum: 1000000
   * @return tcpHalfOpenConnLimit
  **/
  @Schema(description = "The maximum limit of tcp half open connections. If this property is omitted, or set to null, then there is no limit on active tcp half open connections for those components if it's applied to ESX components (such as segment, segment port, virtual machine, etc); on the other side, if it's applied to EDGE components (such as, gateway), it will be set to default limit (1,000,000) on the specific components.")
  public Long getTcpHalfOpenConnLimit() {
    return tcpHalfOpenConnLimit;
  }

  public void setTcpHalfOpenConnLimit(Long tcpHalfOpenConnLimit) {
    this.tcpHalfOpenConnLimit = tcpHalfOpenConnLimit;
  }

  public FirewallFloodProtectionProfile enableRstSpoofing(Boolean enableRstSpoofing) {
    this.enableRstSpoofing = enableRstSpoofing;
    return this;
  }

   /**
   * The flag to indicate RST spoofing is enabled or not. This option does not apply to EDGE components. This can be enabled only if syncache is enabled.
   * @return enableRstSpoofing
  **/
  @Schema(description = "The flag to indicate RST spoofing is enabled or not. This option does not apply to EDGE components. This can be enabled only if syncache is enabled.")
  public Boolean isEnableRstSpoofing() {
    return enableRstSpoofing;
  }

  public void setEnableRstSpoofing(Boolean enableRstSpoofing) {
    this.enableRstSpoofing = enableRstSpoofing;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FirewallFloodProtectionProfile firewallFloodProtectionProfile = (FirewallFloodProtectionProfile) o;
    return Objects.equals(this.icmpActiveFlowLimit, firewallFloodProtectionProfile.icmpActiveFlowLimit) &&
        Objects.equals(this.otherActiveConnLimit, firewallFloodProtectionProfile.otherActiveConnLimit) &&
        Objects.equals(this.enableSyncache, firewallFloodProtectionProfile.enableSyncache) &&
        Objects.equals(this.udpActiveFlowLimit, firewallFloodProtectionProfile.udpActiveFlowLimit) &&
        Objects.equals(this.tcpHalfOpenConnLimit, firewallFloodProtectionProfile.tcpHalfOpenConnLimit) &&
        Objects.equals(this.enableRstSpoofing, firewallFloodProtectionProfile.enableRstSpoofing) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(icmpActiveFlowLimit, otherActiveConnLimit, enableSyncache, udpActiveFlowLimit, tcpHalfOpenConnLimit, enableRstSpoofing, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FirewallFloodProtectionProfile {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    icmpActiveFlowLimit: ").append(toIndentedString(icmpActiveFlowLimit)).append("\n");
    sb.append("    otherActiveConnLimit: ").append(toIndentedString(otherActiveConnLimit)).append("\n");
    sb.append("    enableSyncache: ").append(toIndentedString(enableSyncache)).append("\n");
    sb.append("    udpActiveFlowLimit: ").append(toIndentedString(udpActiveFlowLimit)).append("\n");
    sb.append("    tcpHalfOpenConnLimit: ").append(toIndentedString(tcpHalfOpenConnLimit)).append("\n");
    sb.append("    enableRstSpoofing: ").append(toIndentedString(enableRstSpoofing)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
