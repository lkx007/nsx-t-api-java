/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * SSL cipher
 */
@Schema(description = "SSL cipher")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class LbSslCipherInfo {
  @SerializedName("is_default")
  private Boolean isDefault = null;

  @SerializedName("is_secure")
  private Boolean isSecure = null;

  /**
   * SSL cipher group
   */
  @JsonAdapter(CipherGroupLabelsEnum.Adapter.class)
  public enum CipherGroupLabelsEnum {
    BALANCED("BALANCED"),
    HIGH_SECURITY("HIGH_SECURITY"),
    HIGH_COMPATIBILITY("HIGH_COMPATIBILITY"),
    CUSTOM("CUSTOM");

    private String value;

    CipherGroupLabelsEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static CipherGroupLabelsEnum fromValue(String text) {
      for (CipherGroupLabelsEnum b : CipherGroupLabelsEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<CipherGroupLabelsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CipherGroupLabelsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CipherGroupLabelsEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return CipherGroupLabelsEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("cipher_group_labels")
  private List<CipherGroupLabelsEnum> cipherGroupLabels = null;

  /**
   * SSL cipher
   */
  @JsonAdapter(CipherEnum.Adapter.class)
  public enum CipherEnum {
    ECDHE_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"),
    ECDHE_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"),
    ECDHE_RSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"),
    ECDHE_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"),
    ECDH_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA"),
    ECDH_RSA_WITH_AES_256_CBC_SHA("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA"),
    RSA_WITH_AES_256_CBC_SHA("TLS_RSA_WITH_AES_256_CBC_SHA"),
    RSA_WITH_AES_128_CBC_SHA("TLS_RSA_WITH_AES_128_CBC_SHA"),
    RSA_WITH_3DES_EDE_CBC_SHA("TLS_RSA_WITH_3DES_EDE_CBC_SHA"),
    ECDHE_RSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"),
    ECDHE_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"),
    ECDHE_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384"),
    RSA_WITH_AES_128_CBC_SHA256("TLS_RSA_WITH_AES_128_CBC_SHA256"),
    RSA_WITH_AES_128_GCM_SHA256("TLS_RSA_WITH_AES_128_GCM_SHA256"),
    RSA_WITH_AES_256_CBC_SHA256("TLS_RSA_WITH_AES_256_CBC_SHA256"),
    RSA_WITH_AES_256_GCM_SHA384("TLS_RSA_WITH_AES_256_GCM_SHA384"),
    ECDHE_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"),
    ECDHE_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"),
    ECDHE_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"),
    ECDHE_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384"),
    ECDHE_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"),
    ECDH_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA"),
    ECDH_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256"),
    ECDH_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256"),
    ECDH_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384"),
    ECDH_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384"),
    ECDH_RSA_WITH_AES_128_CBC_SHA("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA"),
    ECDH_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256"),
    ECDH_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256"),
    ECDH_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384"),
    ECDH_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384");

    private String value;

    CipherEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static CipherEnum fromValue(String text) {
      for (CipherEnum b : CipherEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<CipherEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CipherEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CipherEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return CipherEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("cipher")
  private CipherEnum cipher = null;

  public LbSslCipherInfo isDefault(Boolean isDefault) {
    this.isDefault = isDefault;
    return this;
  }

   /**
   * Default SSL cipher flag
   * @return isDefault
  **/
  @Schema(required = true, description = "Default SSL cipher flag")
  public Boolean isIsDefault() {
    return isDefault;
  }

  public void setIsDefault(Boolean isDefault) {
    this.isDefault = isDefault;
  }

  public LbSslCipherInfo isSecure(Boolean isSecure) {
    this.isSecure = isSecure;
    return this;
  }

   /**
   * Secure/insecure SSL cipher flag
   * @return isSecure
  **/
  @Schema(required = true, description = "Secure/insecure SSL cipher flag")
  public Boolean isIsSecure() {
    return isSecure;
  }

  public void setIsSecure(Boolean isSecure) {
    this.isSecure = isSecure;
  }

  public LbSslCipherInfo cipherGroupLabels(List<CipherGroupLabelsEnum> cipherGroupLabels) {
    this.cipherGroupLabels = cipherGroupLabels;
    return this;
  }

  public LbSslCipherInfo addCipherGroupLabelsItem(CipherGroupLabelsEnum cipherGroupLabelsItem) {
    if (this.cipherGroupLabels == null) {
      this.cipherGroupLabels = new ArrayList<CipherGroupLabelsEnum>();
    }
    this.cipherGroupLabels.add(cipherGroupLabelsItem);
    return this;
  }

   /**
   * Several cipher groups might contain the same cipher suite, each cipher suite could have multiple cipher group labels. 
   * @return cipherGroupLabels
  **/
  @Schema(description = "Several cipher groups might contain the same cipher suite, each cipher suite could have multiple cipher group labels. ")
  public List<CipherGroupLabelsEnum> getCipherGroupLabels() {
    return cipherGroupLabels;
  }

  public void setCipherGroupLabels(List<CipherGroupLabelsEnum> cipherGroupLabels) {
    this.cipherGroupLabels = cipherGroupLabels;
  }

  public LbSslCipherInfo cipher(CipherEnum cipher) {
    this.cipher = cipher;
    return this;
  }

   /**
   * SSL cipher
   * @return cipher
  **/
  @Schema(required = true, description = "SSL cipher")
  public CipherEnum getCipher() {
    return cipher;
  }

  public void setCipher(CipherEnum cipher) {
    this.cipher = cipher;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LbSslCipherInfo lbSslCipherInfo = (LbSslCipherInfo) o;
    return Objects.equals(this.isDefault, lbSslCipherInfo.isDefault) &&
        Objects.equals(this.isSecure, lbSslCipherInfo.isSecure) &&
        Objects.equals(this.cipherGroupLabels, lbSslCipherInfo.cipherGroupLabels) &&
        Objects.equals(this.cipher, lbSslCipherInfo.cipher);
  }

  @Override
  public int hashCode() {
    return Objects.hash(isDefault, isSecure, cipherGroupLabels, cipher);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LbSslCipherInfo {\n");
    
    sb.append("    isDefault: ").append(toIndentedString(isDefault)).append("\n");
    sb.append("    isSecure: ").append(toIndentedString(isSecure)).append("\n");
    sb.append("    cipherGroupLabels: ").append(toIndentedString(cipherGroupLabels)).append("\n");
    sb.append("    cipher: ").append(toIndentedString(cipher)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
