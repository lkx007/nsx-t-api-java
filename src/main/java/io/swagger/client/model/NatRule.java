/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.ManagedResource;
import io.swagger.client.model.NSServiceElement;
import io.swagger.client.model.ResourceReference;
import io.swagger.client.model.Tag;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * The configuration entity to define a NAT rule. It defines how an ip packet is matched via source address or/and destination address or/and service(s), how the address (and/or) port is translated, and how the related firewall stage is involved or bypassed. 
 */
@Schema(description = "The configuration entity to define a NAT rule. It defines how an ip packet is matched via source address or/and destination address or/and service(s), how the address (and/or) port is translated, and how the related firewall stage is involved or bypassed. ")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class NatRule extends ManagedResource {
  @SerializedName("match_destination_network")
  private String matchDestinationNetwork = null;

  @SerializedName("translated_network")
  private String translatedNetwork = null;

  @SerializedName("rule_priority")
  private Long rulePriority = 1024l;

  @SerializedName("match_service")
  private NSServiceElement matchService = null;

  @SerializedName("applied_tos")
  private List<ResourceReference> appliedTos = null;

  @SerializedName("enabled")
  private Boolean enabled = true;

  @SerializedName("internal_rule_id")
  private String internalRuleId = null;

  @SerializedName("logging")
  private Boolean logging = false;

  @SerializedName("translated_ports")
  private String translatedPorts = null;

  /**
   * Valid actions: SNAT, DNAT, NO_SNAT, NO_DNAT, REFLEXIVE. All rules in a logical router are either stateless or stateful. Mix is not supported. SNAT and DNAT are stateful, can NOT be supported when the logical router is running at active-active HA mode; REFLEXIVE is stateless. NO_SNAT and NO_DNAT have no translated_fields, only match fields are supported. 
   */
  @JsonAdapter(ActionEnum.Adapter.class)
  public enum ActionEnum {
    SNAT("SNAT"),
    DNAT("DNAT"),
    NO_NAT("NO_NAT"),
    REFLEXIVE("REFLEXIVE"),
    NO_SNAT("NO_SNAT"),
    NO_DNAT("NO_DNAT");

    private String value;

    ActionEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ActionEnum fromValue(String text) {
      for (ActionEnum b : ActionEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ActionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ActionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ActionEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ActionEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("action")
  private ActionEnum action = null;

  /**
   * Indicate how firewall is applied to a traffic packet. Firewall can be bypassed, or be applied to external/internal address of NAT rule.  The firewall_match will take priority over nat_pass. If the firewall_match is not provided, the nat_pass will be picked up. 
   */
  @JsonAdapter(FirewallMatchEnum.Adapter.class)
  public enum FirewallMatchEnum {
    MATCH_EXTERNAL_ADDRESS("MATCH_EXTERNAL_ADDRESS"),
    MATCH_INTERNAL_ADDRESS("MATCH_INTERNAL_ADDRESS"),
    BYPASS("BYPASS");

    private String value;

    FirewallMatchEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static FirewallMatchEnum fromValue(String text) {
      for (FirewallMatchEnum b : FirewallMatchEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<FirewallMatchEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FirewallMatchEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FirewallMatchEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return FirewallMatchEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("firewall_match")
  private FirewallMatchEnum firewallMatch = null;

  @SerializedName("nat_pass")
  private Boolean natPass = true;

  @SerializedName("logical_router_id")
  private String logicalRouterId = null;

  @SerializedName("match_source_network")
  private String matchSourceNetwork = null;

  public NatRule matchDestinationNetwork(String matchDestinationNetwork) {
    this.matchDestinationNetwork = matchDestinationNetwork;
    return this;
  }

   /**
   * IP Address | CIDR | (null implies Any) 
   * @return matchDestinationNetwork
  **/
  @Schema(description = "IP Address | CIDR | (null implies Any) ")
  public String getMatchDestinationNetwork() {
    return matchDestinationNetwork;
  }

  public void setMatchDestinationNetwork(String matchDestinationNetwork) {
    this.matchDestinationNetwork = matchDestinationNetwork;
  }

  public NatRule translatedNetwork(String translatedNetwork) {
    this.translatedNetwork = translatedNetwork;
    return this;
  }

   /**
   * The translated address for the matched IP packet. For a SNAT, it can be a single ip address, an ip range, or a CIDR block. For a DNAT and a REFLEXIVE, it can be a single ip address or a CIDR block. Translated network is not supported for NO_SNAT or NO_DNAT. 
   * @return translatedNetwork
  **/
  @Schema(description = "The translated address for the matched IP packet. For a SNAT, it can be a single ip address, an ip range, or a CIDR block. For a DNAT and a REFLEXIVE, it can be a single ip address or a CIDR block. Translated network is not supported for NO_SNAT or NO_DNAT. ")
  public String getTranslatedNetwork() {
    return translatedNetwork;
  }

  public void setTranslatedNetwork(String translatedNetwork) {
    this.translatedNetwork = translatedNetwork;
  }

  public NatRule rulePriority(Long rulePriority) {
    this.rulePriority = rulePriority;
    return this;
  }

   /**
   * Ascending, valid range [0-2147483647]. If multiple rules have the same priority, evaluation sequence is undefined. 
   * @return rulePriority
  **/
  @Schema(description = "Ascending, valid range [0-2147483647]. If multiple rules have the same priority, evaluation sequence is undefined. ")
  public Long getRulePriority() {
    return rulePriority;
  }

  public void setRulePriority(Long rulePriority) {
    this.rulePriority = rulePriority;
  }

  public NatRule matchService(NSServiceElement matchService) {
    this.matchService = matchService;
    return this;
  }

   /**
   * Get matchService
   * @return matchService
  **/
  @Schema(description = "")
  public NSServiceElement getMatchService() {
    return matchService;
  }

  public void setMatchService(NSServiceElement matchService) {
    this.matchService = matchService;
  }

  public NatRule appliedTos(List<ResourceReference> appliedTos) {
    this.appliedTos = appliedTos;
    return this;
  }

  public NatRule addAppliedTosItem(ResourceReference appliedTosItem) {
    if (this.appliedTos == null) {
      this.appliedTos = new ArrayList<ResourceReference>();
    }
    this.appliedTos.add(appliedTosItem);
    return this;
  }

   /**
   * Holds the list of LogicalRouterPort Ids that a NAT rule can be applied to. The LogicalRouterPort used must belong to the same LogicalRouter for which the NAT Rule is created. As of now a NAT rule can only have a single LogicalRouterPort as applied_tos. When applied_tos is not set, the NAT rule is applied to all LogicalRouterPorts beloging to the LogicalRouter.
   * @return appliedTos
  **/
  @Schema(description = "Holds the list of LogicalRouterPort Ids that a NAT rule can be applied to. The LogicalRouterPort used must belong to the same LogicalRouter for which the NAT Rule is created. As of now a NAT rule can only have a single LogicalRouterPort as applied_tos. When applied_tos is not set, the NAT rule is applied to all LogicalRouterPorts beloging to the LogicalRouter.")
  public List<ResourceReference> getAppliedTos() {
    return appliedTos;
  }

  public void setAppliedTos(List<ResourceReference> appliedTos) {
    this.appliedTos = appliedTos;
  }

  public NatRule enabled(Boolean enabled) {
    this.enabled = enabled;
    return this;
  }

   /**
   * Indicator to enable/disable the rule. 
   * @return enabled
  **/
  @Schema(description = "Indicator to enable/disable the rule. ")
  public Boolean isEnabled() {
    return enabled;
  }

  public void setEnabled(Boolean enabled) {
    this.enabled = enabled;
  }

   /**
   * Internal NAT rule uuid for debug used in Controller and backend.
   * @return internalRuleId
  **/
  @Schema(description = "Internal NAT rule uuid for debug used in Controller and backend.")
  public String getInternalRuleId() {
    return internalRuleId;
  }

  public NatRule logging(Boolean logging) {
    this.logging = logging;
    return this;
  }

   /**
   * Enable/disable the logging of rule. 
   * @return logging
  **/
  @Schema(description = "Enable/disable the logging of rule. ")
  public Boolean isLogging() {
    return logging;
  }

  public void setLogging(Boolean logging) {
    this.logging = logging;
  }

  public NatRule translatedPorts(String translatedPorts) {
    this.translatedPorts = translatedPorts;
    return this;
  }

   /**
   * The translated port(s) for the mtached IP packet. It can be a single port or a port range. Please note, port translating is supported only for DNAT. 
   * @return translatedPorts
  **/
  @Schema(description = "The translated port(s) for the mtached IP packet. It can be a single port or a port range. Please note, port translating is supported only for DNAT. ")
  public String getTranslatedPorts() {
    return translatedPorts;
  }

  public void setTranslatedPorts(String translatedPorts) {
    this.translatedPorts = translatedPorts;
  }

  public NatRule action(ActionEnum action) {
    this.action = action;
    return this;
  }

   /**
   * Valid actions: SNAT, DNAT, NO_SNAT, NO_DNAT, REFLEXIVE. All rules in a logical router are either stateless or stateful. Mix is not supported. SNAT and DNAT are stateful, can NOT be supported when the logical router is running at active-active HA mode; REFLEXIVE is stateless. NO_SNAT and NO_DNAT have no translated_fields, only match fields are supported. 
   * @return action
  **/
  @Schema(required = true, description = "Valid actions: SNAT, DNAT, NO_SNAT, NO_DNAT, REFLEXIVE. All rules in a logical router are either stateless or stateful. Mix is not supported. SNAT and DNAT are stateful, can NOT be supported when the logical router is running at active-active HA mode; REFLEXIVE is stateless. NO_SNAT and NO_DNAT have no translated_fields, only match fields are supported. ")
  public ActionEnum getAction() {
    return action;
  }

  public void setAction(ActionEnum action) {
    this.action = action;
  }

  public NatRule firewallMatch(FirewallMatchEnum firewallMatch) {
    this.firewallMatch = firewallMatch;
    return this;
  }

   /**
   * Indicate how firewall is applied to a traffic packet. Firewall can be bypassed, or be applied to external/internal address of NAT rule.  The firewall_match will take priority over nat_pass. If the firewall_match is not provided, the nat_pass will be picked up. 
   * @return firewallMatch
  **/
  @Schema(description = "Indicate how firewall is applied to a traffic packet. Firewall can be bypassed, or be applied to external/internal address of NAT rule.  The firewall_match will take priority over nat_pass. If the firewall_match is not provided, the nat_pass will be picked up. ")
  public FirewallMatchEnum getFirewallMatch() {
    return firewallMatch;
  }

  public void setFirewallMatch(FirewallMatchEnum firewallMatch) {
    this.firewallMatch = firewallMatch;
  }

  public NatRule natPass(Boolean natPass) {
    this.natPass = natPass;
    return this;
  }

   /**
   * Default is true. If the nat_pass is set to true, the following firewall stage will be skipped. Please note, if action is NO_SNAT or NO_DNAT, then nat_pass must be set to true or omitted.  Nat_pass was deprecated with an alternative firewall_match. Please stop using nat_pass to specify whether firewall stage is skipped. if you want to skip, please set firewall_match to BYPASS. If you do not want to skip, please set the firewall_match to MATCH_EXTERNAL_ADDRESS or MATCH_INTERNAL_ADDRESS.  Please note, the firewall_match will take priority over the nat_pass. If both are provided, the nat_pass is ignored. If firewall_match is not provided while the nat_pass is specified, the nat_pass will still be picked up. In this case, if nat_pass is set to false, firewall rule will be applied on internall address of a packet, i.e. MATCH_INTERNAL_ADDRESS. 
   * @return natPass
  **/
  @Schema(description = "Default is true. If the nat_pass is set to true, the following firewall stage will be skipped. Please note, if action is NO_SNAT or NO_DNAT, then nat_pass must be set to true or omitted.  Nat_pass was deprecated with an alternative firewall_match. Please stop using nat_pass to specify whether firewall stage is skipped. if you want to skip, please set firewall_match to BYPASS. If you do not want to skip, please set the firewall_match to MATCH_EXTERNAL_ADDRESS or MATCH_INTERNAL_ADDRESS.  Please note, the firewall_match will take priority over the nat_pass. If both are provided, the nat_pass is ignored. If firewall_match is not provided while the nat_pass is specified, the nat_pass will still be picked up. In this case, if nat_pass is set to false, firewall rule will be applied on internall address of a packet, i.e. MATCH_INTERNAL_ADDRESS. ")
  public Boolean isNatPass() {
    return natPass;
  }

  public void setNatPass(Boolean natPass) {
    this.natPass = natPass;
  }

   /**
   * The logical router id which the nat rule runs on.
   * @return logicalRouterId
  **/
  @Schema(description = "The logical router id which the nat rule runs on.")
  public String getLogicalRouterId() {
    return logicalRouterId;
  }

  public NatRule matchSourceNetwork(String matchSourceNetwork) {
    this.matchSourceNetwork = matchSourceNetwork;
    return this;
  }

   /**
   * IP Address | CIDR | (null implies Any) 
   * @return matchSourceNetwork
  **/
  @Schema(description = "IP Address | CIDR | (null implies Any) ")
  public String getMatchSourceNetwork() {
    return matchSourceNetwork;
  }

  public void setMatchSourceNetwork(String matchSourceNetwork) {
    this.matchSourceNetwork = matchSourceNetwork;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NatRule natRule = (NatRule) o;
    return Objects.equals(this.matchDestinationNetwork, natRule.matchDestinationNetwork) &&
        Objects.equals(this.translatedNetwork, natRule.translatedNetwork) &&
        Objects.equals(this.rulePriority, natRule.rulePriority) &&
        Objects.equals(this.matchService, natRule.matchService) &&
        Objects.equals(this.appliedTos, natRule.appliedTos) &&
        Objects.equals(this.enabled, natRule.enabled) &&
        Objects.equals(this.internalRuleId, natRule.internalRuleId) &&
        Objects.equals(this.logging, natRule.logging) &&
        Objects.equals(this.translatedPorts, natRule.translatedPorts) &&
        Objects.equals(this.action, natRule.action) &&
        Objects.equals(this.firewallMatch, natRule.firewallMatch) &&
        Objects.equals(this.natPass, natRule.natPass) &&
        Objects.equals(this.logicalRouterId, natRule.logicalRouterId) &&
        Objects.equals(this.matchSourceNetwork, natRule.matchSourceNetwork) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(matchDestinationNetwork, translatedNetwork, rulePriority, matchService, appliedTos, enabled, internalRuleId, logging, translatedPorts, action, firewallMatch, natPass, logicalRouterId, matchSourceNetwork, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NatRule {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    matchDestinationNetwork: ").append(toIndentedString(matchDestinationNetwork)).append("\n");
    sb.append("    translatedNetwork: ").append(toIndentedString(translatedNetwork)).append("\n");
    sb.append("    rulePriority: ").append(toIndentedString(rulePriority)).append("\n");
    sb.append("    matchService: ").append(toIndentedString(matchService)).append("\n");
    sb.append("    appliedTos: ").append(toIndentedString(appliedTos)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    internalRuleId: ").append(toIndentedString(internalRuleId)).append("\n");
    sb.append("    logging: ").append(toIndentedString(logging)).append("\n");
    sb.append("    translatedPorts: ").append(toIndentedString(translatedPorts)).append("\n");
    sb.append("    action: ").append(toIndentedString(action)).append("\n");
    sb.append("    firewallMatch: ").append(toIndentedString(firewallMatch)).append("\n");
    sb.append("    natPass: ").append(toIndentedString(natPass)).append("\n");
    sb.append("    logicalRouterId: ").append(toIndentedString(logicalRouterId)).append("\n");
    sb.append("    matchSourceNetwork: ").append(toIndentedString(matchSourceNetwork)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
