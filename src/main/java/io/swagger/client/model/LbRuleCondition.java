/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * Match conditions are used to match application traffic passing through load balancers. Multiple match conditions can be specified in one load balancer rule, each match condition defines a criterion for application traffic. If inverse field is set to true, the match result of the condition is inverted. If more than one match condition is specified, match strategy determines if all conditions should match or any one condition should match for the load balancer rule to be considered a match. Currently only HTTP messages are supported by load balancer rules. Each load balancer rule is used at a specific phase of load balancer processing. Currently three phases are supported, HTTP_REQUEST_REWRITE, HTTP_FORWARDING and HTTP_RESPONSE_REWRITE. Each phase supports certain types of match conditions, supported match conditions in HTTP_REQUEST_REWRITE phase are: LbHttpRequestMethodCondition LbHttpRequestUriCondition LbHttpRequestUriArgumentsCondition LbHttpRequestVersionCondition LbHttpRequestHeaderCondition LbHttpRequestCookieCondition LbHttpRequestBodyCondition LbTcpHeaderCondition LbIpHeaderCondition LbVariableCondition LbHttpSslCondition Supported match conditions in HTTP_FORWARDING phase are: LbHttpRequestMethodCondition LbHttpRequestUriCondition LbHttpRequestUriArgumentsCondition LbHttpRequestVersionCondition LbHttpRequestHeaderCondition LbHttpRequestCookieCondition LbHttpRequestBodyCondition LbTcpHeaderCondition LbIpHeaderCondition LbVariableCondition LbHttpSslCondition Supported match condition in HTTP_RESPONSE_REWRITE phase is: LbHttpResponseHeaderCondition LbHttpRequestMethodCondition LbHttpRequestUriCondition LbHttpRequestUriArgumentsCondition LbHttpRequestVersionCondition LbHttpRequestHeaderCondition LbHttpRequestCookieCondition LbTcpHeaderCondition LbIpHeaderCondition LbVariableCondition LbHttpSslCondition 
 */
@Schema(description = "Match conditions are used to match application traffic passing through load balancers. Multiple match conditions can be specified in one load balancer rule, each match condition defines a criterion for application traffic. If inverse field is set to true, the match result of the condition is inverted. If more than one match condition is specified, match strategy determines if all conditions should match or any one condition should match for the load balancer rule to be considered a match. Currently only HTTP messages are supported by load balancer rules. Each load balancer rule is used at a specific phase of load balancer processing. Currently three phases are supported, HTTP_REQUEST_REWRITE, HTTP_FORWARDING and HTTP_RESPONSE_REWRITE. Each phase supports certain types of match conditions, supported match conditions in HTTP_REQUEST_REWRITE phase are: LbHttpRequestMethodCondition LbHttpRequestUriCondition LbHttpRequestUriArgumentsCondition LbHttpRequestVersionCondition LbHttpRequestHeaderCondition LbHttpRequestCookieCondition LbHttpRequestBodyCondition LbTcpHeaderCondition LbIpHeaderCondition LbVariableCondition LbHttpSslCondition Supported match conditions in HTTP_FORWARDING phase are: LbHttpRequestMethodCondition LbHttpRequestUriCondition LbHttpRequestUriArgumentsCondition LbHttpRequestVersionCondition LbHttpRequestHeaderCondition LbHttpRequestCookieCondition LbHttpRequestBodyCondition LbTcpHeaderCondition LbIpHeaderCondition LbVariableCondition LbHttpSslCondition Supported match condition in HTTP_RESPONSE_REWRITE phase is: LbHttpResponseHeaderCondition LbHttpRequestMethodCondition LbHttpRequestUriCondition LbHttpRequestUriArgumentsCondition LbHttpRequestVersionCondition LbHttpRequestHeaderCondition LbHttpRequestCookieCondition LbTcpHeaderCondition LbIpHeaderCondition LbVariableCondition LbHttpSslCondition ")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")

public class LbRuleCondition {
  @SerializedName("inverse")
  private Boolean inverse = false;

  /**
   * Type of load balancer rule condition
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    LBHTTPREQUESTMETHODCONDITION("LbHttpRequestMethodCondition"),
    LBHTTPREQUESTURICONDITION("LbHttpRequestUriCondition"),
    LBHTTPREQUESTURIARGUMENTSCONDITION("LbHttpRequestUriArgumentsCondition"),
    LBHTTPREQUESTVERSIONCONDITION("LbHttpRequestVersionCondition"),
    LBHTTPREQUESTHEADERCONDITION("LbHttpRequestHeaderCondition"),
    LBHTTPREQUESTCOOKIECONDITION("LbHttpRequestCookieCondition"),
    LBHTTPREQUESTBODYCONDITION("LbHttpRequestBodyCondition"),
    LBHTTPRESPONSEHEADERCONDITION("LbHttpResponseHeaderCondition"),
    LBTCPHEADERCONDITION("LbTcpHeaderCondition"),
    LBIPHEADERCONDITION("LbIpHeaderCondition"),
    LBVARIABLECONDITION("LbVariableCondition"),
    LBHTTPSSLCONDITION("LbHttpSslCondition");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TypeEnum fromValue(String text) {
      for (TypeEnum b : TypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return TypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("type")
  private TypeEnum type = null;

  public LbRuleCondition() {
    this.type = this.getClass().getSimpleName();
  }
  public LbRuleCondition inverse(Boolean inverse) {
    this.inverse = inverse;
    return this;
  }

   /**
   * A flag to indicate whether reverse the match result of this condition
   * @return inverse
  **/
  @Schema(description = "A flag to indicate whether reverse the match result of this condition")
  public Boolean isInverse() {
    return inverse;
  }

  public void setInverse(Boolean inverse) {
    this.inverse = inverse;
  }

  public LbRuleCondition type(TypeEnum type) {
    this.type = type;
    return this;
  }

   /**
   * Type of load balancer rule condition
   * @return type
  **/
  @Schema(required = true, description = "Type of load balancer rule condition")
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LbRuleCondition lbRuleCondition = (LbRuleCondition) o;
    return Objects.equals(this.inverse, lbRuleCondition.inverse) &&
        Objects.equals(this.type, lbRuleCondition.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(inverse, type);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LbRuleCondition {\n");
    
    sb.append("    inverse: ").append(toIndentedString(inverse)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
