/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.LbRule;
import io.swagger.client.model.LbVirtualServer;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * LbVirtualServerWithRule
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class LbVirtualServerWithRule {
  @SerializedName("rules")
  private List<LbRule> rules = null;

  @SerializedName("virtual_server")
  private LbVirtualServer virtualServer = null;

  public LbVirtualServerWithRule rules(List<LbRule> rules) {
    this.rules = rules;
    return this;
  }

  public LbVirtualServerWithRule addRulesItem(LbRule rulesItem) {
    if (this.rules == null) {
      this.rules = new ArrayList<LbRule>();
    }
    this.rules.add(rulesItem);
    return this;
  }

   /**
   * It is used to add rules, update rules and bind rules to the virtual server. To add new rules, make sure that the rules have no identifier specified, the new rules are automatically generated and associated to the virtual server. If the virtual server need to consume some existed rules without change, those rules should not be specified in the list, otherwise, the rules are updated. For update_with_rules action, it supports rules delete and update. To delete old rules, the rules should not be configured in new action, the UUID of deleted rules should be removed from rule_ids. To update rules, the rules should be specified with new change and configured with identifier. If there are some rules which are not modified, those rule should not be specified in the rules list, the UUID list of rules should be specified in rule_ids of LbVirtualServer. 
   * @return rules
  **/
  @Schema(description = "It is used to add rules, update rules and bind rules to the virtual server. To add new rules, make sure that the rules have no identifier specified, the new rules are automatically generated and associated to the virtual server. If the virtual server need to consume some existed rules without change, those rules should not be specified in the list, otherwise, the rules are updated. For update_with_rules action, it supports rules delete and update. To delete old rules, the rules should not be configured in new action, the UUID of deleted rules should be removed from rule_ids. To update rules, the rules should be specified with new change and configured with identifier. If there are some rules which are not modified, those rule should not be specified in the rules list, the UUID list of rules should be specified in rule_ids of LbVirtualServer. ")
  public List<LbRule> getRules() {
    return rules;
  }

  public void setRules(List<LbRule> rules) {
    this.rules = rules;
  }

  public LbVirtualServerWithRule virtualServer(LbVirtualServer virtualServer) {
    this.virtualServer = virtualServer;
    return this;
  }

   /**
   * Get virtualServer
   * @return virtualServer
  **/
  @Schema(required = true, description = "")
  public LbVirtualServer getVirtualServer() {
    return virtualServer;
  }

  public void setVirtualServer(LbVirtualServer virtualServer) {
    this.virtualServer = virtualServer;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LbVirtualServerWithRule lbVirtualServerWithRule = (LbVirtualServerWithRule) o;
    return Objects.equals(this.rules, lbVirtualServerWithRule.rules) &&
        Objects.equals(this.virtualServer, lbVirtualServerWithRule.virtualServer);
  }

  @Override
  public int hashCode() {
    return Objects.hash(rules, virtualServer);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LbVirtualServerWithRule {\n");
    
    sb.append("    rules: ").append(toIndentedString(rules)).append("\n");
    sb.append("    virtualServer: ").append(toIndentedString(virtualServer)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
