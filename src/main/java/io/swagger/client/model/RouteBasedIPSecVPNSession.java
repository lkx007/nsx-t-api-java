/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.IPSecVPNSession;
import io.swagger.client.model.TcpMssClamping;
import io.swagger.client.model.TunnelPortConfig;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * A Route Based VPN is more flexible, more powerful and recommended over policy based VPN. IP Tunnel port is created and all traffic routed via tunnel port is protected. Routes can be configured statically or can be learned through BGP. A route based VPN is must for establishing redundant VPN session to remote site.
 */
@Schema(description = "A Route Based VPN is more flexible, more powerful and recommended over policy based VPN. IP Tunnel port is created and all traffic routed via tunnel port is protected. Routes can be configured statically or can be learned through BGP. A route based VPN is must for establishing redundant VPN session to remote site.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class RouteBasedIPSecVPNSession extends IPSecVPNSession {
  @SerializedName("tunnel_ports")
  private List<TunnelPortConfig> tunnelPorts = new ArrayList<TunnelPortConfig>();

  public RouteBasedIPSecVPNSession tunnelPorts(List<TunnelPortConfig> tunnelPorts) {
    this.tunnelPorts = tunnelPorts;
    return this;
  }

  public RouteBasedIPSecVPNSession addTunnelPortsItem(TunnelPortConfig tunnelPortsItem) {
    this.tunnelPorts.add(tunnelPortsItem);
    return this;
  }

   /**
   * IP Tunnel ports.
   * @return tunnelPorts
  **/
  @Schema(required = true, description = "IP Tunnel ports.")
  public List<TunnelPortConfig> getTunnelPorts() {
    return tunnelPorts;
  }

  public void setTunnelPorts(List<TunnelPortConfig> tunnelPorts) {
    this.tunnelPorts = tunnelPorts;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RouteBasedIPSecVPNSession routeBasedIPSecVPNSession = (RouteBasedIPSecVPNSession) o;
    return Objects.equals(this.tunnelPorts, routeBasedIPSecVPNSession.tunnelPorts) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(tunnelPorts, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RouteBasedIPSecVPNSession {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    tunnelPorts: ").append(toIndentedString(tunnelPorts)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
