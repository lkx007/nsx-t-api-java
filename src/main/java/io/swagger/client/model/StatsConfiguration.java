/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.Datasource;
import io.swagger.client.model.DonutSection;
import io.swagger.client.model.Footer;
import io.swagger.client.model.Icon;
import io.swagger.client.model.Label;
import io.swagger.client.model.Legend;
import io.swagger.client.model.StatItem;
import io.swagger.client.model.WidgetConfiguration;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * Represents configuration of a statistic for an entity. Example, number of logical switches and their admin states.
 */
@Schema(description = "Represents configuration of a statistic for an entity. Example, number of logical switches and their admin states.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class StatsConfiguration extends WidgetConfiguration {
  @SerializedName("navigation")
  private String navigation = null;

  @SerializedName("stat")
  private StatItem stat = null;

  @SerializedName("sections")
  private List<DonutSection> sections = null;

  /**
   * A sub-type of StatsConfiguration. If sub-type is not specified the parent type is rendered. The COMPACT sub_type, conserves the space for the widget. The statistic is placed on the right side on top of the status bar and the title of the widget is placed on the left side on the top of the status bar. The COMPACT style aligns itself horizontally as per the width of the container. If multiple widgets are placed insided the container then the widgets are placed one below the other to conserve the space.
   */
  @JsonAdapter(SubTypeEnum.Adapter.class)
  public enum SubTypeEnum {
    COMPACT("COMPACT");

    private String value;

    SubTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static SubTypeEnum fromValue(String text) {
      for (SubTypeEnum b : SubTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<SubTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SubTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SubTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return SubTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("sub_type")
  private SubTypeEnum subType = null;

  @SerializedName("label")
  private Label label = null;

  public StatsConfiguration navigation(String navigation) {
    this.navigation = navigation;
    return this;
  }

   /**
   * Hyperlink of the specified UI page that provides details.
   * @return navigation
  **/
  @Schema(description = "Hyperlink of the specified UI page that provides details.")
  public String getNavigation() {
    return navigation;
  }

  public void setNavigation(String navigation) {
    this.navigation = navigation;
  }

  public StatsConfiguration stat(StatItem stat) {
    this.stat = stat;
    return this;
  }

   /**
   * Get stat
   * @return stat
  **/
  @Schema(description = "")
  public StatItem getStat() {
    return stat;
  }

  public void setStat(StatItem stat) {
    this.stat = stat;
  }

  public StatsConfiguration sections(List<DonutSection> sections) {
    this.sections = sections;
    return this;
  }

  public StatsConfiguration addSectionsItem(DonutSection sectionsItem) {
    if (this.sections == null) {
      this.sections = new ArrayList<DonutSection>();
    }
    this.sections.add(sectionsItem);
    return this;
  }

   /**
   * Sections
   * @return sections
  **/
  @Schema(description = "Sections")
  public List<DonutSection> getSections() {
    return sections;
  }

  public void setSections(List<DonutSection> sections) {
    this.sections = sections;
  }

  public StatsConfiguration subType(SubTypeEnum subType) {
    this.subType = subType;
    return this;
  }

   /**
   * A sub-type of StatsConfiguration. If sub-type is not specified the parent type is rendered. The COMPACT sub_type, conserves the space for the widget. The statistic is placed on the right side on top of the status bar and the title of the widget is placed on the left side on the top of the status bar. The COMPACT style aligns itself horizontally as per the width of the container. If multiple widgets are placed insided the container then the widgets are placed one below the other to conserve the space.
   * @return subType
  **/
  @Schema(description = "A sub-type of StatsConfiguration. If sub-type is not specified the parent type is rendered. The COMPACT sub_type, conserves the space for the widget. The statistic is placed on the right side on top of the status bar and the title of the widget is placed on the left side on the top of the status bar. The COMPACT style aligns itself horizontally as per the width of the container. If multiple widgets are placed insided the container then the widgets are placed one below the other to conserve the space.")
  public SubTypeEnum getSubType() {
    return subType;
  }

  public void setSubType(SubTypeEnum subType) {
    this.subType = subType;
  }

  public StatsConfiguration label(Label label) {
    this.label = label;
    return this;
  }

   /**
   * Get label
   * @return label
  **/
  @Schema(description = "")
  public Label getLabel() {
    return label;
  }

  public void setLabel(Label label) {
    this.label = label;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    StatsConfiguration statsConfiguration = (StatsConfiguration) o;
    return Objects.equals(this.navigation, statsConfiguration.navigation) &&
        Objects.equals(this.stat, statsConfiguration.stat) &&
        Objects.equals(this.sections, statsConfiguration.sections) &&
        Objects.equals(this.subType, statsConfiguration.subType) &&
        Objects.equals(this.label, statsConfiguration.label) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(navigation, stat, sections, subType, label, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class StatsConfiguration {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    navigation: ").append(toIndentedString(navigation)).append("\n");
    sb.append("    stat: ").append(toIndentedString(stat)).append("\n");
    sb.append("    sections: ").append(toIndentedString(sections)).append("\n");
    sb.append("    subType: ").append(toIndentedString(subType)).append("\n");
    sb.append("    label: ").append(toIndentedString(label)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
