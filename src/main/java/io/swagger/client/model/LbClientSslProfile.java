/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.LbSslProfile;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * LbClientSslProfile
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class LbClientSslProfile extends LbSslProfile {
  @SerializedName("session_cache_enabled")
  private Boolean sessionCacheEnabled = true;

  @SerializedName("session_cache_timeout")
  private Long sessionCacheTimeout = 300l;

  /**
   * It is a label of cipher group which is mostly consumed by GUI. 
   */
  @JsonAdapter(CipherGroupLabelEnum.Adapter.class)
  public enum CipherGroupLabelEnum {
    BALANCED("BALANCED"),
    HIGH_SECURITY("HIGH_SECURITY"),
    HIGH_COMPATIBILITY("HIGH_COMPATIBILITY"),
    CUSTOM("CUSTOM");

    private String value;

    CipherGroupLabelEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static CipherGroupLabelEnum fromValue(String text) {
      for (CipherGroupLabelEnum b : CipherGroupLabelEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<CipherGroupLabelEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CipherGroupLabelEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CipherGroupLabelEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return CipherGroupLabelEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("cipher_group_label")
  private CipherGroupLabelEnum cipherGroupLabel = null;

  @SerializedName("is_fips")
  private Boolean isFips = null;

  @SerializedName("is_secure")
  private Boolean isSecure = null;

  @SerializedName("prefer_server_ciphers")
  private Boolean preferServerCiphers = true;

  /**
   * SSL cipher
   */
  @JsonAdapter(CiphersEnum.Adapter.class)
  public enum CiphersEnum {
    ECDHE_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"),
    ECDHE_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"),
    ECDHE_RSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"),
    ECDHE_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"),
    ECDH_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA"),
    ECDH_RSA_WITH_AES_256_CBC_SHA("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA"),
    RSA_WITH_AES_256_CBC_SHA("TLS_RSA_WITH_AES_256_CBC_SHA"),
    RSA_WITH_AES_128_CBC_SHA("TLS_RSA_WITH_AES_128_CBC_SHA"),
    RSA_WITH_3DES_EDE_CBC_SHA("TLS_RSA_WITH_3DES_EDE_CBC_SHA"),
    ECDHE_RSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"),
    ECDHE_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"),
    ECDHE_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384"),
    RSA_WITH_AES_128_CBC_SHA256("TLS_RSA_WITH_AES_128_CBC_SHA256"),
    RSA_WITH_AES_128_GCM_SHA256("TLS_RSA_WITH_AES_128_GCM_SHA256"),
    RSA_WITH_AES_256_CBC_SHA256("TLS_RSA_WITH_AES_256_CBC_SHA256"),
    RSA_WITH_AES_256_GCM_SHA384("TLS_RSA_WITH_AES_256_GCM_SHA384"),
    ECDHE_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"),
    ECDHE_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"),
    ECDHE_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"),
    ECDHE_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384"),
    ECDHE_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"),
    ECDH_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA"),
    ECDH_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256"),
    ECDH_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256"),
    ECDH_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384"),
    ECDH_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384"),
    ECDH_RSA_WITH_AES_128_CBC_SHA("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA"),
    ECDH_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256"),
    ECDH_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256"),
    ECDH_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384"),
    ECDH_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384");

    private String value;

    CiphersEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static CiphersEnum fromValue(String text) {
      for (CiphersEnum b : CiphersEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<CiphersEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CiphersEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CiphersEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return CiphersEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("ciphers")
  private List<CiphersEnum> ciphers = null;

  /**
   * SSL protocol
   */
  @JsonAdapter(ProtocolsEnum.Adapter.class)
  public enum ProtocolsEnum {
    SSL_V2("SSL_V2"),
    SSL_V3("SSL_V3"),
    TLS_V1("TLS_V1"),
    TLS_V1_1("TLS_V1_1"),
    TLS_V1_2("TLS_V1_2");

    private String value;

    ProtocolsEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ProtocolsEnum fromValue(String text) {
      for (ProtocolsEnum b : ProtocolsEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ProtocolsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProtocolsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProtocolsEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ProtocolsEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("protocols")
  private List<ProtocolsEnum> protocols = null;

  public LbClientSslProfile sessionCacheEnabled(Boolean sessionCacheEnabled) {
    this.sessionCacheEnabled = sessionCacheEnabled;
    return this;
  }

   /**
   * SSL session caching allows SSL client and server to reuse previously negotiated security parameters avoiding the expensive public key operation during handshake. 
   * @return sessionCacheEnabled
  **/
  @Schema(description = "SSL session caching allows SSL client and server to reuse previously negotiated security parameters avoiding the expensive public key operation during handshake. ")
  public Boolean isSessionCacheEnabled() {
    return sessionCacheEnabled;
  }

  public void setSessionCacheEnabled(Boolean sessionCacheEnabled) {
    this.sessionCacheEnabled = sessionCacheEnabled;
  }

  public LbClientSslProfile sessionCacheTimeout(Long sessionCacheTimeout) {
    this.sessionCacheTimeout = sessionCacheTimeout;
    return this;
  }

   /**
   * Session cache timeout specifies how long the SSL session parameters are held on to and can be reused. 
   * minimum: 1
   * maximum: 86400
   * @return sessionCacheTimeout
  **/
  @Schema(description = "Session cache timeout specifies how long the SSL session parameters are held on to and can be reused. ")
  public Long getSessionCacheTimeout() {
    return sessionCacheTimeout;
  }

  public void setSessionCacheTimeout(Long sessionCacheTimeout) {
    this.sessionCacheTimeout = sessionCacheTimeout;
  }

  public LbClientSslProfile cipherGroupLabel(CipherGroupLabelEnum cipherGroupLabel) {
    this.cipherGroupLabel = cipherGroupLabel;
    return this;
  }

   /**
   * It is a label of cipher group which is mostly consumed by GUI. 
   * @return cipherGroupLabel
  **/
  @Schema(description = "It is a label of cipher group which is mostly consumed by GUI. ")
  public CipherGroupLabelEnum getCipherGroupLabel() {
    return cipherGroupLabel;
  }

  public void setCipherGroupLabel(CipherGroupLabelEnum cipherGroupLabel) {
    this.cipherGroupLabel = cipherGroupLabel;
  }

   /**
   * This flag is set to true when all the ciphers and protocols are FIPS compliant. It is set to false when one of the ciphers or protocols are not FIPS compliant.. 
   * @return isFips
  **/
  @Schema(description = "This flag is set to true when all the ciphers and protocols are FIPS compliant. It is set to false when one of the ciphers or protocols are not FIPS compliant.. ")
  public Boolean isIsFips() {
    return isFips;
  }

   /**
   * This flag is set to true when all the ciphers and protocols are secure. It is set to false when one of the ciphers or protocols is insecure. 
   * @return isSecure
  **/
  @Schema(description = "This flag is set to true when all the ciphers and protocols are secure. It is set to false when one of the ciphers or protocols is insecure. ")
  public Boolean isIsSecure() {
    return isSecure;
  }

  public LbClientSslProfile preferServerCiphers(Boolean preferServerCiphers) {
    this.preferServerCiphers = preferServerCiphers;
    return this;
  }

   /**
   * During SSL handshake as part of the SSL client Hello client sends an ordered list of ciphers that it can support (or prefers) and typically server selects the first one from the top of that list it can also support. For Perfect Forward Secrecy(PFS), server could override the client&#x27;s preference. 
   * @return preferServerCiphers
  **/
  @Schema(description = "During SSL handshake as part of the SSL client Hello client sends an ordered list of ciphers that it can support (or prefers) and typically server selects the first one from the top of that list it can also support. For Perfect Forward Secrecy(PFS), server could override the client's preference. ")
  public Boolean isPreferServerCiphers() {
    return preferServerCiphers;
  }

  public void setPreferServerCiphers(Boolean preferServerCiphers) {
    this.preferServerCiphers = preferServerCiphers;
  }

  public LbClientSslProfile ciphers(List<CiphersEnum> ciphers) {
    this.ciphers = ciphers;
    return this;
  }

  public LbClientSslProfile addCiphersItem(CiphersEnum ciphersItem) {
    if (this.ciphers == null) {
      this.ciphers = new ArrayList<CiphersEnum>();
    }
    this.ciphers.add(ciphersItem);
    return this;
  }

   /**
   * supported SSL cipher list to client side
   * @return ciphers
  **/
  @Schema(description = "supported SSL cipher list to client side")
  public List<CiphersEnum> getCiphers() {
    return ciphers;
  }

  public void setCiphers(List<CiphersEnum> ciphers) {
    this.ciphers = ciphers;
  }

  public LbClientSslProfile protocols(List<ProtocolsEnum> protocols) {
    this.protocols = protocols;
    return this;
  }

  public LbClientSslProfile addProtocolsItem(ProtocolsEnum protocolsItem) {
    if (this.protocols == null) {
      this.protocols = new ArrayList<ProtocolsEnum>();
    }
    this.protocols.add(protocolsItem);
    return this;
  }

   /**
   * SSL versions TLS1.1 and TLS1.2 are supported and enabled by default. SSLv2, SSLv3, and TLS1.0 are supported, but disabled by default. 
   * @return protocols
  **/
  @Schema(description = "SSL versions TLS1.1 and TLS1.2 are supported and enabled by default. SSLv2, SSLv3, and TLS1.0 are supported, but disabled by default. ")
  public List<ProtocolsEnum> getProtocols() {
    return protocols;
  }

  public void setProtocols(List<ProtocolsEnum> protocols) {
    this.protocols = protocols;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LbClientSslProfile lbClientSslProfile = (LbClientSslProfile) o;
    return Objects.equals(this.sessionCacheEnabled, lbClientSslProfile.sessionCacheEnabled) &&
        Objects.equals(this.sessionCacheTimeout, lbClientSslProfile.sessionCacheTimeout) &&
        Objects.equals(this.cipherGroupLabel, lbClientSslProfile.cipherGroupLabel) &&
        Objects.equals(this.isFips, lbClientSslProfile.isFips) &&
        Objects.equals(this.isSecure, lbClientSslProfile.isSecure) &&
        Objects.equals(this.preferServerCiphers, lbClientSslProfile.preferServerCiphers) &&
        Objects.equals(this.ciphers, lbClientSslProfile.ciphers) &&
        Objects.equals(this.protocols, lbClientSslProfile.protocols) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(sessionCacheEnabled, sessionCacheTimeout, cipherGroupLabel, isFips, isSecure, preferServerCiphers, ciphers, protocols, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LbClientSslProfile {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    sessionCacheEnabled: ").append(toIndentedString(sessionCacheEnabled)).append("\n");
    sb.append("    sessionCacheTimeout: ").append(toIndentedString(sessionCacheTimeout)).append("\n");
    sb.append("    cipherGroupLabel: ").append(toIndentedString(cipherGroupLabel)).append("\n");
    sb.append("    isFips: ").append(toIndentedString(isFips)).append("\n");
    sb.append("    isSecure: ").append(toIndentedString(isSecure)).append("\n");
    sb.append("    preferServerCiphers: ").append(toIndentedString(preferServerCiphers)).append("\n");
    sb.append("    ciphers: ").append(toIndentedString(ciphers)).append("\n");
    sb.append("    protocols: ").append(toIndentedString(protocols)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
