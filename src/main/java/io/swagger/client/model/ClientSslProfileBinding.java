/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * ClientSslProfileBinding
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class ClientSslProfileBinding {
  /**
   * client authentication mode
   */
  @JsonAdapter(ClientAuthEnum.Adapter.class)
  public enum ClientAuthEnum {
    REQUIRED("REQUIRED"),
    IGNORE("IGNORE");

    private String value;

    ClientAuthEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ClientAuthEnum fromValue(String text) {
      for (ClientAuthEnum b : ClientAuthEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ClientAuthEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ClientAuthEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ClientAuthEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ClientAuthEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("client_auth")
  private ClientAuthEnum clientAuth = ClientAuthEnum.IGNORE;

  @SerializedName("ssl_profile_id")
  private String sslProfileId = null;

  @SerializedName("certificate_chain_depth")
  private Long certificateChainDepth = 3l;

  @SerializedName("client_auth_ca_ids")
  private List<String> clientAuthCaIds = null;

  @SerializedName("default_certificate_id")
  private String defaultCertificateId = null;

  @SerializedName("sni_certificate_ids")
  private List<String> sniCertificateIds = null;

  @SerializedName("client_auth_crl_ids")
  private List<String> clientAuthCrlIds = null;

  public ClientSslProfileBinding clientAuth(ClientAuthEnum clientAuth) {
    this.clientAuth = clientAuth;
    return this;
  }

   /**
   * client authentication mode
   * @return clientAuth
  **/
  @Schema(description = "client authentication mode")
  public ClientAuthEnum getClientAuth() {
    return clientAuth;
  }

  public void setClientAuth(ClientAuthEnum clientAuth) {
    this.clientAuth = clientAuth;
  }

  public ClientSslProfileBinding sslProfileId(String sslProfileId) {
    this.sslProfileId = sslProfileId;
    return this;
  }

   /**
   * Client SSL profile defines reusable, application-independent client side SSL properties. 
   * @return sslProfileId
  **/
  @Schema(description = "Client SSL profile defines reusable, application-independent client side SSL properties. ")
  public String getSslProfileId() {
    return sslProfileId;
  }

  public void setSslProfileId(String sslProfileId) {
    this.sslProfileId = sslProfileId;
  }

  public ClientSslProfileBinding certificateChainDepth(Long certificateChainDepth) {
    this.certificateChainDepth = certificateChainDepth;
    return this;
  }

   /**
   * authentication depth is used to set the verification depth in the client certificates chain. 
   * minimum: 1
   * maximum: 2147483647
   * @return certificateChainDepth
  **/
  @Schema(description = "authentication depth is used to set the verification depth in the client certificates chain. ")
  public Long getCertificateChainDepth() {
    return certificateChainDepth;
  }

  public void setCertificateChainDepth(Long certificateChainDepth) {
    this.certificateChainDepth = certificateChainDepth;
  }

  public ClientSslProfileBinding clientAuthCaIds(List<String> clientAuthCaIds) {
    this.clientAuthCaIds = clientAuthCaIds;
    return this;
  }

  public ClientSslProfileBinding addClientAuthCaIdsItem(String clientAuthCaIdsItem) {
    if (this.clientAuthCaIds == null) {
      this.clientAuthCaIds = new ArrayList<String>();
    }
    this.clientAuthCaIds.add(clientAuthCaIdsItem);
    return this;
  }

   /**
   * If client auth type is REQUIRED, client certificate must be signed by one of the trusted Certificate Authorities (CAs), also referred to as root CAs, whose self signed certificates are specified. 
   * @return clientAuthCaIds
  **/
  @Schema(description = "If client auth type is REQUIRED, client certificate must be signed by one of the trusted Certificate Authorities (CAs), also referred to as root CAs, whose self signed certificates are specified. ")
  public List<String> getClientAuthCaIds() {
    return clientAuthCaIds;
  }

  public void setClientAuthCaIds(List<String> clientAuthCaIds) {
    this.clientAuthCaIds = clientAuthCaIds;
  }

  public ClientSslProfileBinding defaultCertificateId(String defaultCertificateId) {
    this.defaultCertificateId = defaultCertificateId;
    return this;
  }

   /**
   * A default certificate should be specified which will be used if the server does not host multiple hostnames on the same IP address or if the client does not support SNI extension. 
   * @return defaultCertificateId
  **/
  @Schema(required = true, description = "A default certificate should be specified which will be used if the server does not host multiple hostnames on the same IP address or if the client does not support SNI extension. ")
  public String getDefaultCertificateId() {
    return defaultCertificateId;
  }

  public void setDefaultCertificateId(String defaultCertificateId) {
    this.defaultCertificateId = defaultCertificateId;
  }

  public ClientSslProfileBinding sniCertificateIds(List<String> sniCertificateIds) {
    this.sniCertificateIds = sniCertificateIds;
    return this;
  }

  public ClientSslProfileBinding addSniCertificateIdsItem(String sniCertificateIdsItem) {
    if (this.sniCertificateIds == null) {
      this.sniCertificateIds = new ArrayList<String>();
    }
    this.sniCertificateIds.add(sniCertificateIdsItem);
    return this;
  }

   /**
   * Client-side SSL profile binding allows multiple certificates, for different hostnames, to be bound to the same virtual server. 
   * @return sniCertificateIds
  **/
  @Schema(description = "Client-side SSL profile binding allows multiple certificates, for different hostnames, to be bound to the same virtual server. ")
  public List<String> getSniCertificateIds() {
    return sniCertificateIds;
  }

  public void setSniCertificateIds(List<String> sniCertificateIds) {
    this.sniCertificateIds = sniCertificateIds;
  }

  public ClientSslProfileBinding clientAuthCrlIds(List<String> clientAuthCrlIds) {
    this.clientAuthCrlIds = clientAuthCrlIds;
    return this;
  }

  public ClientSslProfileBinding addClientAuthCrlIdsItem(String clientAuthCrlIdsItem) {
    if (this.clientAuthCrlIds == null) {
      this.clientAuthCrlIds = new ArrayList<String>();
    }
    this.clientAuthCrlIds.add(clientAuthCrlIdsItem);
    return this;
  }

   /**
   * A Certificate Revocation List (CRL) can be specified in the client-side SSL profile binding to disallow compromised client certificates. 
   * @return clientAuthCrlIds
  **/
  @Schema(description = "A Certificate Revocation List (CRL) can be specified in the client-side SSL profile binding to disallow compromised client certificates. ")
  public List<String> getClientAuthCrlIds() {
    return clientAuthCrlIds;
  }

  public void setClientAuthCrlIds(List<String> clientAuthCrlIds) {
    this.clientAuthCrlIds = clientAuthCrlIds;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ClientSslProfileBinding clientSslProfileBinding = (ClientSslProfileBinding) o;
    return Objects.equals(this.clientAuth, clientSslProfileBinding.clientAuth) &&
        Objects.equals(this.sslProfileId, clientSslProfileBinding.sslProfileId) &&
        Objects.equals(this.certificateChainDepth, clientSslProfileBinding.certificateChainDepth) &&
        Objects.equals(this.clientAuthCaIds, clientSslProfileBinding.clientAuthCaIds) &&
        Objects.equals(this.defaultCertificateId, clientSslProfileBinding.defaultCertificateId) &&
        Objects.equals(this.sniCertificateIds, clientSslProfileBinding.sniCertificateIds) &&
        Objects.equals(this.clientAuthCrlIds, clientSslProfileBinding.clientAuthCrlIds);
  }

  @Override
  public int hashCode() {
    return Objects.hash(clientAuth, sslProfileId, certificateChainDepth, clientAuthCaIds, defaultCertificateId, sniCertificateIds, clientAuthCrlIds);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ClientSslProfileBinding {\n");
    
    sb.append("    clientAuth: ").append(toIndentedString(clientAuth)).append("\n");
    sb.append("    sslProfileId: ").append(toIndentedString(sslProfileId)).append("\n");
    sb.append("    certificateChainDepth: ").append(toIndentedString(certificateChainDepth)).append("\n");
    sb.append("    clientAuthCaIds: ").append(toIndentedString(clientAuthCaIds)).append("\n");
    sb.append("    defaultCertificateId: ").append(toIndentedString(defaultCertificateId)).append("\n");
    sb.append("    sniCertificateIds: ").append(toIndentedString(sniCertificateIds)).append("\n");
    sb.append("    clientAuthCrlIds: ").append(toIndentedString(clientAuthCrlIds)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
