/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.ManagedResource;
import io.swagger.client.model.Tag;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * IPSec VPN tunnel profile is a reusable profile that captures phase two negotiation parameters and tunnel properties. Any changes affects all IPSec VPN sessions consuming this profile.
 */
@Schema(description = "IPSec VPN tunnel profile is a reusable profile that captures phase two negotiation parameters and tunnel properties. Any changes affects all IPSec VPN sessions consuming this profile.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class IPSecVPNTunnelProfile extends ManagedResource {
  /**
   * Encapsulation Mode to be used for encryption of packet. Tunnel mode protects internal routing information by encrypting IP header of original packet.
   */
  @JsonAdapter(EncapsulationModeEnum.Adapter.class)
  public enum EncapsulationModeEnum {
    MODE("TUNNEL_MODE");

    private String value;

    EncapsulationModeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static EncapsulationModeEnum fromValue(String text) {
      for (EncapsulationModeEnum b : EncapsulationModeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<EncapsulationModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EncapsulationModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EncapsulationModeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return EncapsulationModeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("encapsulation_mode")
  private EncapsulationModeEnum encapsulationMode = EncapsulationModeEnum.MODE;

  /**
   * IPSec transform specifies IPSec security protocol.
   */
  @JsonAdapter(TransformProtocolEnum.Adapter.class)
  public enum TransformProtocolEnum {
    ESP("ESP");

    private String value;

    TransformProtocolEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TransformProtocolEnum fromValue(String text) {
      for (TransformProtocolEnum b : TransformProtocolEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TransformProtocolEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TransformProtocolEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TransformProtocolEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return TransformProtocolEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("transform_protocol")
  private TransformProtocolEnum transformProtocol = TransformProtocolEnum.ESP;

  /**
   * The TunnelDigestAlgorithms are used to verify message integrity during IPSec VPN tunnel establishment. SHA1 produces 160 bits hash and SHA2_XXX produces XXX bit hash. 
   */
  @JsonAdapter(DigestAlgorithmsEnum.Adapter.class)
  public enum DigestAlgorithmsEnum {
    SHA1("SHA1"),
    SHA2_256("SHA2_256"),
    SHA2_384("SHA2_384"),
    SHA2_512("SHA2_512");

    private String value;

    DigestAlgorithmsEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static DigestAlgorithmsEnum fromValue(String text) {
      for (DigestAlgorithmsEnum b : DigestAlgorithmsEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<DigestAlgorithmsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DigestAlgorithmsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DigestAlgorithmsEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return DigestAlgorithmsEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("digest_algorithms")
  private List<DigestAlgorithmsEnum> digestAlgorithms = null;

  /**
   * TunnelEncryption algorithms are used to ensure confidentiality of the messages exchanged during Tunnel negotiations. AES stands for Advanced Encryption Standards. AES_128 uses 128-bit keys whereas AES_256 uses 256-bit keys for encryption and decryption. AES_GCM stands for Advanced Encryption Standard(AES) in Galois/Counter Mode (GCM) and is used to provide both confidentiality and data origin authentication. NO_ENCRYPTION_AUTH_AES_GMAC_* enables authentication on input data without encyption. Digest algorithm should be empty for this option. 
   */
  @JsonAdapter(EncryptionAlgorithmsEnum.Adapter.class)
  public enum EncryptionAlgorithmsEnum {
    AES_128("AES_128"),
    AES_256("AES_256"),
    AES_GCM_128("AES_GCM_128"),
    AES_GCM_192("AES_GCM_192"),
    AES_GCM_256("AES_GCM_256"),
    NO_ENCRYPTION_AUTH_AES_GMAC_128("NO_ENCRYPTION_AUTH_AES_GMAC_128"),
    NO_ENCRYPTION_AUTH_AES_GMAC_192("NO_ENCRYPTION_AUTH_AES_GMAC_192"),
    NO_ENCRYPTION_AUTH_AES_GMAC_256("NO_ENCRYPTION_AUTH_AES_GMAC_256"),
    NO_ENCRYPTION("NO_ENCRYPTION");

    private String value;

    EncryptionAlgorithmsEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static EncryptionAlgorithmsEnum fromValue(String text) {
      for (EncryptionAlgorithmsEnum b : EncryptionAlgorithmsEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<EncryptionAlgorithmsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EncryptionAlgorithmsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EncryptionAlgorithmsEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return EncryptionAlgorithmsEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("encryption_algorithms")
  private List<EncryptionAlgorithmsEnum> encryptionAlgorithms = null;

  @SerializedName("enable_perfect_forward_secrecy")
  private Boolean enablePerfectForwardSecrecy = true;

  /**
   * Diffie-Hellman groups represent algorithm used to derive shared keys between IPSec VPN initiator and responder over an unsecured network. GROUP2 uses 1024-bit Modular Exponentiation (MODP) group. GROUP5 uses 1536-bit MODP group. GROUP14 uses 2048-bit MODP group. GROUP15 uses 3072-bit MODP group. GROUP16 uses 4096-bit MODP group. GROUP19 uses 256-bit random Elliptic Curve (ECP) group. GROUP20 uses 384-bit random ECP group. GROUP21 uses 521-bit random ECP group. 
   */
  @JsonAdapter(DhGroupsEnum.Adapter.class)
  public enum DhGroupsEnum {
    GROUP2("GROUP2"),
    GROUP5("GROUP5"),
    GROUP14("GROUP14"),
    GROUP15("GROUP15"),
    GROUP16("GROUP16"),
    GROUP19("GROUP19"),
    GROUP20("GROUP20"),
    GROUP21("GROUP21");

    private String value;

    DhGroupsEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static DhGroupsEnum fromValue(String text) {
      for (DhGroupsEnum b : DhGroupsEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<DhGroupsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DhGroupsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DhGroupsEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return DhGroupsEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("dh_groups")
  private List<DhGroupsEnum> dhGroups = null;

  /**
   * Defragmentation policy helps to handle defragmentation bit present in the inner packet. COPY copies the defragmentation bit from the inner IP packet into the outer packet. CLEAR ignores the defragmentation bit present in the inner packet.
   */
  @JsonAdapter(DfPolicyEnum.Adapter.class)
  public enum DfPolicyEnum {
    COPY("COPY"),
    CLEAR("CLEAR");

    private String value;

    DfPolicyEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static DfPolicyEnum fromValue(String text) {
      for (DfPolicyEnum b : DfPolicyEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<DfPolicyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DfPolicyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DfPolicyEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return DfPolicyEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("df_policy")
  private DfPolicyEnum dfPolicy = DfPolicyEnum.COPY;

  @SerializedName("sa_life_time")
  private Long saLifeTime = 3600l;

   /**
   * Encapsulation Mode to be used for encryption of packet. Tunnel mode protects internal routing information by encrypting IP header of original packet.
   * @return encapsulationMode
  **/
  @Schema(description = "Encapsulation Mode to be used for encryption of packet. Tunnel mode protects internal routing information by encrypting IP header of original packet.")
  public EncapsulationModeEnum getEncapsulationMode() {
    return encapsulationMode;
  }

   /**
   * IPSec transform specifies IPSec security protocol.
   * @return transformProtocol
  **/
  @Schema(description = "IPSec transform specifies IPSec security protocol.")
  public TransformProtocolEnum getTransformProtocol() {
    return transformProtocol;
  }

  public IPSecVPNTunnelProfile digestAlgorithms(List<DigestAlgorithmsEnum> digestAlgorithms) {
    this.digestAlgorithms = digestAlgorithms;
    return this;
  }

  public IPSecVPNTunnelProfile addDigestAlgorithmsItem(DigestAlgorithmsEnum digestAlgorithmsItem) {
    if (this.digestAlgorithms == null) {
      this.digestAlgorithms = new ArrayList<DigestAlgorithmsEnum>();
    }
    this.digestAlgorithms.add(digestAlgorithmsItem);
    return this;
  }

   /**
   * Algorithm to be used for message digest. Default digest algorithm is implicitly covered by default encryption algorithm \&quot;AES_GCM_128\&quot;.
   * @return digestAlgorithms
  **/
  @Schema(description = "Algorithm to be used for message digest. Default digest algorithm is implicitly covered by default encryption algorithm \"AES_GCM_128\".")
  public List<DigestAlgorithmsEnum> getDigestAlgorithms() {
    return digestAlgorithms;
  }

  public void setDigestAlgorithms(List<DigestAlgorithmsEnum> digestAlgorithms) {
    this.digestAlgorithms = digestAlgorithms;
  }

  public IPSecVPNTunnelProfile encryptionAlgorithms(List<EncryptionAlgorithmsEnum> encryptionAlgorithms) {
    this.encryptionAlgorithms = encryptionAlgorithms;
    return this;
  }

  public IPSecVPNTunnelProfile addEncryptionAlgorithmsItem(EncryptionAlgorithmsEnum encryptionAlgorithmsItem) {
    if (this.encryptionAlgorithms == null) {
      this.encryptionAlgorithms = new ArrayList<EncryptionAlgorithmsEnum>();
    }
    this.encryptionAlgorithms.add(encryptionAlgorithmsItem);
    return this;
  }

   /**
   * Encryption algorithm to encrypt/decrypt the messages exchanged between IPSec VPN initiator and responder during tunnel negotiation. Default is AES_GCM_128.
   * @return encryptionAlgorithms
  **/
  @Schema(description = "Encryption algorithm to encrypt/decrypt the messages exchanged between IPSec VPN initiator and responder during tunnel negotiation. Default is AES_GCM_128.")
  public List<EncryptionAlgorithmsEnum> getEncryptionAlgorithms() {
    return encryptionAlgorithms;
  }

  public void setEncryptionAlgorithms(List<EncryptionAlgorithmsEnum> encryptionAlgorithms) {
    this.encryptionAlgorithms = encryptionAlgorithms;
  }

  public IPSecVPNTunnelProfile enablePerfectForwardSecrecy(Boolean enablePerfectForwardSecrecy) {
    this.enablePerfectForwardSecrecy = enablePerfectForwardSecrecy;
    return this;
  }

   /**
   * If true, perfect forward secrecy (PFS) is enabled.
   * @return enablePerfectForwardSecrecy
  **/
  @Schema(description = "If true, perfect forward secrecy (PFS) is enabled.")
  public Boolean isEnablePerfectForwardSecrecy() {
    return enablePerfectForwardSecrecy;
  }

  public void setEnablePerfectForwardSecrecy(Boolean enablePerfectForwardSecrecy) {
    this.enablePerfectForwardSecrecy = enablePerfectForwardSecrecy;
  }

  public IPSecVPNTunnelProfile dhGroups(List<DhGroupsEnum> dhGroups) {
    this.dhGroups = dhGroups;
    return this;
  }

  public IPSecVPNTunnelProfile addDhGroupsItem(DhGroupsEnum dhGroupsItem) {
    if (this.dhGroups == null) {
      this.dhGroups = new ArrayList<DhGroupsEnum>();
    }
    this.dhGroups.add(dhGroupsItem);
    return this;
  }

   /**
   * Diffie-Hellman group to be used if PFS is enabled. Default is GROUP14.
   * @return dhGroups
  **/
  @Schema(description = "Diffie-Hellman group to be used if PFS is enabled. Default is GROUP14.")
  public List<DhGroupsEnum> getDhGroups() {
    return dhGroups;
  }

  public void setDhGroups(List<DhGroupsEnum> dhGroups) {
    this.dhGroups = dhGroups;
  }

  public IPSecVPNTunnelProfile dfPolicy(DfPolicyEnum dfPolicy) {
    this.dfPolicy = dfPolicy;
    return this;
  }

   /**
   * Defragmentation policy helps to handle defragmentation bit present in the inner packet. COPY copies the defragmentation bit from the inner IP packet into the outer packet. CLEAR ignores the defragmentation bit present in the inner packet.
   * @return dfPolicy
  **/
  @Schema(description = "Defragmentation policy helps to handle defragmentation bit present in the inner packet. COPY copies the defragmentation bit from the inner IP packet into the outer packet. CLEAR ignores the defragmentation bit present in the inner packet.")
  public DfPolicyEnum getDfPolicy() {
    return dfPolicy;
  }

  public void setDfPolicy(DfPolicyEnum dfPolicy) {
    this.dfPolicy = dfPolicy;
  }

  public IPSecVPNTunnelProfile saLifeTime(Long saLifeTime) {
    this.saLifeTime = saLifeTime;
    return this;
  }

   /**
   * SA life time specifies the expiry time of security association. Default is 3600 seconds. 
   * minimum: 900
   * maximum: 31536000
   * @return saLifeTime
  **/
  @Schema(description = "SA life time specifies the expiry time of security association. Default is 3600 seconds. ")
  public Long getSaLifeTime() {
    return saLifeTime;
  }

  public void setSaLifeTime(Long saLifeTime) {
    this.saLifeTime = saLifeTime;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IPSecVPNTunnelProfile ipSecVPNTunnelProfile = (IPSecVPNTunnelProfile) o;
    return Objects.equals(this.encapsulationMode, ipSecVPNTunnelProfile.encapsulationMode) &&
        Objects.equals(this.transformProtocol, ipSecVPNTunnelProfile.transformProtocol) &&
        Objects.equals(this.digestAlgorithms, ipSecVPNTunnelProfile.digestAlgorithms) &&
        Objects.equals(this.encryptionAlgorithms, ipSecVPNTunnelProfile.encryptionAlgorithms) &&
        Objects.equals(this.enablePerfectForwardSecrecy, ipSecVPNTunnelProfile.enablePerfectForwardSecrecy) &&
        Objects.equals(this.dhGroups, ipSecVPNTunnelProfile.dhGroups) &&
        Objects.equals(this.dfPolicy, ipSecVPNTunnelProfile.dfPolicy) &&
        Objects.equals(this.saLifeTime, ipSecVPNTunnelProfile.saLifeTime) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(encapsulationMode, transformProtocol, digestAlgorithms, encryptionAlgorithms, enablePerfectForwardSecrecy, dhGroups, dfPolicy, saLifeTime, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IPSecVPNTunnelProfile {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    encapsulationMode: ").append(toIndentedString(encapsulationMode)).append("\n");
    sb.append("    transformProtocol: ").append(toIndentedString(transformProtocol)).append("\n");
    sb.append("    digestAlgorithms: ").append(toIndentedString(digestAlgorithms)).append("\n");
    sb.append("    encryptionAlgorithms: ").append(toIndentedString(encryptionAlgorithms)).append("\n");
    sb.append("    enablePerfectForwardSecrecy: ").append(toIndentedString(enablePerfectForwardSecrecy)).append("\n");
    sb.append("    dhGroups: ").append(toIndentedString(dhGroups)).append("\n");
    sb.append("    dfPolicy: ").append(toIndentedString(dfPolicy)).append("\n");
    sb.append("    saLifeTime: ").append(toIndentedString(saLifeTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
