/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.LbActiveMonitor;
import io.swagger.client.model.LbHttpRequestHeader;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * LbHttpsMonitor
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class LbHttpsMonitor extends LbActiveMonitor {
  @SerializedName("response_status_codes")
  private List<Integer> responseStatusCodes = null;

  @SerializedName("server_auth_crl_ids")
  private List<String> serverAuthCrlIds = null;

  @SerializedName("server_auth_ca_ids")
  private List<String> serverAuthCaIds = null;

  /**
   * server authentication mode
   */
  @JsonAdapter(ServerAuthEnum.Adapter.class)
  public enum ServerAuthEnum {
    REQUIRED("REQUIRED"),
    IGNORE("IGNORE");

    private String value;

    ServerAuthEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ServerAuthEnum fromValue(String text) {
      for (ServerAuthEnum b : ServerAuthEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ServerAuthEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ServerAuthEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ServerAuthEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ServerAuthEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("server_auth")
  private ServerAuthEnum serverAuth = ServerAuthEnum.IGNORE;

  @SerializedName("request_body")
  private String requestBody = null;

  @SerializedName("response_body")
  private String responseBody = null;

  /**
   * SSL cipher
   */
  @JsonAdapter(CiphersEnum.Adapter.class)
  public enum CiphersEnum {
    ECDHE_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"),
    ECDHE_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"),
    ECDHE_RSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"),
    ECDHE_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"),
    ECDH_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA"),
    ECDH_RSA_WITH_AES_256_CBC_SHA("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA"),
    RSA_WITH_AES_256_CBC_SHA("TLS_RSA_WITH_AES_256_CBC_SHA"),
    RSA_WITH_AES_128_CBC_SHA("TLS_RSA_WITH_AES_128_CBC_SHA"),
    RSA_WITH_3DES_EDE_CBC_SHA("TLS_RSA_WITH_3DES_EDE_CBC_SHA"),
    ECDHE_RSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"),
    ECDHE_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"),
    ECDHE_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384"),
    RSA_WITH_AES_128_CBC_SHA256("TLS_RSA_WITH_AES_128_CBC_SHA256"),
    RSA_WITH_AES_128_GCM_SHA256("TLS_RSA_WITH_AES_128_GCM_SHA256"),
    RSA_WITH_AES_256_CBC_SHA256("TLS_RSA_WITH_AES_256_CBC_SHA256"),
    RSA_WITH_AES_256_GCM_SHA384("TLS_RSA_WITH_AES_256_GCM_SHA384"),
    ECDHE_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"),
    ECDHE_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"),
    ECDHE_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"),
    ECDHE_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384"),
    ECDHE_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"),
    ECDH_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA"),
    ECDH_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256"),
    ECDH_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256"),
    ECDH_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384"),
    ECDH_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384"),
    ECDH_RSA_WITH_AES_128_CBC_SHA("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA"),
    ECDH_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256"),
    ECDH_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256"),
    ECDH_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384"),
    ECDH_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384");

    private String value;

    CiphersEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static CiphersEnum fromValue(String text) {
      for (CiphersEnum b : CiphersEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<CiphersEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CiphersEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CiphersEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return CiphersEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("ciphers")
  private List<CiphersEnum> ciphers = null;

  @SerializedName("request_headers")
  private List<LbHttpRequestHeader> requestHeaders = null;

  @SerializedName("client_certificate_id")
  private String clientCertificateId = null;

  /**
   * the health check method for HTTP monitor type
   */
  @JsonAdapter(RequestMethodEnum.Adapter.class)
  public enum RequestMethodEnum {
    GET("GET"),
    OPTIONS("OPTIONS"),
    POST("POST"),
    HEAD("HEAD"),
    PUT("PUT");

    private String value;

    RequestMethodEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static RequestMethodEnum fromValue(String text) {
      for (RequestMethodEnum b : RequestMethodEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<RequestMethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RequestMethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RequestMethodEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return RequestMethodEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("request_method")
  private RequestMethodEnum requestMethod = RequestMethodEnum.GET;

  @SerializedName("is_fips")
  private Boolean isFips = null;

  @SerializedName("certificate_chain_depth")
  private Long certificateChainDepth = 3l;

  @SerializedName("is_secure")
  private Boolean isSecure = null;

  @SerializedName("request_url")
  private String requestUrl = null;

  /**
   * It is a label of cipher group which is mostly consumed by GUI. 
   */
  @JsonAdapter(CipherGroupLabelEnum.Adapter.class)
  public enum CipherGroupLabelEnum {
    BALANCED("BALANCED"),
    HIGH_SECURITY("HIGH_SECURITY"),
    HIGH_COMPATIBILITY("HIGH_COMPATIBILITY"),
    CUSTOM("CUSTOM");

    private String value;

    CipherGroupLabelEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static CipherGroupLabelEnum fromValue(String text) {
      for (CipherGroupLabelEnum b : CipherGroupLabelEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<CipherGroupLabelEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CipherGroupLabelEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CipherGroupLabelEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return CipherGroupLabelEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("cipher_group_label")
  private CipherGroupLabelEnum cipherGroupLabel = null;

  /**
   * HTTP request version
   */
  @JsonAdapter(RequestVersionEnum.Adapter.class)
  public enum RequestVersionEnum {
    _1_0("HTTP_VERSION_1_0"),
    _1_1("HTTP_VERSION_1_1"),
    _2_0("HTTP_VERSION_2_0");

    private String value;

    RequestVersionEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static RequestVersionEnum fromValue(String text) {
      for (RequestVersionEnum b : RequestVersionEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<RequestVersionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RequestVersionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RequestVersionEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return RequestVersionEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("request_version")
  private RequestVersionEnum requestVersion = RequestVersionEnum._1_1;

  /**
   * SSL protocol
   */
  @JsonAdapter(ProtocolsEnum.Adapter.class)
  public enum ProtocolsEnum {
    SSL_V2("SSL_V2"),
    SSL_V3("SSL_V3"),
    TLS_V1("TLS_V1"),
    TLS_V1_1("TLS_V1_1"),
    TLS_V1_2("TLS_V1_2");

    private String value;

    ProtocolsEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ProtocolsEnum fromValue(String text) {
      for (ProtocolsEnum b : ProtocolsEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ProtocolsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProtocolsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProtocolsEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ProtocolsEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("protocols")
  private List<ProtocolsEnum> protocols = null;

  public LbHttpsMonitor responseStatusCodes(List<Integer> responseStatusCodes) {
    this.responseStatusCodes = responseStatusCodes;
    return this;
  }

  public LbHttpsMonitor addResponseStatusCodesItem(Integer responseStatusCodesItem) {
    if (this.responseStatusCodes == null) {
      this.responseStatusCodes = new ArrayList<Integer>();
    }
    this.responseStatusCodes.add(responseStatusCodesItem);
    return this;
  }

   /**
   * The HTTP response status code should be a valid HTTP status code. 
   * @return responseStatusCodes
  **/
  @Schema(description = "The HTTP response status code should be a valid HTTP status code. ")
  public List<Integer> getResponseStatusCodes() {
    return responseStatusCodes;
  }

  public void setResponseStatusCodes(List<Integer> responseStatusCodes) {
    this.responseStatusCodes = responseStatusCodes;
  }

  public LbHttpsMonitor serverAuthCrlIds(List<String> serverAuthCrlIds) {
    this.serverAuthCrlIds = serverAuthCrlIds;
    return this;
  }

  public LbHttpsMonitor addServerAuthCrlIdsItem(String serverAuthCrlIdsItem) {
    if (this.serverAuthCrlIds == null) {
      this.serverAuthCrlIds = new ArrayList<String>();
    }
    this.serverAuthCrlIds.add(serverAuthCrlIdsItem);
    return this;
  }

   /**
   * A Certificate Revocation List (CRL) can be specified in the server-side SSL profile binding to disallow compromised server certificates. 
   * @return serverAuthCrlIds
  **/
  @Schema(description = "A Certificate Revocation List (CRL) can be specified in the server-side SSL profile binding to disallow compromised server certificates. ")
  public List<String> getServerAuthCrlIds() {
    return serverAuthCrlIds;
  }

  public void setServerAuthCrlIds(List<String> serverAuthCrlIds) {
    this.serverAuthCrlIds = serverAuthCrlIds;
  }

  public LbHttpsMonitor serverAuthCaIds(List<String> serverAuthCaIds) {
    this.serverAuthCaIds = serverAuthCaIds;
    return this;
  }

  public LbHttpsMonitor addServerAuthCaIdsItem(String serverAuthCaIdsItem) {
    if (this.serverAuthCaIds == null) {
      this.serverAuthCaIds = new ArrayList<String>();
    }
    this.serverAuthCaIds.add(serverAuthCaIdsItem);
    return this;
  }

   /**
   * If server auth type is REQUIRED, server certificate must be signed by one of the trusted Certificate Authorities (CAs), also referred to as root CAs, whose self signed certificates are specified. 
   * @return serverAuthCaIds
  **/
  @Schema(description = "If server auth type is REQUIRED, server certificate must be signed by one of the trusted Certificate Authorities (CAs), also referred to as root CAs, whose self signed certificates are specified. ")
  public List<String> getServerAuthCaIds() {
    return serverAuthCaIds;
  }

  public void setServerAuthCaIds(List<String> serverAuthCaIds) {
    this.serverAuthCaIds = serverAuthCaIds;
  }

  public LbHttpsMonitor serverAuth(ServerAuthEnum serverAuth) {
    this.serverAuth = serverAuth;
    return this;
  }

   /**
   * server authentication mode
   * @return serverAuth
  **/
  @Schema(description = "server authentication mode")
  public ServerAuthEnum getServerAuth() {
    return serverAuth;
  }

  public void setServerAuth(ServerAuthEnum serverAuth) {
    this.serverAuth = serverAuth;
  }

  public LbHttpsMonitor requestBody(String requestBody) {
    this.requestBody = requestBody;
    return this;
  }

   /**
   * String to send as part of HTTP health check request body. Valid only for certain HTTP methods like POST. 
   * @return requestBody
  **/
  @Schema(description = "String to send as part of HTTP health check request body. Valid only for certain HTTP methods like POST. ")
  public String getRequestBody() {
    return requestBody;
  }

  public void setRequestBody(String requestBody) {
    this.requestBody = requestBody;
  }

  public LbHttpsMonitor responseBody(String responseBody) {
    this.responseBody = responseBody;
    return this;
  }

   /**
   * If HTTP response body match string (regular expressions not supported) is specified (using LbHttpMonitor.response_body) then the healthcheck HTTP response body is matched against the specified string and server is considered healthy only if there is a match. If the response body string is not specified, HTTP healthcheck is considered successful if the HTTP response status code is 2xx, but it can be configured to accept other status codes as successful. 
   * @return responseBody
  **/
  @Schema(description = "If HTTP response body match string (regular expressions not supported) is specified (using LbHttpMonitor.response_body) then the healthcheck HTTP response body is matched against the specified string and server is considered healthy only if there is a match. If the response body string is not specified, HTTP healthcheck is considered successful if the HTTP response status code is 2xx, but it can be configured to accept other status codes as successful. ")
  public String getResponseBody() {
    return responseBody;
  }

  public void setResponseBody(String responseBody) {
    this.responseBody = responseBody;
  }

  public LbHttpsMonitor ciphers(List<CiphersEnum> ciphers) {
    this.ciphers = ciphers;
    return this;
  }

  public LbHttpsMonitor addCiphersItem(CiphersEnum ciphersItem) {
    if (this.ciphers == null) {
      this.ciphers = new ArrayList<CiphersEnum>();
    }
    this.ciphers.add(ciphersItem);
    return this;
  }

   /**
   * supported SSL cipher list to servers
   * @return ciphers
  **/
  @Schema(description = "supported SSL cipher list to servers")
  public List<CiphersEnum> getCiphers() {
    return ciphers;
  }

  public void setCiphers(List<CiphersEnum> ciphers) {
    this.ciphers = ciphers;
  }

  public LbHttpsMonitor requestHeaders(List<LbHttpRequestHeader> requestHeaders) {
    this.requestHeaders = requestHeaders;
    return this;
  }

  public LbHttpsMonitor addRequestHeadersItem(LbHttpRequestHeader requestHeadersItem) {
    if (this.requestHeaders == null) {
      this.requestHeaders = new ArrayList<LbHttpRequestHeader>();
    }
    this.requestHeaders.add(requestHeadersItem);
    return this;
  }

   /**
   * Array of HTTP request headers
   * @return requestHeaders
  **/
  @Schema(description = "Array of HTTP request headers")
  public List<LbHttpRequestHeader> getRequestHeaders() {
    return requestHeaders;
  }

  public void setRequestHeaders(List<LbHttpRequestHeader> requestHeaders) {
    this.requestHeaders = requestHeaders;
  }

  public LbHttpsMonitor clientCertificateId(String clientCertificateId) {
    this.clientCertificateId = clientCertificateId;
    return this;
  }

   /**
   * client certificate can be specified to support client authentication. 
   * @return clientCertificateId
  **/
  @Schema(description = "client certificate can be specified to support client authentication. ")
  public String getClientCertificateId() {
    return clientCertificateId;
  }

  public void setClientCertificateId(String clientCertificateId) {
    this.clientCertificateId = clientCertificateId;
  }

  public LbHttpsMonitor requestMethod(RequestMethodEnum requestMethod) {
    this.requestMethod = requestMethod;
    return this;
  }

   /**
   * the health check method for HTTP monitor type
   * @return requestMethod
  **/
  @Schema(description = "the health check method for HTTP monitor type")
  public RequestMethodEnum getRequestMethod() {
    return requestMethod;
  }

  public void setRequestMethod(RequestMethodEnum requestMethod) {
    this.requestMethod = requestMethod;
  }

   /**
   * This flag is set to true when all the ciphers and protocols are FIPS compliant. It is set to false when one of the ciphers or protocols are not FIPS compliant.. 
   * @return isFips
  **/
  @Schema(description = "This flag is set to true when all the ciphers and protocols are FIPS compliant. It is set to false when one of the ciphers or protocols are not FIPS compliant.. ")
  public Boolean isIsFips() {
    return isFips;
  }

  public LbHttpsMonitor certificateChainDepth(Long certificateChainDepth) {
    this.certificateChainDepth = certificateChainDepth;
    return this;
  }

   /**
   * authentication depth is used to set the verification depth in the server certificates chain. 
   * minimum: 1
   * maximum: 2147483647
   * @return certificateChainDepth
  **/
  @Schema(description = "authentication depth is used to set the verification depth in the server certificates chain. ")
  public Long getCertificateChainDepth() {
    return certificateChainDepth;
  }

  public void setCertificateChainDepth(Long certificateChainDepth) {
    this.certificateChainDepth = certificateChainDepth;
  }

   /**
   * This flag is set to true when all the ciphers and protocols are secure. It is set to false when one of the ciphers or protocols is insecure. 
   * @return isSecure
  **/
  @Schema(description = "This flag is set to true when all the ciphers and protocols are secure. It is set to false when one of the ciphers or protocols is insecure. ")
  public Boolean isIsSecure() {
    return isSecure;
  }

  public LbHttpsMonitor requestUrl(String requestUrl) {
    this.requestUrl = requestUrl;
    return this;
  }

   /**
   * URL used for HTTP monitor
   * @return requestUrl
  **/
  @Schema(description = "URL used for HTTP monitor")
  public String getRequestUrl() {
    return requestUrl;
  }

  public void setRequestUrl(String requestUrl) {
    this.requestUrl = requestUrl;
  }

  public LbHttpsMonitor cipherGroupLabel(CipherGroupLabelEnum cipherGroupLabel) {
    this.cipherGroupLabel = cipherGroupLabel;
    return this;
  }

   /**
   * It is a label of cipher group which is mostly consumed by GUI. 
   * @return cipherGroupLabel
  **/
  @Schema(description = "It is a label of cipher group which is mostly consumed by GUI. ")
  public CipherGroupLabelEnum getCipherGroupLabel() {
    return cipherGroupLabel;
  }

  public void setCipherGroupLabel(CipherGroupLabelEnum cipherGroupLabel) {
    this.cipherGroupLabel = cipherGroupLabel;
  }

  public LbHttpsMonitor requestVersion(RequestVersionEnum requestVersion) {
    this.requestVersion = requestVersion;
    return this;
  }

   /**
   * HTTP request version
   * @return requestVersion
  **/
  @Schema(description = "HTTP request version")
  public RequestVersionEnum getRequestVersion() {
    return requestVersion;
  }

  public void setRequestVersion(RequestVersionEnum requestVersion) {
    this.requestVersion = requestVersion;
  }

  public LbHttpsMonitor protocols(List<ProtocolsEnum> protocols) {
    this.protocols = protocols;
    return this;
  }

  public LbHttpsMonitor addProtocolsItem(ProtocolsEnum protocolsItem) {
    if (this.protocols == null) {
      this.protocols = new ArrayList<ProtocolsEnum>();
    }
    this.protocols.add(protocolsItem);
    return this;
  }

   /**
   * SSL versions TLS1.1 and TLS1.2 are supported and enabled by default. SSLv2, SSLv3, and TLS1.0 are supported, but disabled by default. 
   * @return protocols
  **/
  @Schema(description = "SSL versions TLS1.1 and TLS1.2 are supported and enabled by default. SSLv2, SSLv3, and TLS1.0 are supported, but disabled by default. ")
  public List<ProtocolsEnum> getProtocols() {
    return protocols;
  }

  public void setProtocols(List<ProtocolsEnum> protocols) {
    this.protocols = protocols;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LbHttpsMonitor lbHttpsMonitor = (LbHttpsMonitor) o;
    return Objects.equals(this.responseStatusCodes, lbHttpsMonitor.responseStatusCodes) &&
        Objects.equals(this.serverAuthCrlIds, lbHttpsMonitor.serverAuthCrlIds) &&
        Objects.equals(this.serverAuthCaIds, lbHttpsMonitor.serverAuthCaIds) &&
        Objects.equals(this.serverAuth, lbHttpsMonitor.serverAuth) &&
        Objects.equals(this.requestBody, lbHttpsMonitor.requestBody) &&
        Objects.equals(this.responseBody, lbHttpsMonitor.responseBody) &&
        Objects.equals(this.ciphers, lbHttpsMonitor.ciphers) &&
        Objects.equals(this.requestHeaders, lbHttpsMonitor.requestHeaders) &&
        Objects.equals(this.clientCertificateId, lbHttpsMonitor.clientCertificateId) &&
        Objects.equals(this.requestMethod, lbHttpsMonitor.requestMethod) &&
        Objects.equals(this.isFips, lbHttpsMonitor.isFips) &&
        Objects.equals(this.certificateChainDepth, lbHttpsMonitor.certificateChainDepth) &&
        Objects.equals(this.isSecure, lbHttpsMonitor.isSecure) &&
        Objects.equals(this.requestUrl, lbHttpsMonitor.requestUrl) &&
        Objects.equals(this.cipherGroupLabel, lbHttpsMonitor.cipherGroupLabel) &&
        Objects.equals(this.requestVersion, lbHttpsMonitor.requestVersion) &&
        Objects.equals(this.protocols, lbHttpsMonitor.protocols) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(responseStatusCodes, serverAuthCrlIds, serverAuthCaIds, serverAuth, requestBody, responseBody, ciphers, requestHeaders, clientCertificateId, requestMethod, isFips, certificateChainDepth, isSecure, requestUrl, cipherGroupLabel, requestVersion, protocols, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LbHttpsMonitor {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    responseStatusCodes: ").append(toIndentedString(responseStatusCodes)).append("\n");
    sb.append("    serverAuthCrlIds: ").append(toIndentedString(serverAuthCrlIds)).append("\n");
    sb.append("    serverAuthCaIds: ").append(toIndentedString(serverAuthCaIds)).append("\n");
    sb.append("    serverAuth: ").append(toIndentedString(serverAuth)).append("\n");
    sb.append("    requestBody: ").append(toIndentedString(requestBody)).append("\n");
    sb.append("    responseBody: ").append(toIndentedString(responseBody)).append("\n");
    sb.append("    ciphers: ").append(toIndentedString(ciphers)).append("\n");
    sb.append("    requestHeaders: ").append(toIndentedString(requestHeaders)).append("\n");
    sb.append("    clientCertificateId: ").append(toIndentedString(clientCertificateId)).append("\n");
    sb.append("    requestMethod: ").append(toIndentedString(requestMethod)).append("\n");
    sb.append("    isFips: ").append(toIndentedString(isFips)).append("\n");
    sb.append("    certificateChainDepth: ").append(toIndentedString(certificateChainDepth)).append("\n");
    sb.append("    isSecure: ").append(toIndentedString(isSecure)).append("\n");
    sb.append("    requestUrl: ").append(toIndentedString(requestUrl)).append("\n");
    sb.append("    cipherGroupLabel: ").append(toIndentedString(cipherGroupLabel)).append("\n");
    sb.append("    requestVersion: ").append(toIndentedString(requestVersion)).append("\n");
    sb.append("    protocols: ").append(toIndentedString(protocols)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
