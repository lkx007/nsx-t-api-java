/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * ServerSslProfileBinding
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class ServerSslProfileBinding {
  @SerializedName("server_auth_crl_ids")
  private List<String> serverAuthCrlIds = null;

  /**
   * server authentication mode
   */
  @JsonAdapter(ServerAuthEnum.Adapter.class)
  public enum ServerAuthEnum {
    REQUIRED("REQUIRED"),
    IGNORE("IGNORE");

    private String value;

    ServerAuthEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ServerAuthEnum fromValue(String text) {
      for (ServerAuthEnum b : ServerAuthEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ServerAuthEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ServerAuthEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ServerAuthEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ServerAuthEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("server_auth")
  private ServerAuthEnum serverAuth = ServerAuthEnum.IGNORE;

  @SerializedName("certificate_chain_depth")
  private Long certificateChainDepth = 3l;

  @SerializedName("client_certificate_id")
  private String clientCertificateId = null;

  @SerializedName("server_auth_ca_ids")
  private List<String> serverAuthCaIds = null;

  @SerializedName("ssl_profile_id")
  private String sslProfileId = null;

  public ServerSslProfileBinding serverAuthCrlIds(List<String> serverAuthCrlIds) {
    this.serverAuthCrlIds = serverAuthCrlIds;
    return this;
  }

  public ServerSslProfileBinding addServerAuthCrlIdsItem(String serverAuthCrlIdsItem) {
    if (this.serverAuthCrlIds == null) {
      this.serverAuthCrlIds = new ArrayList<String>();
    }
    this.serverAuthCrlIds.add(serverAuthCrlIdsItem);
    return this;
  }

   /**
   * A Certificate Revocation List (CRL) can be specified in the server-side SSL profile binding to disallow compromised server certificates. 
   * @return serverAuthCrlIds
  **/
  @Schema(description = "A Certificate Revocation List (CRL) can be specified in the server-side SSL profile binding to disallow compromised server certificates. ")
  public List<String> getServerAuthCrlIds() {
    return serverAuthCrlIds;
  }

  public void setServerAuthCrlIds(List<String> serverAuthCrlIds) {
    this.serverAuthCrlIds = serverAuthCrlIds;
  }

  public ServerSslProfileBinding serverAuth(ServerAuthEnum serverAuth) {
    this.serverAuth = serverAuth;
    return this;
  }

   /**
   * server authentication mode
   * @return serverAuth
  **/
  @Schema(description = "server authentication mode")
  public ServerAuthEnum getServerAuth() {
    return serverAuth;
  }

  public void setServerAuth(ServerAuthEnum serverAuth) {
    this.serverAuth = serverAuth;
  }

  public ServerSslProfileBinding certificateChainDepth(Long certificateChainDepth) {
    this.certificateChainDepth = certificateChainDepth;
    return this;
  }

   /**
   * authentication depth is used to set the verification depth in the server certificates chain. 
   * minimum: 1
   * maximum: 2147483647
   * @return certificateChainDepth
  **/
  @Schema(description = "authentication depth is used to set the verification depth in the server certificates chain. ")
  public Long getCertificateChainDepth() {
    return certificateChainDepth;
  }

  public void setCertificateChainDepth(Long certificateChainDepth) {
    this.certificateChainDepth = certificateChainDepth;
  }

  public ServerSslProfileBinding clientCertificateId(String clientCertificateId) {
    this.clientCertificateId = clientCertificateId;
    return this;
  }

   /**
   * To support client authentication (load balancer acting as a client authenticating to the backend server), client certificate can be specified in the server-side SSL profile binding 
   * @return clientCertificateId
  **/
  @Schema(description = "To support client authentication (load balancer acting as a client authenticating to the backend server), client certificate can be specified in the server-side SSL profile binding ")
  public String getClientCertificateId() {
    return clientCertificateId;
  }

  public void setClientCertificateId(String clientCertificateId) {
    this.clientCertificateId = clientCertificateId;
  }

  public ServerSslProfileBinding serverAuthCaIds(List<String> serverAuthCaIds) {
    this.serverAuthCaIds = serverAuthCaIds;
    return this;
  }

  public ServerSslProfileBinding addServerAuthCaIdsItem(String serverAuthCaIdsItem) {
    if (this.serverAuthCaIds == null) {
      this.serverAuthCaIds = new ArrayList<String>();
    }
    this.serverAuthCaIds.add(serverAuthCaIdsItem);
    return this;
  }

   /**
   * If server auth type is REQUIRED, server certificate must be signed by one of the trusted Certificate Authorities (CAs), also referred to as root CAs, whose self signed certificates are specified. 
   * @return serverAuthCaIds
  **/
  @Schema(description = "If server auth type is REQUIRED, server certificate must be signed by one of the trusted Certificate Authorities (CAs), also referred to as root CAs, whose self signed certificates are specified. ")
  public List<String> getServerAuthCaIds() {
    return serverAuthCaIds;
  }

  public void setServerAuthCaIds(List<String> serverAuthCaIds) {
    this.serverAuthCaIds = serverAuthCaIds;
  }

  public ServerSslProfileBinding sslProfileId(String sslProfileId) {
    this.sslProfileId = sslProfileId;
    return this;
  }

   /**
   * Server SSL profile defines reusable, application-independent server side SSL properties. 
   * @return sslProfileId
  **/
  @Schema(description = "Server SSL profile defines reusable, application-independent server side SSL properties. ")
  public String getSslProfileId() {
    return sslProfileId;
  }

  public void setSslProfileId(String sslProfileId) {
    this.sslProfileId = sslProfileId;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ServerSslProfileBinding serverSslProfileBinding = (ServerSslProfileBinding) o;
    return Objects.equals(this.serverAuthCrlIds, serverSslProfileBinding.serverAuthCrlIds) &&
        Objects.equals(this.serverAuth, serverSslProfileBinding.serverAuth) &&
        Objects.equals(this.certificateChainDepth, serverSslProfileBinding.certificateChainDepth) &&
        Objects.equals(this.clientCertificateId, serverSslProfileBinding.clientCertificateId) &&
        Objects.equals(this.serverAuthCaIds, serverSslProfileBinding.serverAuthCaIds) &&
        Objects.equals(this.sslProfileId, serverSslProfileBinding.sslProfileId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(serverAuthCrlIds, serverAuth, certificateChainDepth, clientCertificateId, serverAuthCaIds, sslProfileId);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ServerSslProfileBinding {\n");
    
    sb.append("    serverAuthCrlIds: ").append(toIndentedString(serverAuthCrlIds)).append("\n");
    sb.append("    serverAuth: ").append(toIndentedString(serverAuth)).append("\n");
    sb.append("    certificateChainDepth: ").append(toIndentedString(certificateChainDepth)).append("\n");
    sb.append("    clientCertificateId: ").append(toIndentedString(clientCertificateId)).append("\n");
    sb.append("    serverAuthCaIds: ").append(toIndentedString(serverAuthCaIds)).append("\n");
    sb.append("    sslProfileId: ").append(toIndentedString(sslProfileId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
