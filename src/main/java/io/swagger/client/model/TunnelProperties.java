/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.BFDProperties;
import io.swagger.client.model.Resource;
import io.swagger.client.model.ResourceLink;
import io.swagger.client.model.SelfResourceLink;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.List;
/**
 * TunnelProperties
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class TunnelProperties extends Resource {
  /**
   * Status of tunnel
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    UP("UP"),
    DOWN("DOWN"),
    UNKNOWN("UNKNOWN");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static StatusEnum fromValue(String text) {
      for (StatusEnum b : StatusEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return StatusEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("status")
  private StatusEnum status = null;

  @SerializedName("egress_interface")
  private String egressInterface = null;

  @SerializedName("remote_node_id")
  private String remoteNodeId = null;

  @SerializedName("bfd")
  private BFDProperties bfd = null;

  @SerializedName("local_ip")
  private String localIp = null;

  @SerializedName("last_updated_time")
  private Long lastUpdatedTime = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("remote_node_display_name")
  private String remoteNodeDisplayName = null;

  /**
   * Tunnel encap
   */
  @JsonAdapter(EncapEnum.Adapter.class)
  public enum EncapEnum {
    STT("STT"),
    VXLAN("VXLAN"),
    GENEVE("GENEVE"),
    UNKNOWN_ENCAP("UNKNOWN_ENCAP");

    private String value;

    EncapEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static EncapEnum fromValue(String text) {
      for (EncapEnum b : EncapEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<EncapEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EncapEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EncapEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return EncapEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("encap")
  private EncapEnum encap = null;

  /**
   * Latency type.
   */
  @JsonAdapter(LatencyTypeEnum.Adapter.class)
  public enum LatencyTypeEnum {
    UNKNOWN_LATENCY("UNKNOWN_LATENCY"),
    VALID("VALID"),
    NOT_READY("NOT_READY"),
    TIMEOUT("TIMEOUT");

    private String value;

    LatencyTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static LatencyTypeEnum fromValue(String text) {
      for (LatencyTypeEnum b : LatencyTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<LatencyTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LatencyTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LatencyTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return LatencyTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("latency_type")
  private LatencyTypeEnum latencyType = null;

  @SerializedName("latency_value")
  private Long latencyValue = null;

  @SerializedName("remote_ip")
  private String remoteIp = null;

   /**
   * Status of tunnel
   * @return status
  **/
  @Schema(description = "Status of tunnel")
  public StatusEnum getStatus() {
    return status;
  }

   /**
   * Corresponds to the interface where local_ip_address is routed.
   * @return egressInterface
  **/
  @Schema(description = "Corresponds to the interface where local_ip_address is routed.")
  public String getEgressInterface() {
    return egressInterface;
  }

   /**
   * UUID of the remote transport node
   * @return remoteNodeId
  **/
  @Schema(description = "UUID of the remote transport node")
  public String getRemoteNodeId() {
    return remoteNodeId;
  }

  public TunnelProperties bfd(BFDProperties bfd) {
    this.bfd = bfd;
    return this;
  }

   /**
   * Get bfd
   * @return bfd
  **/
  @Schema(description = "")
  public BFDProperties getBfd() {
    return bfd;
  }

  public void setBfd(BFDProperties bfd) {
    this.bfd = bfd;
  }

   /**
   * Local IP address of tunnel
   * @return localIp
  **/
  @Schema(description = "Local IP address of tunnel")
  public String getLocalIp() {
    return localIp;
  }

   /**
   * Time at which the Tunnel status has been fetched last time.
   * @return lastUpdatedTime
  **/
  @Schema(description = "Time at which the Tunnel status has been fetched last time.")
  public Long getLastUpdatedTime() {
    return lastUpdatedTime;
  }

   /**
   * Name of tunnel
   * @return name
  **/
  @Schema(description = "Name of tunnel")
  public String getName() {
    return name;
  }

   /**
   * Represents the display name of the remote transport node at the other end of the tunnel.
   * @return remoteNodeDisplayName
  **/
  @Schema(description = "Represents the display name of the remote transport node at the other end of the tunnel.")
  public String getRemoteNodeDisplayName() {
    return remoteNodeDisplayName;
  }

   /**
   * Tunnel encap
   * @return encap
  **/
  @Schema(description = "Tunnel encap")
  public EncapEnum getEncap() {
    return encap;
  }

   /**
   * Latency type.
   * @return latencyType
  **/
  @Schema(description = "Latency type.")
  public LatencyTypeEnum getLatencyType() {
    return latencyType;
  }

   /**
   * The latency value is set only when latency_type is VALID.
   * @return latencyValue
  **/
  @Schema(description = "The latency value is set only when latency_type is VALID.")
  public Long getLatencyValue() {
    return latencyValue;
  }

   /**
   * Remote IP address of tunnel
   * @return remoteIp
  **/
  @Schema(description = "Remote IP address of tunnel")
  public String getRemoteIp() {
    return remoteIp;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TunnelProperties tunnelProperties = (TunnelProperties) o;
    return Objects.equals(this.status, tunnelProperties.status) &&
        Objects.equals(this.egressInterface, tunnelProperties.egressInterface) &&
        Objects.equals(this.remoteNodeId, tunnelProperties.remoteNodeId) &&
        Objects.equals(this.bfd, tunnelProperties.bfd) &&
        Objects.equals(this.localIp, tunnelProperties.localIp) &&
        Objects.equals(this.lastUpdatedTime, tunnelProperties.lastUpdatedTime) &&
        Objects.equals(this.name, tunnelProperties.name) &&
        Objects.equals(this.remoteNodeDisplayName, tunnelProperties.remoteNodeDisplayName) &&
        Objects.equals(this.encap, tunnelProperties.encap) &&
        Objects.equals(this.latencyType, tunnelProperties.latencyType) &&
        Objects.equals(this.latencyValue, tunnelProperties.latencyValue) &&
        Objects.equals(this.remoteIp, tunnelProperties.remoteIp) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(status, egressInterface, remoteNodeId, bfd, localIp, lastUpdatedTime, name, remoteNodeDisplayName, encap, latencyType, latencyValue, remoteIp, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TunnelProperties {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    egressInterface: ").append(toIndentedString(egressInterface)).append("\n");
    sb.append("    remoteNodeId: ").append(toIndentedString(remoteNodeId)).append("\n");
    sb.append("    bfd: ").append(toIndentedString(bfd)).append("\n");
    sb.append("    localIp: ").append(toIndentedString(localIp)).append("\n");
    sb.append("    lastUpdatedTime: ").append(toIndentedString(lastUpdatedTime)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    remoteNodeDisplayName: ").append(toIndentedString(remoteNodeDisplayName)).append("\n");
    sb.append("    encap: ").append(toIndentedString(encap)).append("\n");
    sb.append("    latencyType: ").append(toIndentedString(latencyType)).append("\n");
    sb.append("    latencyValue: ").append(toIndentedString(latencyValue)).append("\n");
    sb.append("    remoteIp: ").append(toIndentedString(remoteIp)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
