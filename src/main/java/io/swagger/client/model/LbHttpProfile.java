/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.LbAppProfile;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * LbHttpProfile
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class LbHttpProfile extends LbAppProfile {
  @SerializedName("response_timeout")
  private Long responseTimeout = 60l;

  @SerializedName("idle_timeout")
  private Long idleTimeout = 15l;

  @SerializedName("request_body_size")
  private Long requestBodySize = null;

  @SerializedName("response_header_size")
  private Long responseHeaderSize = 4096l;

  @SerializedName("ntlm")
  private Boolean ntlm = false;

  @SerializedName("request_header_size")
  private Long requestHeaderSize = 1024l;

  @SerializedName("http_redirect_to")
  private String httpRedirectTo = null;

  /**
   * insert or replace x_forwarded_for
   */
  @JsonAdapter(XForwardedForEnum.Adapter.class)
  public enum XForwardedForEnum {
    INSERT("INSERT"),
    REPLACE("REPLACE");

    private String value;

    XForwardedForEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static XForwardedForEnum fromValue(String text) {
      for (XForwardedForEnum b : XForwardedForEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<XForwardedForEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final XForwardedForEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public XForwardedForEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return XForwardedForEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("x_forwarded_for")
  private XForwardedForEnum xForwardedFor = null;

  @SerializedName("http_redirect_to_https")
  private Boolean httpRedirectToHttps = false;

  public LbHttpProfile responseTimeout(Long responseTimeout) {
    this.responseTimeout = responseTimeout;
    return this;
  }

   /**
   * If server doesn&#x27;t send any packet within this time, the connection is closed. 
   * minimum: 1
   * maximum: 2147483647
   * @return responseTimeout
  **/
  @Schema(description = "If server doesn't send any packet within this time, the connection is closed. ")
  public Long getResponseTimeout() {
    return responseTimeout;
  }

  public void setResponseTimeout(Long responseTimeout) {
    this.responseTimeout = responseTimeout;
  }

  public LbHttpProfile idleTimeout(Long idleTimeout) {
    this.idleTimeout = idleTimeout;
    return this;
  }

   /**
   * It is used to specify the HTTP application idle timeout, it means that how long the load balancer will keep the connection idle to wait for the client to send the next keep-alive request. It is not a TCP socket setting. 
   * minimum: 1
   * maximum: 2147483647
   * @return idleTimeout
  **/
  @Schema(description = "It is used to specify the HTTP application idle timeout, it means that how long the load balancer will keep the connection idle to wait for the client to send the next keep-alive request. It is not a TCP socket setting. ")
  public Long getIdleTimeout() {
    return idleTimeout;
  }

  public void setIdleTimeout(Long idleTimeout) {
    this.idleTimeout = idleTimeout;
  }

  public LbHttpProfile requestBodySize(Long requestBodySize) {
    this.requestBodySize = requestBodySize;
    return this;
  }

   /**
   * If it is not specified, it means that request body size is unlimited. 
   * minimum: 1
   * maximum: 2147483647
   * @return requestBodySize
  **/
  @Schema(description = "If it is not specified, it means that request body size is unlimited. ")
  public Long getRequestBodySize() {
    return requestBodySize;
  }

  public void setRequestBodySize(Long requestBodySize) {
    this.requestBodySize = requestBodySize;
  }

  public LbHttpProfile responseHeaderSize(Long responseHeaderSize) {
    this.responseHeaderSize = responseHeaderSize;
    return this;
  }

   /**
   * A response with header larger than response_header_size will be dropped. 
   * minimum: 1
   * maximum: 65536
   * @return responseHeaderSize
  **/
  @Schema(description = "A response with header larger than response_header_size will be dropped. ")
  public Long getResponseHeaderSize() {
    return responseHeaderSize;
  }

  public void setResponseHeaderSize(Long responseHeaderSize) {
    this.responseHeaderSize = responseHeaderSize;
  }

  public LbHttpProfile ntlm(Boolean ntlm) {
    this.ntlm = ntlm;
    return this;
  }

   /**
   * NTLM is an authentication protocol that can be used over HTTP. If the flag is set to true, LB will use NTLM challenge/response methodology. 
   * @return ntlm
  **/
  @Schema(description = "NTLM is an authentication protocol that can be used over HTTP. If the flag is set to true, LB will use NTLM challenge/response methodology. ")
  public Boolean isNtlm() {
    return ntlm;
  }

  public void setNtlm(Boolean ntlm) {
    this.ntlm = ntlm;
  }

  public LbHttpProfile requestHeaderSize(Long requestHeaderSize) {
    this.requestHeaderSize = requestHeaderSize;
    return this;
  }

   /**
   * A request with header larger than request_header_size will be processed as best effort whereas a request with header below this specified size is guaranteed to be processed. 
   * minimum: 1
   * maximum: 65536
   * @return requestHeaderSize
  **/
  @Schema(description = "A request with header larger than request_header_size will be processed as best effort whereas a request with header below this specified size is guaranteed to be processed. ")
  public Long getRequestHeaderSize() {
    return requestHeaderSize;
  }

  public void setRequestHeaderSize(Long requestHeaderSize) {
    this.requestHeaderSize = requestHeaderSize;
  }

  public LbHttpProfile httpRedirectTo(String httpRedirectTo) {
    this.httpRedirectTo = httpRedirectTo;
    return this;
  }

   /**
   * If a website is temporarily down or has moved, incoming requests for that virtual server can be temporarily redirected to a URL 
   * @return httpRedirectTo
  **/
  @Schema(description = "If a website is temporarily down or has moved, incoming requests for that virtual server can be temporarily redirected to a URL ")
  public String getHttpRedirectTo() {
    return httpRedirectTo;
  }

  public void setHttpRedirectTo(String httpRedirectTo) {
    this.httpRedirectTo = httpRedirectTo;
  }

  public LbHttpProfile xForwardedFor(XForwardedForEnum xForwardedFor) {
    this.xForwardedFor = xForwardedFor;
    return this;
  }

   /**
   * insert or replace x_forwarded_for
   * @return xForwardedFor
  **/
  @Schema(description = "insert or replace x_forwarded_for")
  public XForwardedForEnum getXForwardedFor() {
    return xForwardedFor;
  }

  public void setXForwardedFor(XForwardedForEnum xForwardedFor) {
    this.xForwardedFor = xForwardedFor;
  }

  public LbHttpProfile httpRedirectToHttps(Boolean httpRedirectToHttps) {
    this.httpRedirectToHttps = httpRedirectToHttps;
    return this;
  }

   /**
   * Certain secure applications may want to force communication over SSL, but instead of rejecting non-SSL connections, they may choose to redirect the client automatically to use SSL. 
   * @return httpRedirectToHttps
  **/
  @Schema(description = "Certain secure applications may want to force communication over SSL, but instead of rejecting non-SSL connections, they may choose to redirect the client automatically to use SSL. ")
  public Boolean isHttpRedirectToHttps() {
    return httpRedirectToHttps;
  }

  public void setHttpRedirectToHttps(Boolean httpRedirectToHttps) {
    this.httpRedirectToHttps = httpRedirectToHttps;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LbHttpProfile lbHttpProfile = (LbHttpProfile) o;
    return Objects.equals(this.responseTimeout, lbHttpProfile.responseTimeout) &&
        Objects.equals(this.idleTimeout, lbHttpProfile.idleTimeout) &&
        Objects.equals(this.requestBodySize, lbHttpProfile.requestBodySize) &&
        Objects.equals(this.responseHeaderSize, lbHttpProfile.responseHeaderSize) &&
        Objects.equals(this.ntlm, lbHttpProfile.ntlm) &&
        Objects.equals(this.requestHeaderSize, lbHttpProfile.requestHeaderSize) &&
        Objects.equals(this.httpRedirectTo, lbHttpProfile.httpRedirectTo) &&
        Objects.equals(this.xForwardedFor, lbHttpProfile.xForwardedFor) &&
        Objects.equals(this.httpRedirectToHttps, lbHttpProfile.httpRedirectToHttps) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(responseTimeout, idleTimeout, requestBodySize, responseHeaderSize, ntlm, requestHeaderSize, httpRedirectTo, xForwardedFor, httpRedirectToHttps, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LbHttpProfile {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    responseTimeout: ").append(toIndentedString(responseTimeout)).append("\n");
    sb.append("    idleTimeout: ").append(toIndentedString(idleTimeout)).append("\n");
    sb.append("    requestBodySize: ").append(toIndentedString(requestBodySize)).append("\n");
    sb.append("    responseHeaderSize: ").append(toIndentedString(responseHeaderSize)).append("\n");
    sb.append("    ntlm: ").append(toIndentedString(ntlm)).append("\n");
    sb.append("    requestHeaderSize: ").append(toIndentedString(requestHeaderSize)).append("\n");
    sb.append("    httpRedirectTo: ").append(toIndentedString(httpRedirectTo)).append("\n");
    sb.append("    xForwardedFor: ").append(toIndentedString(xForwardedFor)).append("\n");
    sb.append("    httpRedirectToHttps: ").append(toIndentedString(httpRedirectToHttps)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
