/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.IpfixConfig;
import io.swagger.client.model.IpfixDfwTemplateParameters;
import io.swagger.client.model.ResourceReference;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.List;
/**
 * It defines IPFIX DFW Configuration.
 */
@Schema(description = "It defines IPFIX DFW Configuration.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class IpfixDfwConfig extends IpfixConfig {
  @SerializedName("priority")
  private Long priority = 0l;

  @SerializedName("collector")
  private String collector = null;

  @SerializedName("active_flow_export_timeout")
  private Long activeFlowExportTimeout = 1l;

  @SerializedName("template_parameters")
  private IpfixDfwTemplateParameters templateParameters = null;

  @SerializedName("observation_domain_id")
  private Long observationDomainId = null;

  public IpfixDfwConfig priority(Long priority) {
    this.priority = priority;
    return this;
  }

   /**
   * This priority field is used to resolve conflicts in Logical Ports which are covered by more than one IPFIX profiles. The IPFIX exporter will send records to Collectors in highest priority profile (lowest number) only. 
   * minimum: 0
   * maximum: 65536
   * @return priority
  **/
  @Schema(required = true, description = "This priority field is used to resolve conflicts in Logical Ports which are covered by more than one IPFIX profiles. The IPFIX exporter will send records to Collectors in highest priority profile (lowest number) only. ")
  public Long getPriority() {
    return priority;
  }

  public void setPriority(Long priority) {
    this.priority = priority;
  }

  public IpfixDfwConfig collector(String collector) {
    this.collector = collector;
    return this;
  }

   /**
   * Each IPFIX DFW config can have its own collector config. 
   * @return collector
  **/
  @Schema(required = true, description = "Each IPFIX DFW config can have its own collector config. ")
  public String getCollector() {
    return collector;
  }

  public void setCollector(String collector) {
    this.collector = collector;
  }

  public IpfixDfwConfig activeFlowExportTimeout(Long activeFlowExportTimeout) {
    this.activeFlowExportTimeout = activeFlowExportTimeout;
    return this;
  }

   /**
   * For long standing active flows, IPFIX records will be sent per timeout period 
   * minimum: 1
   * maximum: 60
   * @return activeFlowExportTimeout
  **/
  @Schema(description = "For long standing active flows, IPFIX records will be sent per timeout period ")
  public Long getActiveFlowExportTimeout() {
    return activeFlowExportTimeout;
  }

  public void setActiveFlowExportTimeout(Long activeFlowExportTimeout) {
    this.activeFlowExportTimeout = activeFlowExportTimeout;
  }

  public IpfixDfwConfig templateParameters(IpfixDfwTemplateParameters templateParameters) {
    this.templateParameters = templateParameters;
    return this;
  }

   /**
   * Get templateParameters
   * @return templateParameters
  **/
  @Schema(description = "")
  public IpfixDfwTemplateParameters getTemplateParameters() {
    return templateParameters;
  }

  public void setTemplateParameters(IpfixDfwTemplateParameters templateParameters) {
    this.templateParameters = templateParameters;
  }

  public IpfixDfwConfig observationDomainId(Long observationDomainId) {
    this.observationDomainId = observationDomainId;
    return this;
  }

   /**
   * An identifier that is unique to the exporting process and used to meter the Flows. 
   * minimum: 0
   * maximum: 4294967295
   * @return observationDomainId
  **/
  @Schema(required = true, description = "An identifier that is unique to the exporting process and used to meter the Flows. ")
  public Long getObservationDomainId() {
    return observationDomainId;
  }

  public void setObservationDomainId(Long observationDomainId) {
    this.observationDomainId = observationDomainId;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IpfixDfwConfig ipfixDfwConfig = (IpfixDfwConfig) o;
    return Objects.equals(this.priority, ipfixDfwConfig.priority) &&
        Objects.equals(this.collector, ipfixDfwConfig.collector) &&
        Objects.equals(this.activeFlowExportTimeout, ipfixDfwConfig.activeFlowExportTimeout) &&
        Objects.equals(this.templateParameters, ipfixDfwConfig.templateParameters) &&
        Objects.equals(this.observationDomainId, ipfixDfwConfig.observationDomainId) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(priority, collector, activeFlowExportTimeout, templateParameters, observationDomainId, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IpfixDfwConfig {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    priority: ").append(toIndentedString(priority)).append("\n");
    sb.append("    collector: ").append(toIndentedString(collector)).append("\n");
    sb.append("    activeFlowExportTimeout: ").append(toIndentedString(activeFlowExportTimeout)).append("\n");
    sb.append("    templateParameters: ").append(toIndentedString(templateParameters)).append("\n");
    sb.append("    observationDomainId: ").append(toIndentedString(observationDomainId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
