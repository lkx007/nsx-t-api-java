/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * To filter the routes advertised by the TIER1 LR to TIER0 LR. Filtering will be based on the type of route and the prefix operator configured.
 */
@Schema(description = "To filter the routes advertised by the TIER1 LR to TIER0 LR. Filtering will be based on the type of route and the prefix operator configured.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class AdvertisementRuleFilter {
  /**
   * GE prefix operator filters all the routes having network subset of any of the networks configured in Advertise rule. EQ prefix operator filter all the routes having network equal to any of the network configured in Advertise rule.
   */
  @JsonAdapter(PrefixOperatorEnum.Adapter.class)
  public enum PrefixOperatorEnum {
    GE("GE"),
    EQ("EQ");

    private String value;

    PrefixOperatorEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static PrefixOperatorEnum fromValue(String text) {
      for (PrefixOperatorEnum b : PrefixOperatorEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<PrefixOperatorEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PrefixOperatorEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PrefixOperatorEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return PrefixOperatorEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("prefix_operator")
  private PrefixOperatorEnum prefixOperator = PrefixOperatorEnum.GE;

  /**
   * Route types to filter the routes advertised by TIER1 LR. The ANY type filters all routes advertised by TIER1. The STATIC type is deprecated. Please refer to T1_STATIC. The T1_STATIC type filters STATIC routes advertised by TIER1. The NSX_CONNECTED type is deprecated. Please refer to T1_CONNECTED. The T1_CONNECTED type filters directly connected routes including downlink and CSP networks advertised by TIER1. The T1_NAT type filters routes for NAT rules advertised by TIER1. The T1_LB_VIP type filters LB VIP networks advertised by TIER1. The T1_LB_SNAT type filters routes corresponding to LB SNAT rules advertised by TIER1. The T1_DNSFORWARDER type filters routes for DNS FORWARDER advertised by TIER1. The T1_IPSEC_LOCAL_IP type filters IPSec VPN local endpoint ip addresses to be advertised.
   */
  @JsonAdapter(MatchRouteTypesEnum.Adapter.class)
  public enum MatchRouteTypesEnum {
    ANY("ANY"),
    STATIC("STATIC"),
    T1_STATIC("T1_STATIC"),
    NSX_CONNECTED("NSX_CONNECTED"),
    T1_CONNECTED("T1_CONNECTED"),
    T1_NAT("T1_NAT"),
    T1_LB_VIP("T1_LB_VIP"),
    T1_LB_SNAT("T1_LB_SNAT"),
    T1_DNSFORWARDER("T1_DNSFORWARDER"),
    T1_IPSEC_LOCAL_IP("T1_IPSEC_LOCAL_IP");

    private String value;

    MatchRouteTypesEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static MatchRouteTypesEnum fromValue(String text) {
      for (MatchRouteTypesEnum b : MatchRouteTypesEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<MatchRouteTypesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MatchRouteTypesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MatchRouteTypesEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return MatchRouteTypesEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("match_route_types")
  private List<MatchRouteTypesEnum> matchRouteTypes = new ArrayList<MatchRouteTypesEnum>();

  public AdvertisementRuleFilter prefixOperator(PrefixOperatorEnum prefixOperator) {
    this.prefixOperator = prefixOperator;
    return this;
  }

   /**
   * GE prefix operator filters all the routes having network subset of any of the networks configured in Advertise rule. EQ prefix operator filter all the routes having network equal to any of the network configured in Advertise rule.
   * @return prefixOperator
  **/
  @Schema(required = true, description = "GE prefix operator filters all the routes having network subset of any of the networks configured in Advertise rule. EQ prefix operator filter all the routes having network equal to any of the network configured in Advertise rule.")
  public PrefixOperatorEnum getPrefixOperator() {
    return prefixOperator;
  }

  public void setPrefixOperator(PrefixOperatorEnum prefixOperator) {
    this.prefixOperator = prefixOperator;
  }

  public AdvertisementRuleFilter matchRouteTypes(List<MatchRouteTypesEnum> matchRouteTypes) {
    this.matchRouteTypes = matchRouteTypes;
    return this;
  }

  public AdvertisementRuleFilter addMatchRouteTypesItem(MatchRouteTypesEnum matchRouteTypesItem) {
    this.matchRouteTypes.add(matchRouteTypesItem);
    return this;
  }

   /**
   * Array of route types to filter routes
   * @return matchRouteTypes
  **/
  @Schema(required = true, description = "Array of route types to filter routes")
  public List<MatchRouteTypesEnum> getMatchRouteTypes() {
    return matchRouteTypes;
  }

  public void setMatchRouteTypes(List<MatchRouteTypesEnum> matchRouteTypes) {
    this.matchRouteTypes = matchRouteTypes;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AdvertisementRuleFilter advertisementRuleFilter = (AdvertisementRuleFilter) o;
    return Objects.equals(this.prefixOperator, advertisementRuleFilter.prefixOperator) &&
        Objects.equals(this.matchRouteTypes, advertisementRuleFilter.matchRouteTypes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(prefixOperator, matchRouteTypes);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AdvertisementRuleFilter {\n");
    
    sb.append("    prefixOperator: ").append(toIndentedString(prefixOperator)).append("\n");
    sb.append("    matchRouteTypes: ").append(toIndentedString(matchRouteTypes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
