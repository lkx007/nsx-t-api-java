/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.ManagedResource;
import io.swagger.client.model.Tag;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.List;
/**
 * TCP profile allows customization of TCP stack behavior for each application. As TCP connections are terminated (or initiated) on the load balancer only for L7 virtual servers, TCP profiles are applicable only to them. As the desired TCP characteristics (e.g. Rx/Tx buffers) may be different for client (typically on WAN) and server (typically on LAN) sides, two separate profiles can be bound to virtual server, one for client-side (LbVirtualServer.client_tcp_profile_id) and another for server-side (LbVirtualServer.server_tcp_profile_id). 
 */
@Schema(description = "TCP profile allows customization of TCP stack behavior for each application. As TCP connections are terminated (or initiated) on the load balancer only for L7 virtual servers, TCP profiles are applicable only to them. As the desired TCP characteristics (e.g. Rx/Tx buffers) may be different for client (typically on WAN) and server (typically on LAN) sides, two separate profiles can be bound to virtual server, one for client-side (LbVirtualServer.client_tcp_profile_id) and another for server-side (LbVirtualServer.server_tcp_profile_id). ")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-02-19T07:44:41.574+08:00[Asia/Shanghai]")
public class LbTcpProfile extends ManagedResource {
  @SerializedName("nagle_algorithm_enabled")
  private Boolean nagleAlgorithmEnabled = true;

  @SerializedName("receive_window_size")
  private Long receiveWindowSize = null;

  @SerializedName("fin_wait2_timeout")
  private Long finWait2Timeout = null;

  @SerializedName("max_syn_retransmissions")
  private Long maxSynRetransmissions = null;

  @SerializedName("transmit_window_size")
  private Long transmitWindowSize = null;

  public LbTcpProfile nagleAlgorithmEnabled(Boolean nagleAlgorithmEnabled) {
    this.nagleAlgorithmEnabled = nagleAlgorithmEnabled;
    return this;
  }

   /**
   * Setting this option to enable or disable Nagle&#x27;s algorithm.
   * @return nagleAlgorithmEnabled
  **/
  @Schema(description = "Setting this option to enable or disable Nagle's algorithm.")
  public Boolean isNagleAlgorithmEnabled() {
    return nagleAlgorithmEnabled;
  }

  public void setNagleAlgorithmEnabled(Boolean nagleAlgorithmEnabled) {
    this.nagleAlgorithmEnabled = nagleAlgorithmEnabled;
  }

  public LbTcpProfile receiveWindowSize(Long receiveWindowSize) {
    this.receiveWindowSize = receiveWindowSize;
    return this;
  }

   /**
   * If the field is not specified, the load balancer will use the default setting per load balancer service flavor. 
   * minimum: 1024
   * maximum: 2147483647
   * @return receiveWindowSize
  **/
  @Schema(description = "If the field is not specified, the load balancer will use the default setting per load balancer service flavor. ")
  public Long getReceiveWindowSize() {
    return receiveWindowSize;
  }

  public void setReceiveWindowSize(Long receiveWindowSize) {
    this.receiveWindowSize = receiveWindowSize;
  }

  public LbTcpProfile finWait2Timeout(Long finWait2Timeout) {
    this.finWait2Timeout = finWait2Timeout;
    return this;
  }

   /**
   * If the field is not specified, the load balancer will use the default setting per load balancer service flavor. 
   * minimum: 0
   * maximum: 2147483647
   * @return finWait2Timeout
  **/
  @Schema(description = "If the field is not specified, the load balancer will use the default setting per load balancer service flavor. ")
  public Long getFinWait2Timeout() {
    return finWait2Timeout;
  }

  public void setFinWait2Timeout(Long finWait2Timeout) {
    this.finWait2Timeout = finWait2Timeout;
  }

  public LbTcpProfile maxSynRetransmissions(Long maxSynRetransmissions) {
    this.maxSynRetransmissions = maxSynRetransmissions;
    return this;
  }

   /**
   * If the field is not specified, the load balancer will use the default setting per load balancer service flavor. 
   * minimum: 1
   * maximum: 127
   * @return maxSynRetransmissions
  **/
  @Schema(description = "If the field is not specified, the load balancer will use the default setting per load balancer service flavor. ")
  public Long getMaxSynRetransmissions() {
    return maxSynRetransmissions;
  }

  public void setMaxSynRetransmissions(Long maxSynRetransmissions) {
    this.maxSynRetransmissions = maxSynRetransmissions;
  }

  public LbTcpProfile transmitWindowSize(Long transmitWindowSize) {
    this.transmitWindowSize = transmitWindowSize;
    return this;
  }

   /**
   * If the field is not specified, the load balancer will use the default setting per load balancer service flavor. 
   * minimum: 2048
   * maximum: 2147483647
   * @return transmitWindowSize
  **/
  @Schema(description = "If the field is not specified, the load balancer will use the default setting per load balancer service flavor. ")
  public Long getTransmitWindowSize() {
    return transmitWindowSize;
  }

  public void setTransmitWindowSize(Long transmitWindowSize) {
    this.transmitWindowSize = transmitWindowSize;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LbTcpProfile lbTcpProfile = (LbTcpProfile) o;
    return Objects.equals(this.nagleAlgorithmEnabled, lbTcpProfile.nagleAlgorithmEnabled) &&
        Objects.equals(this.receiveWindowSize, lbTcpProfile.receiveWindowSize) &&
        Objects.equals(this.finWait2Timeout, lbTcpProfile.finWait2Timeout) &&
        Objects.equals(this.maxSynRetransmissions, lbTcpProfile.maxSynRetransmissions) &&
        Objects.equals(this.transmitWindowSize, lbTcpProfile.transmitWindowSize) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(nagleAlgorithmEnabled, receiveWindowSize, finWait2Timeout, maxSynRetransmissions, transmitWindowSize, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LbTcpProfile {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    nagleAlgorithmEnabled: ").append(toIndentedString(nagleAlgorithmEnabled)).append("\n");
    sb.append("    receiveWindowSize: ").append(toIndentedString(receiveWindowSize)).append("\n");
    sb.append("    finWait2Timeout: ").append(toIndentedString(finWait2Timeout)).append("\n");
    sb.append("    maxSynRetransmissions: ").append(toIndentedString(maxSynRetransmissions)).append("\n");
    sb.append("    transmitWindowSize: ").append(toIndentedString(transmitWindowSize)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
