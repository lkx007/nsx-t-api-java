/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api;

import io.swagger.client.ApiCallback;
import io.swagger.client.ApiClient;
import io.swagger.client.ApiException;
import io.swagger.client.ApiResponse;
import io.swagger.client.Configuration;
import io.swagger.client.Pair;
import io.swagger.client.ProgressRequestBody;
import io.swagger.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.swagger.client.model.ApiError;
import io.swagger.client.model.LogicalPort;
import io.swagger.client.model.LogicalPortListResult;
import io.swagger.client.model.LogicalPortMacAddressCsvListResult;
import io.swagger.client.model.LogicalPortMacAddressListResult;
import io.swagger.client.model.LogicalPortOperationalStatus;
import io.swagger.client.model.LogicalPortState;
import io.swagger.client.model.LogicalPortStatistics;
import io.swagger.client.model.LogicalPortStatusSummary;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ManagementPlaneApiLogicalSwitchingLogicalSwitchPortsApi {
    private ApiClient apiClient;

    public ManagementPlaneApiLogicalSwitchingLogicalSwitchPortsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ManagementPlaneApiLogicalSwitchingLogicalSwitchPortsApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for createLogicalPort
     * @param body  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call createLogicalPortCall(LogicalPort body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/logical-ports";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call createLogicalPortValidateBeforeCall(LogicalPort body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling createLogicalPort(Async)");
        }
        
        com.squareup.okhttp.Call call = createLogicalPortCall(body, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Create a Logical Port
     * Creates a new logical switch port. The required parameters are the associated logical_switch_id and admin_state (UP or DOWN). Optional parameters are the attachment and switching_profile_ids. If you don&#x27;t specify switching_profile_ids, default switching profiles are assigned to the port. If you don&#x27;t specify an attachment, the switch port remains empty. To configure an attachment, you must specify an id, and optionally you can specify an attachment_type (VIF or LOGICALROUTER). The attachment_type is VIF by default. 
     * @param body  (required)
     * @return LogicalPort
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalPort createLogicalPort(LogicalPort body) throws ApiException {
        ApiResponse<LogicalPort> resp = createLogicalPortWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Create a Logical Port
     * Creates a new logical switch port. The required parameters are the associated logical_switch_id and admin_state (UP or DOWN). Optional parameters are the attachment and switching_profile_ids. If you don&#x27;t specify switching_profile_ids, default switching profiles are assigned to the port. If you don&#x27;t specify an attachment, the switch port remains empty. To configure an attachment, you must specify an id, and optionally you can specify an attachment_type (VIF or LOGICALROUTER). The attachment_type is VIF by default. 
     * @param body  (required)
     * @return ApiResponse&lt;LogicalPort&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalPort> createLogicalPortWithHttpInfo(LogicalPort body) throws ApiException {
        com.squareup.okhttp.Call call = createLogicalPortValidateBeforeCall(body, null, null);
        Type localVarReturnType = new TypeToken<LogicalPort>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Create a Logical Port (asynchronously)
     * Creates a new logical switch port. The required parameters are the associated logical_switch_id and admin_state (UP or DOWN). Optional parameters are the attachment and switching_profile_ids. If you don&#x27;t specify switching_profile_ids, default switching profiles are assigned to the port. If you don&#x27;t specify an attachment, the switch port remains empty. To configure an attachment, you must specify an id, and optionally you can specify an attachment_type (VIF or LOGICALROUTER). The attachment_type is VIF by default. 
     * @param body  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call createLogicalPortAsync(LogicalPort body, final ApiCallback<LogicalPort> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = createLogicalPortValidateBeforeCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalPort>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for deleteLogicalPort
     * @param lportId  (required)
     * @param detach force delete even if attached or referenced by a group (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call deleteLogicalPortCall(String lportId, Boolean detach, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-ports/{lport-id}"
            .replaceAll("\\{" + "lport-id" + "\\}", apiClient.escapeString(lportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (detach != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("detach", detach));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call deleteLogicalPortValidateBeforeCall(String lportId, Boolean detach, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'lportId' is set
        if (lportId == null) {
            throw new ApiException("Missing the required parameter 'lportId' when calling deleteLogicalPort(Async)");
        }
        
        com.squareup.okhttp.Call call = deleteLogicalPortCall(lportId, detach, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Delete a Logical Port
     * Deletes the specified logical switch port. By default, if logical port has attachments, or it is added to any NSGroup, the deletion will be failed. Option detach could be used for deleting logical port forcibly. 
     * @param lportId  (required)
     * @param detach force delete even if attached or referenced by a group (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void deleteLogicalPort(String lportId, Boolean detach) throws ApiException {
        deleteLogicalPortWithHttpInfo(lportId, detach);
    }

    /**
     * Delete a Logical Port
     * Deletes the specified logical switch port. By default, if logical port has attachments, or it is added to any NSGroup, the deletion will be failed. Option detach could be used for deleting logical port forcibly. 
     * @param lportId  (required)
     * @param detach force delete even if attached or referenced by a group (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> deleteLogicalPortWithHttpInfo(String lportId, Boolean detach) throws ApiException {
        com.squareup.okhttp.Call call = deleteLogicalPortValidateBeforeCall(lportId, detach, null, null);
        return apiClient.execute(call);
    }

    /**
     * Delete a Logical Port (asynchronously)
     * Deletes the specified logical switch port. By default, if logical port has attachments, or it is added to any NSGroup, the deletion will be failed. Option detach could be used for deleting logical port forcibly. 
     * @param lportId  (required)
     * @param detach force delete even if attached or referenced by a group (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call deleteLogicalPortAsync(String lportId, Boolean detach, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = deleteLogicalPortValidateBeforeCall(lportId, detach, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for getLogicalPort
     * @param lportId  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalPortCall(String lportId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-ports/{lport-id}"
            .replaceAll("\\{" + "lport-id" + "\\}", apiClient.escapeString(lportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalPortValidateBeforeCall(String lportId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'lportId' is set
        if (lportId == null) {
            throw new ApiException("Missing the required parameter 'lportId' when calling getLogicalPort(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalPortCall(lportId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get Information About a Logical Port
     * Returns information about a specified logical port.
     * @param lportId  (required)
     * @return LogicalPort
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalPort getLogicalPort(String lportId) throws ApiException {
        ApiResponse<LogicalPort> resp = getLogicalPortWithHttpInfo(lportId);
        return resp.getData();
    }

    /**
     * Get Information About a Logical Port
     * Returns information about a specified logical port.
     * @param lportId  (required)
     * @return ApiResponse&lt;LogicalPort&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalPort> getLogicalPortWithHttpInfo(String lportId) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalPortValidateBeforeCall(lportId, null, null);
        Type localVarReturnType = new TypeToken<LogicalPort>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Information About a Logical Port (asynchronously)
     * Returns information about a specified logical port.
     * @param lportId  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalPortAsync(String lportId, final ApiCallback<LogicalPort> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalPortValidateBeforeCall(lportId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalPort>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalPortMacTable
     * @param lportId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalPortMacTableCall(String lportId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-ports/{lport-id}/mac-table"
            .replaceAll("\\{" + "lport-id" + "\\}", apiClient.escapeString(lportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (cursor != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cursor", cursor));
        if (includedFields != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("included_fields", includedFields));
        if (pageSize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page_size", pageSize));
        if (sortAscending != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_ascending", sortAscending));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_by", sortBy));
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
        if (transportNodeId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_node_id", transportNodeId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalPortMacTableValidateBeforeCall(String lportId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'lportId' is set
        if (lportId == null) {
            throw new ApiException("Missing the required parameter 'lportId' when calling getLogicalPortMacTable(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalPortMacTableCall(lportId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get MAC table of a logical port with a given port id (lport-id)
     * Returns MAC table of a specified logical port. If the target transport node id is not provided, the NSX manager will ask the controller for the transport node where the logical port is located. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. MAC table retrieval is not supported on logical ports that are attached to a logical router. 
     * @param lportId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @return LogicalPortMacAddressListResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalPortMacAddressListResult getLogicalPortMacTable(String lportId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId) throws ApiException {
        ApiResponse<LogicalPortMacAddressListResult> resp = getLogicalPortMacTableWithHttpInfo(lportId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId);
        return resp.getData();
    }

    /**
     * Get MAC table of a logical port with a given port id (lport-id)
     * Returns MAC table of a specified logical port. If the target transport node id is not provided, the NSX manager will ask the controller for the transport node where the logical port is located. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. MAC table retrieval is not supported on logical ports that are attached to a logical router. 
     * @param lportId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @return ApiResponse&lt;LogicalPortMacAddressListResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalPortMacAddressListResult> getLogicalPortMacTableWithHttpInfo(String lportId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalPortMacTableValidateBeforeCall(lportId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId, null, null);
        Type localVarReturnType = new TypeToken<LogicalPortMacAddressListResult>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get MAC table of a logical port with a given port id (lport-id) (asynchronously)
     * Returns MAC table of a specified logical port. If the target transport node id is not provided, the NSX manager will ask the controller for the transport node where the logical port is located. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. MAC table retrieval is not supported on logical ports that are attached to a logical router. 
     * @param lportId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalPortMacTableAsync(String lportId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId, final ApiCallback<LogicalPortMacAddressListResult> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalPortMacTableValidateBeforeCall(lportId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalPortMacAddressListResult>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalPortMacTableInCsvFormatCsv
     * @param lportId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalPortMacTableInCsvFormatCsvCall(String lportId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-ports/{lport-id}/mac-table?format=csv"
            .replaceAll("\\{" + "lport-id" + "\\}", apiClient.escapeString(lportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (cursor != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cursor", cursor));
        if (includedFields != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("included_fields", includedFields));
        if (pageSize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page_size", pageSize));
        if (sortAscending != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_ascending", sortAscending));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_by", sortBy));
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
        if (transportNodeId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_node_id", transportNodeId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/csv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalPortMacTableInCsvFormatCsvValidateBeforeCall(String lportId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'lportId' is set
        if (lportId == null) {
            throw new ApiException("Missing the required parameter 'lportId' when calling getLogicalPortMacTableInCsvFormatCsv(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalPortMacTableInCsvFormatCsvCall(lportId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get MAC table of a logical port with a given port id (lport-id)
     * Returns MAC table in CSV format of a specified logical port. If the target transport node id is not provided, the NSX manager will ask the controller for the transport node where the logical port is located. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. MAC table retrieval is not supported on logical ports that are attached to a logical router. 
     * @param lportId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @return LogicalPortMacAddressCsvListResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalPortMacAddressCsvListResult getLogicalPortMacTableInCsvFormatCsv(String lportId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId) throws ApiException {
        ApiResponse<LogicalPortMacAddressCsvListResult> resp = getLogicalPortMacTableInCsvFormatCsvWithHttpInfo(lportId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId);
        return resp.getData();
    }

    /**
     * Get MAC table of a logical port with a given port id (lport-id)
     * Returns MAC table in CSV format of a specified logical port. If the target transport node id is not provided, the NSX manager will ask the controller for the transport node where the logical port is located. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. MAC table retrieval is not supported on logical ports that are attached to a logical router. 
     * @param lportId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @return ApiResponse&lt;LogicalPortMacAddressCsvListResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalPortMacAddressCsvListResult> getLogicalPortMacTableInCsvFormatCsvWithHttpInfo(String lportId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalPortMacTableInCsvFormatCsvValidateBeforeCall(lportId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId, null, null);
        Type localVarReturnType = new TypeToken<LogicalPortMacAddressCsvListResult>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get MAC table of a logical port with a given port id (lport-id) (asynchronously)
     * Returns MAC table in CSV format of a specified logical port. If the target transport node id is not provided, the NSX manager will ask the controller for the transport node where the logical port is located. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. MAC table retrieval is not supported on logical ports that are attached to a logical router. 
     * @param lportId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalPortMacTableInCsvFormatCsvAsync(String lportId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId, final ApiCallback<LogicalPortMacAddressCsvListResult> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalPortMacTableInCsvFormatCsvValidateBeforeCall(lportId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalPortMacAddressCsvListResult>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalPortOperationalStatus
     * @param lportId  (required)
     * @param source Data source type. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalPortOperationalStatusCall(String lportId, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-ports/{lport-id}/status"
            .replaceAll("\\{" + "lport-id" + "\\}", apiClient.escapeString(lportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalPortOperationalStatusValidateBeforeCall(String lportId, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'lportId' is set
        if (lportId == null) {
            throw new ApiException("Missing the required parameter 'lportId' when calling getLogicalPortOperationalStatus(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalPortOperationalStatusCall(lportId, source, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get Operational Status for Logical Port of a Given Port ID (lport-id)
     * Returns operational status of a specified logical port.
     * @param lportId  (required)
     * @param source Data source type. (optional)
     * @return LogicalPortOperationalStatus
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalPortOperationalStatus getLogicalPortOperationalStatus(String lportId, String source) throws ApiException {
        ApiResponse<LogicalPortOperationalStatus> resp = getLogicalPortOperationalStatusWithHttpInfo(lportId, source);
        return resp.getData();
    }

    /**
     * Get Operational Status for Logical Port of a Given Port ID (lport-id)
     * Returns operational status of a specified logical port.
     * @param lportId  (required)
     * @param source Data source type. (optional)
     * @return ApiResponse&lt;LogicalPortOperationalStatus&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalPortOperationalStatus> getLogicalPortOperationalStatusWithHttpInfo(String lportId, String source) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalPortOperationalStatusValidateBeforeCall(lportId, source, null, null);
        Type localVarReturnType = new TypeToken<LogicalPortOperationalStatus>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Operational Status for Logical Port of a Given Port ID (lport-id) (asynchronously)
     * Returns operational status of a specified logical port.
     * @param lportId  (required)
     * @param source Data source type. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalPortOperationalStatusAsync(String lportId, String source, final ApiCallback<LogicalPortOperationalStatus> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalPortOperationalStatusValidateBeforeCall(lportId, source, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalPortOperationalStatus>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalPortState
     * @param lportId  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalPortStateCall(String lportId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-ports/{lport-id}/state"
            .replaceAll("\\{" + "lport-id" + "\\}", apiClient.escapeString(lportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalPortStateValidateBeforeCall(String lportId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'lportId' is set
        if (lportId == null) {
            throw new ApiException("Missing the required parameter 'lportId' when calling getLogicalPortState(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalPortStateCall(lportId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get realized state &amp; location of a logical port
     * Returns transport node id for a specified logical port. Also returns information about all address bindings of the specified logical port. This includes address bindings discovered via various snooping methods like ARP snooping, DHCP snooping etc. and addressing bindings that are realized based on user configuration. 
     * @param lportId  (required)
     * @return LogicalPortState
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalPortState getLogicalPortState(String lportId) throws ApiException {
        ApiResponse<LogicalPortState> resp = getLogicalPortStateWithHttpInfo(lportId);
        return resp.getData();
    }

    /**
     * Get realized state &amp; location of a logical port
     * Returns transport node id for a specified logical port. Also returns information about all address bindings of the specified logical port. This includes address bindings discovered via various snooping methods like ARP snooping, DHCP snooping etc. and addressing bindings that are realized based on user configuration. 
     * @param lportId  (required)
     * @return ApiResponse&lt;LogicalPortState&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalPortState> getLogicalPortStateWithHttpInfo(String lportId) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalPortStateValidateBeforeCall(lportId, null, null);
        Type localVarReturnType = new TypeToken<LogicalPortState>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get realized state &amp; location of a logical port (asynchronously)
     * Returns transport node id for a specified logical port. Also returns information about all address bindings of the specified logical port. This includes address bindings discovered via various snooping methods like ARP snooping, DHCP snooping etc. and addressing bindings that are realized based on user configuration. 
     * @param lportId  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalPortStateAsync(String lportId, final ApiCallback<LogicalPortState> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalPortStateValidateBeforeCall(lportId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalPortState>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalPortStatistics
     * @param lportId  (required)
     * @param source Data source type. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalPortStatisticsCall(String lportId, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-ports/{lport-id}/statistics"
            .replaceAll("\\{" + "lport-id" + "\\}", apiClient.escapeString(lportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalPortStatisticsValidateBeforeCall(String lportId, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'lportId' is set
        if (lportId == null) {
            throw new ApiException("Missing the required parameter 'lportId' when calling getLogicalPortStatistics(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalPortStatisticsCall(lportId, source, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get Statistics for Logical Port of a Given Port ID (lport-id)
     * Returns statistics of a specified logical port. If the logical port is attached to a logical router port, query parameter \&quot;source&#x3D;realtime\&quot; is not supported. 
     * @param lportId  (required)
     * @param source Data source type. (optional)
     * @return LogicalPortStatistics
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalPortStatistics getLogicalPortStatistics(String lportId, String source) throws ApiException {
        ApiResponse<LogicalPortStatistics> resp = getLogicalPortStatisticsWithHttpInfo(lportId, source);
        return resp.getData();
    }

    /**
     * Get Statistics for Logical Port of a Given Port ID (lport-id)
     * Returns statistics of a specified logical port. If the logical port is attached to a logical router port, query parameter \&quot;source&#x3D;realtime\&quot; is not supported. 
     * @param lportId  (required)
     * @param source Data source type. (optional)
     * @return ApiResponse&lt;LogicalPortStatistics&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalPortStatistics> getLogicalPortStatisticsWithHttpInfo(String lportId, String source) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalPortStatisticsValidateBeforeCall(lportId, source, null, null);
        Type localVarReturnType = new TypeToken<LogicalPortStatistics>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Statistics for Logical Port of a Given Port ID (lport-id) (asynchronously)
     * Returns statistics of a specified logical port. If the logical port is attached to a logical router port, query parameter \&quot;source&#x3D;realtime\&quot; is not supported. 
     * @param lportId  (required)
     * @param source Data source type. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalPortStatisticsAsync(String lportId, String source, final ApiCallback<LogicalPortStatistics> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalPortStatisticsValidateBeforeCall(lportId, source, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalPortStatistics>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalPortStatusSummary
     * @param attachmentId Logical Port attachment Id (optional)
     * @param attachmentType Type of attachment for logical port; for query only. (optional)
     * @param bridgeClusterId Bridge Cluster identifier (optional)
     * @param containerPortsOnly Only container VIF logical ports will be returned if true (optional)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param diagnostic Flag to enable showing of transit logical port. (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param logicalSwitchId Logical Switch identifier (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param parentVifId ID of the VIF of type PARENT (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param switchingProfileId Network Profile identifier (optional)
     * @param transportNodeId Transport node identifier (optional)
     * @param transportZoneId Transport zone identifier (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalPortStatusSummaryCall(String attachmentId, String attachmentType, String bridgeClusterId, Boolean containerPortsOnly, String cursor, Boolean diagnostic, String includedFields, String logicalSwitchId, Long pageSize, String parentVifId, Boolean sortAscending, String sortBy, String source, String switchingProfileId, String transportNodeId, String transportZoneId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-ports/status";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (attachmentId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("attachment_id", attachmentId));
        if (attachmentType != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("attachment_type", attachmentType));
        if (bridgeClusterId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("bridge_cluster_id", bridgeClusterId));
        if (containerPortsOnly != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("container_ports_only", containerPortsOnly));
        if (cursor != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cursor", cursor));
        if (diagnostic != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("diagnostic", diagnostic));
        if (includedFields != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("included_fields", includedFields));
        if (logicalSwitchId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("logical_switch_id", logicalSwitchId));
        if (pageSize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page_size", pageSize));
        if (parentVifId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("parent_vif_id", parentVifId));
        if (sortAscending != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_ascending", sortAscending));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_by", sortBy));
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
        if (switchingProfileId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("switching_profile_id", switchingProfileId));
        if (transportNodeId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_node_id", transportNodeId));
        if (transportZoneId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_zone_id", transportZoneId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalPortStatusSummaryValidateBeforeCall(String attachmentId, String attachmentType, String bridgeClusterId, Boolean containerPortsOnly, String cursor, Boolean diagnostic, String includedFields, String logicalSwitchId, Long pageSize, String parentVifId, Boolean sortAscending, String sortBy, String source, String switchingProfileId, String transportNodeId, String transportZoneId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        com.squareup.okhttp.Call call = getLogicalPortStatusSummaryCall(attachmentId, attachmentType, bridgeClusterId, containerPortsOnly, cursor, diagnostic, includedFields, logicalSwitchId, pageSize, parentVifId, sortAscending, sortBy, source, switchingProfileId, transportNodeId, transportZoneId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get Operational Status Summary of All Logical Ports in the System
     * Returns operational status of all logical ports. The query parameter \&quot;source&#x3D;realtime\&quot; is not supported. 
     * @param attachmentId Logical Port attachment Id (optional)
     * @param attachmentType Type of attachment for logical port; for query only. (optional)
     * @param bridgeClusterId Bridge Cluster identifier (optional)
     * @param containerPortsOnly Only container VIF logical ports will be returned if true (optional)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param diagnostic Flag to enable showing of transit logical port. (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param logicalSwitchId Logical Switch identifier (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param parentVifId ID of the VIF of type PARENT (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param switchingProfileId Network Profile identifier (optional)
     * @param transportNodeId Transport node identifier (optional)
     * @param transportZoneId Transport zone identifier (optional)
     * @return LogicalPortStatusSummary
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalPortStatusSummary getLogicalPortStatusSummary(String attachmentId, String attachmentType, String bridgeClusterId, Boolean containerPortsOnly, String cursor, Boolean diagnostic, String includedFields, String logicalSwitchId, Long pageSize, String parentVifId, Boolean sortAscending, String sortBy, String source, String switchingProfileId, String transportNodeId, String transportZoneId) throws ApiException {
        ApiResponse<LogicalPortStatusSummary> resp = getLogicalPortStatusSummaryWithHttpInfo(attachmentId, attachmentType, bridgeClusterId, containerPortsOnly, cursor, diagnostic, includedFields, logicalSwitchId, pageSize, parentVifId, sortAscending, sortBy, source, switchingProfileId, transportNodeId, transportZoneId);
        return resp.getData();
    }

    /**
     * Get Operational Status Summary of All Logical Ports in the System
     * Returns operational status of all logical ports. The query parameter \&quot;source&#x3D;realtime\&quot; is not supported. 
     * @param attachmentId Logical Port attachment Id (optional)
     * @param attachmentType Type of attachment for logical port; for query only. (optional)
     * @param bridgeClusterId Bridge Cluster identifier (optional)
     * @param containerPortsOnly Only container VIF logical ports will be returned if true (optional)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param diagnostic Flag to enable showing of transit logical port. (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param logicalSwitchId Logical Switch identifier (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param parentVifId ID of the VIF of type PARENT (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param switchingProfileId Network Profile identifier (optional)
     * @param transportNodeId Transport node identifier (optional)
     * @param transportZoneId Transport zone identifier (optional)
     * @return ApiResponse&lt;LogicalPortStatusSummary&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalPortStatusSummary> getLogicalPortStatusSummaryWithHttpInfo(String attachmentId, String attachmentType, String bridgeClusterId, Boolean containerPortsOnly, String cursor, Boolean diagnostic, String includedFields, String logicalSwitchId, Long pageSize, String parentVifId, Boolean sortAscending, String sortBy, String source, String switchingProfileId, String transportNodeId, String transportZoneId) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalPortStatusSummaryValidateBeforeCall(attachmentId, attachmentType, bridgeClusterId, containerPortsOnly, cursor, diagnostic, includedFields, logicalSwitchId, pageSize, parentVifId, sortAscending, sortBy, source, switchingProfileId, transportNodeId, transportZoneId, null, null);
        Type localVarReturnType = new TypeToken<LogicalPortStatusSummary>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Operational Status Summary of All Logical Ports in the System (asynchronously)
     * Returns operational status of all logical ports. The query parameter \&quot;source&#x3D;realtime\&quot; is not supported. 
     * @param attachmentId Logical Port attachment Id (optional)
     * @param attachmentType Type of attachment for logical port; for query only. (optional)
     * @param bridgeClusterId Bridge Cluster identifier (optional)
     * @param containerPortsOnly Only container VIF logical ports will be returned if true (optional)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param diagnostic Flag to enable showing of transit logical port. (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param logicalSwitchId Logical Switch identifier (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param parentVifId ID of the VIF of type PARENT (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param switchingProfileId Network Profile identifier (optional)
     * @param transportNodeId Transport node identifier (optional)
     * @param transportZoneId Transport zone identifier (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalPortStatusSummaryAsync(String attachmentId, String attachmentType, String bridgeClusterId, Boolean containerPortsOnly, String cursor, Boolean diagnostic, String includedFields, String logicalSwitchId, Long pageSize, String parentVifId, Boolean sortAscending, String sortBy, String source, String switchingProfileId, String transportNodeId, String transportZoneId, final ApiCallback<LogicalPortStatusSummary> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalPortStatusSummaryValidateBeforeCall(attachmentId, attachmentType, bridgeClusterId, containerPortsOnly, cursor, diagnostic, includedFields, logicalSwitchId, pageSize, parentVifId, sortAscending, sortBy, source, switchingProfileId, transportNodeId, transportZoneId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalPortStatusSummary>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for listLogicalPorts
     * @param attachmentId Logical Port attachment Id (optional)
     * @param attachmentType Type of attachment for logical port; for query only. (optional)
     * @param bridgeClusterId Bridge Cluster identifier (optional)
     * @param containerPortsOnly Only container VIF logical ports will be returned if true (optional)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param diagnostic Flag to enable showing of transit logical port. (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param logicalSwitchId Logical Switch identifier (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param parentVifId ID of the VIF of type PARENT (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param switchingProfileId Network Profile identifier (optional)
     * @param transportNodeId Transport node identifier (optional)
     * @param transportZoneId Transport zone identifier (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call listLogicalPortsCall(String attachmentId, String attachmentType, String bridgeClusterId, Boolean containerPortsOnly, String cursor, Boolean diagnostic, String includedFields, String logicalSwitchId, Long pageSize, String parentVifId, Boolean sortAscending, String sortBy, String switchingProfileId, String transportNodeId, String transportZoneId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-ports";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (attachmentId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("attachment_id", attachmentId));
        if (attachmentType != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("attachment_type", attachmentType));
        if (bridgeClusterId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("bridge_cluster_id", bridgeClusterId));
        if (containerPortsOnly != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("container_ports_only", containerPortsOnly));
        if (cursor != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cursor", cursor));
        if (diagnostic != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("diagnostic", diagnostic));
        if (includedFields != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("included_fields", includedFields));
        if (logicalSwitchId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("logical_switch_id", logicalSwitchId));
        if (pageSize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page_size", pageSize));
        if (parentVifId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("parent_vif_id", parentVifId));
        if (sortAscending != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_ascending", sortAscending));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_by", sortBy));
        if (switchingProfileId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("switching_profile_id", switchingProfileId));
        if (transportNodeId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_node_id", transportNodeId));
        if (transportZoneId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_zone_id", transportZoneId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call listLogicalPortsValidateBeforeCall(String attachmentId, String attachmentType, String bridgeClusterId, Boolean containerPortsOnly, String cursor, Boolean diagnostic, String includedFields, String logicalSwitchId, Long pageSize, String parentVifId, Boolean sortAscending, String sortBy, String switchingProfileId, String transportNodeId, String transportZoneId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        com.squareup.okhttp.Call call = listLogicalPortsCall(attachmentId, attachmentType, bridgeClusterId, containerPortsOnly, cursor, diagnostic, includedFields, logicalSwitchId, pageSize, parentVifId, sortAscending, sortBy, switchingProfileId, transportNodeId, transportZoneId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * List All Logical Ports
     * Returns information about all configured logical switch ports. Logical switch ports connect to VM virtual network interface cards (NICs). Each logical port is associated with one logical switch. 
     * @param attachmentId Logical Port attachment Id (optional)
     * @param attachmentType Type of attachment for logical port; for query only. (optional)
     * @param bridgeClusterId Bridge Cluster identifier (optional)
     * @param containerPortsOnly Only container VIF logical ports will be returned if true (optional)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param diagnostic Flag to enable showing of transit logical port. (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param logicalSwitchId Logical Switch identifier (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param parentVifId ID of the VIF of type PARENT (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param switchingProfileId Network Profile identifier (optional)
     * @param transportNodeId Transport node identifier (optional)
     * @param transportZoneId Transport zone identifier (optional)
     * @return LogicalPortListResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalPortListResult listLogicalPorts(String attachmentId, String attachmentType, String bridgeClusterId, Boolean containerPortsOnly, String cursor, Boolean diagnostic, String includedFields, String logicalSwitchId, Long pageSize, String parentVifId, Boolean sortAscending, String sortBy, String switchingProfileId, String transportNodeId, String transportZoneId) throws ApiException {
        ApiResponse<LogicalPortListResult> resp = listLogicalPortsWithHttpInfo(attachmentId, attachmentType, bridgeClusterId, containerPortsOnly, cursor, diagnostic, includedFields, logicalSwitchId, pageSize, parentVifId, sortAscending, sortBy, switchingProfileId, transportNodeId, transportZoneId);
        return resp.getData();
    }

    /**
     * List All Logical Ports
     * Returns information about all configured logical switch ports. Logical switch ports connect to VM virtual network interface cards (NICs). Each logical port is associated with one logical switch. 
     * @param attachmentId Logical Port attachment Id (optional)
     * @param attachmentType Type of attachment for logical port; for query only. (optional)
     * @param bridgeClusterId Bridge Cluster identifier (optional)
     * @param containerPortsOnly Only container VIF logical ports will be returned if true (optional)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param diagnostic Flag to enable showing of transit logical port. (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param logicalSwitchId Logical Switch identifier (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param parentVifId ID of the VIF of type PARENT (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param switchingProfileId Network Profile identifier (optional)
     * @param transportNodeId Transport node identifier (optional)
     * @param transportZoneId Transport zone identifier (optional)
     * @return ApiResponse&lt;LogicalPortListResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalPortListResult> listLogicalPortsWithHttpInfo(String attachmentId, String attachmentType, String bridgeClusterId, Boolean containerPortsOnly, String cursor, Boolean diagnostic, String includedFields, String logicalSwitchId, Long pageSize, String parentVifId, Boolean sortAscending, String sortBy, String switchingProfileId, String transportNodeId, String transportZoneId) throws ApiException {
        com.squareup.okhttp.Call call = listLogicalPortsValidateBeforeCall(attachmentId, attachmentType, bridgeClusterId, containerPortsOnly, cursor, diagnostic, includedFields, logicalSwitchId, pageSize, parentVifId, sortAscending, sortBy, switchingProfileId, transportNodeId, transportZoneId, null, null);
        Type localVarReturnType = new TypeToken<LogicalPortListResult>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * List All Logical Ports (asynchronously)
     * Returns information about all configured logical switch ports. Logical switch ports connect to VM virtual network interface cards (NICs). Each logical port is associated with one logical switch. 
     * @param attachmentId Logical Port attachment Id (optional)
     * @param attachmentType Type of attachment for logical port; for query only. (optional)
     * @param bridgeClusterId Bridge Cluster identifier (optional)
     * @param containerPortsOnly Only container VIF logical ports will be returned if true (optional)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param diagnostic Flag to enable showing of transit logical port. (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param logicalSwitchId Logical Switch identifier (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param parentVifId ID of the VIF of type PARENT (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param switchingProfileId Network Profile identifier (optional)
     * @param transportNodeId Transport node identifier (optional)
     * @param transportZoneId Transport zone identifier (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call listLogicalPortsAsync(String attachmentId, String attachmentType, String bridgeClusterId, Boolean containerPortsOnly, String cursor, Boolean diagnostic, String includedFields, String logicalSwitchId, Long pageSize, String parentVifId, Boolean sortAscending, String sortBy, String switchingProfileId, String transportNodeId, String transportZoneId, final ApiCallback<LogicalPortListResult> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = listLogicalPortsValidateBeforeCall(attachmentId, attachmentType, bridgeClusterId, containerPortsOnly, cursor, diagnostic, includedFields, logicalSwitchId, pageSize, parentVifId, sortAscending, sortBy, switchingProfileId, transportNodeId, transportZoneId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalPortListResult>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for updateLogicalPort
     * @param body  (required)
     * @param lportId  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call updateLogicalPortCall(LogicalPort body, String lportId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/logical-ports/{lport-id}"
            .replaceAll("\\{" + "lport-id" + "\\}", apiClient.escapeString(lportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call updateLogicalPortValidateBeforeCall(LogicalPort body, String lportId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling updateLogicalPort(Async)");
        }
        // verify the required parameter 'lportId' is set
        if (lportId == null) {
            throw new ApiException("Missing the required parameter 'lportId' when calling updateLogicalPort(Async)");
        }
        
        com.squareup.okhttp.Call call = updateLogicalPortCall(body, lportId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Update a Logical Port
     * Modifies an existing logical switch port. Parameters that can be modified include attachment_type (LOGICALROUTER, VIF), admin_state (UP or DOWN), attachment id and switching_profile_ids. You cannot modify the logical_switch_id. In other words, you cannot move an existing port from one switch to another switch. 
     * @param body  (required)
     * @param lportId  (required)
     * @return LogicalPort
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalPort updateLogicalPort(LogicalPort body, String lportId) throws ApiException {
        ApiResponse<LogicalPort> resp = updateLogicalPortWithHttpInfo(body, lportId);
        return resp.getData();
    }

    /**
     * Update a Logical Port
     * Modifies an existing logical switch port. Parameters that can be modified include attachment_type (LOGICALROUTER, VIF), admin_state (UP or DOWN), attachment id and switching_profile_ids. You cannot modify the logical_switch_id. In other words, you cannot move an existing port from one switch to another switch. 
     * @param body  (required)
     * @param lportId  (required)
     * @return ApiResponse&lt;LogicalPort&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalPort> updateLogicalPortWithHttpInfo(LogicalPort body, String lportId) throws ApiException {
        com.squareup.okhttp.Call call = updateLogicalPortValidateBeforeCall(body, lportId, null, null);
        Type localVarReturnType = new TypeToken<LogicalPort>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update a Logical Port (asynchronously)
     * Modifies an existing logical switch port. Parameters that can be modified include attachment_type (LOGICALROUTER, VIF), admin_state (UP or DOWN), attachment id and switching_profile_ids. You cannot modify the logical_switch_id. In other words, you cannot move an existing port from one switch to another switch. 
     * @param body  (required)
     * @param lportId  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call updateLogicalPortAsync(LogicalPort body, String lportId, final ApiCallback<LogicalPort> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = updateLogicalPortValidateBeforeCall(body, lportId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalPort>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
