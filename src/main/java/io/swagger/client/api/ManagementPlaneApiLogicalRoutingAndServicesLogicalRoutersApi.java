/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api;

import io.swagger.client.ApiCallback;
import io.swagger.client.ApiClient;
import io.swagger.client.ApiException;
import io.swagger.client.ApiResponse;
import io.swagger.client.Configuration;
import io.swagger.client.Pair;
import io.swagger.client.ProgressRequestBody;
import io.swagger.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.swagger.client.model.ApiError;
import io.swagger.client.model.BgpNeighborRouteDetails;
import io.swagger.client.model.BgpNeighborRouteDetailsInCsvFormat;
import io.swagger.client.model.BgpNeighborsStatusListResult;
import io.swagger.client.model.LogicalRouter;
import io.swagger.client.model.LogicalRouterListResult;
import io.swagger.client.model.LogicalRouterRouteTable;
import io.swagger.client.model.LogicalRouterRouteTableInCsvFormat;
import io.swagger.client.model.LogicalRouterState;
import io.swagger.client.model.LogicalRouterStatus;
import io.swagger.client.model.LogicalServiceRouterClusterState;
import io.swagger.client.model.ServiceRouterAllocationConfig;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ManagementPlaneApiLogicalRoutingAndServicesLogicalRoutersApi {
    private ApiClient apiClient;

    public ManagementPlaneApiLogicalRoutingAndServicesLogicalRoutersApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ManagementPlaneApiLogicalRoutingAndServicesLogicalRoutersApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for createLogicalRouter
     * @param body  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call createLogicalRouterCall(LogicalRouter body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/logical-routers";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call createLogicalRouterValidateBeforeCall(LogicalRouter body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling createLogicalRouter(Async)");
        }
        
        com.squareup.okhttp.Call call = createLogicalRouterCall(body, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Create a Logical Router
     * Creates a logical router. The required parameters are router_type (TIER0 or TIER1) and edge_cluster_id (TIER0 only). Optional parameters include internal and external transit network addresses. 
     * @param body  (required)
     * @return LogicalRouter
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalRouter createLogicalRouter(LogicalRouter body) throws ApiException {
        ApiResponse<LogicalRouter> resp = createLogicalRouterWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Create a Logical Router
     * Creates a logical router. The required parameters are router_type (TIER0 or TIER1) and edge_cluster_id (TIER0 only). Optional parameters include internal and external transit network addresses. 
     * @param body  (required)
     * @return ApiResponse&lt;LogicalRouter&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalRouter> createLogicalRouterWithHttpInfo(LogicalRouter body) throws ApiException {
        com.squareup.okhttp.Call call = createLogicalRouterValidateBeforeCall(body, null, null);
        Type localVarReturnType = new TypeToken<LogicalRouter>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Create a Logical Router (asynchronously)
     * Creates a logical router. The required parameters are router_type (TIER0 or TIER1) and edge_cluster_id (TIER0 only). Optional parameters include internal and external transit network addresses. 
     * @param body  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call createLogicalRouterAsync(LogicalRouter body, final ApiCallback<LogicalRouter> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = createLogicalRouterValidateBeforeCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalRouter>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for deleteLogicalRouter
     * @param logicalRouterId  (required)
     * @param cascadeDeleteLinkedPorts Flag to specify whether to delete related logical switch ports (optional)
     * @param force Force delete the resource even if it is being used somewhere  (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call deleteLogicalRouterCall(String logicalRouterId, Boolean cascadeDeleteLinkedPorts, Boolean force, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (cascadeDeleteLinkedPorts != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cascade_delete_linked_ports", cascadeDeleteLinkedPorts));
        if (force != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("force", force));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call deleteLogicalRouterValidateBeforeCall(String logicalRouterId, Boolean cascadeDeleteLinkedPorts, Boolean force, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling deleteLogicalRouter(Async)");
        }
        
        com.squareup.okhttp.Call call = deleteLogicalRouterCall(logicalRouterId, cascadeDeleteLinkedPorts, force, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Delete a Logical Router
     * Deletes the specified logical router. You must delete associated logical router ports before you can delete a logical router. Otherwise use force delete which will delete all related ports and other entities associated with that LR. To force delete logical router pass force&#x3D;true in query param. 
     * @param logicalRouterId  (required)
     * @param cascadeDeleteLinkedPorts Flag to specify whether to delete related logical switch ports (optional)
     * @param force Force delete the resource even if it is being used somewhere  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void deleteLogicalRouter(String logicalRouterId, Boolean cascadeDeleteLinkedPorts, Boolean force) throws ApiException {
        deleteLogicalRouterWithHttpInfo(logicalRouterId, cascadeDeleteLinkedPorts, force);
    }

    /**
     * Delete a Logical Router
     * Deletes the specified logical router. You must delete associated logical router ports before you can delete a logical router. Otherwise use force delete which will delete all related ports and other entities associated with that LR. To force delete logical router pass force&#x3D;true in query param. 
     * @param logicalRouterId  (required)
     * @param cascadeDeleteLinkedPorts Flag to specify whether to delete related logical switch ports (optional)
     * @param force Force delete the resource even if it is being used somewhere  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> deleteLogicalRouterWithHttpInfo(String logicalRouterId, Boolean cascadeDeleteLinkedPorts, Boolean force) throws ApiException {
        com.squareup.okhttp.Call call = deleteLogicalRouterValidateBeforeCall(logicalRouterId, cascadeDeleteLinkedPorts, force, null, null);
        return apiClient.execute(call);
    }

    /**
     * Delete a Logical Router (asynchronously)
     * Deletes the specified logical router. You must delete associated logical router ports before you can delete a logical router. Otherwise use force delete which will delete all related ports and other entities associated with that LR. To force delete logical router pass force&#x3D;true in query param. 
     * @param logicalRouterId  (required)
     * @param cascadeDeleteLinkedPorts Flag to specify whether to delete related logical switch ports (optional)
     * @param force Force delete the resource even if it is being used somewhere  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call deleteLogicalRouterAsync(String logicalRouterId, Boolean cascadeDeleteLinkedPorts, Boolean force, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = deleteLogicalRouterValidateBeforeCall(logicalRouterId, cascadeDeleteLinkedPorts, force, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for getBgpNeighborAdvertisedRoutes
     * @param logicalRouterId  (required)
     * @param neighborId  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getBgpNeighborAdvertisedRoutesCall(String logicalRouterId, String neighborId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}/routing/bgp/neighbors/{neighbor-id}/advertised-routes"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()))
            .replaceAll("\\{" + "neighbor-id" + "\\}", apiClient.escapeString(neighborId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getBgpNeighborAdvertisedRoutesValidateBeforeCall(String logicalRouterId, String neighborId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling getBgpNeighborAdvertisedRoutes(Async)");
        }
        // verify the required parameter 'neighborId' is set
        if (neighborId == null) {
            throw new ApiException("Missing the required parameter 'neighborId' when calling getBgpNeighborAdvertisedRoutes(Async)");
        }
        
        com.squareup.okhttp.Call call = getBgpNeighborAdvertisedRoutesCall(logicalRouterId, neighborId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get BGP neighbor advertised routes
     * Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled. It always returns realtime response. 
     * @param logicalRouterId  (required)
     * @param neighborId  (required)
     * @return BgpNeighborRouteDetails
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public BgpNeighborRouteDetails getBgpNeighborAdvertisedRoutes(String logicalRouterId, String neighborId) throws ApiException {
        ApiResponse<BgpNeighborRouteDetails> resp = getBgpNeighborAdvertisedRoutesWithHttpInfo(logicalRouterId, neighborId);
        return resp.getData();
    }

    /**
     * Get BGP neighbor advertised routes
     * Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled. It always returns realtime response. 
     * @param logicalRouterId  (required)
     * @param neighborId  (required)
     * @return ApiResponse&lt;BgpNeighborRouteDetails&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<BgpNeighborRouteDetails> getBgpNeighborAdvertisedRoutesWithHttpInfo(String logicalRouterId, String neighborId) throws ApiException {
        com.squareup.okhttp.Call call = getBgpNeighborAdvertisedRoutesValidateBeforeCall(logicalRouterId, neighborId, null, null);
        Type localVarReturnType = new TypeToken<BgpNeighborRouteDetails>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get BGP neighbor advertised routes (asynchronously)
     * Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled. It always returns realtime response. 
     * @param logicalRouterId  (required)
     * @param neighborId  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getBgpNeighborAdvertisedRoutesAsync(String logicalRouterId, String neighborId, final ApiCallback<BgpNeighborRouteDetails> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getBgpNeighborAdvertisedRoutesValidateBeforeCall(logicalRouterId, neighborId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<BgpNeighborRouteDetails>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getBgpNeighborAdvertisedRoutesInCsvFormatCsv
     * @param logicalRouterId  (required)
     * @param neighborId  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getBgpNeighborAdvertisedRoutesInCsvFormatCsvCall(String logicalRouterId, String neighborId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}/routing/bgp/neighbors/{neighbor-id}/advertised-routes?format=csv"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()))
            .replaceAll("\\{" + "neighbor-id" + "\\}", apiClient.escapeString(neighborId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/csv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getBgpNeighborAdvertisedRoutesInCsvFormatCsvValidateBeforeCall(String logicalRouterId, String neighborId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling getBgpNeighborAdvertisedRoutesInCsvFormatCsv(Async)");
        }
        // verify the required parameter 'neighborId' is set
        if (neighborId == null) {
            throw new ApiException("Missing the required parameter 'neighborId' when calling getBgpNeighborAdvertisedRoutesInCsvFormatCsv(Async)");
        }
        
        com.squareup.okhttp.Call call = getBgpNeighborAdvertisedRoutesInCsvFormatCsvCall(logicalRouterId, neighborId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get BGP neighbor advertised routes in CSV format 
     * Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled in CSV format. It always returns realtime response. 
     * @param logicalRouterId  (required)
     * @param neighborId  (required)
     * @return BgpNeighborRouteDetailsInCsvFormat
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public BgpNeighborRouteDetailsInCsvFormat getBgpNeighborAdvertisedRoutesInCsvFormatCsv(String logicalRouterId, String neighborId) throws ApiException {
        ApiResponse<BgpNeighborRouteDetailsInCsvFormat> resp = getBgpNeighborAdvertisedRoutesInCsvFormatCsvWithHttpInfo(logicalRouterId, neighborId);
        return resp.getData();
    }

    /**
     * Get BGP neighbor advertised routes in CSV format 
     * Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled in CSV format. It always returns realtime response. 
     * @param logicalRouterId  (required)
     * @param neighborId  (required)
     * @return ApiResponse&lt;BgpNeighborRouteDetailsInCsvFormat&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<BgpNeighborRouteDetailsInCsvFormat> getBgpNeighborAdvertisedRoutesInCsvFormatCsvWithHttpInfo(String logicalRouterId, String neighborId) throws ApiException {
        com.squareup.okhttp.Call call = getBgpNeighborAdvertisedRoutesInCsvFormatCsvValidateBeforeCall(logicalRouterId, neighborId, null, null);
        Type localVarReturnType = new TypeToken<BgpNeighborRouteDetailsInCsvFormat>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get BGP neighbor advertised routes in CSV format  (asynchronously)
     * Returns routes advertised by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled in CSV format. It always returns realtime response. 
     * @param logicalRouterId  (required)
     * @param neighborId  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getBgpNeighborAdvertisedRoutesInCsvFormatCsvAsync(String logicalRouterId, String neighborId, final ApiCallback<BgpNeighborRouteDetailsInCsvFormat> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getBgpNeighborAdvertisedRoutesInCsvFormatCsvValidateBeforeCall(logicalRouterId, neighborId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<BgpNeighborRouteDetailsInCsvFormat>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getBgpNeighborRoutes
     * @param logicalRouterId  (required)
     * @param neighborId  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getBgpNeighborRoutesCall(String logicalRouterId, String neighborId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}/routing/bgp/neighbors/{neighbor-id}/routes"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()))
            .replaceAll("\\{" + "neighbor-id" + "\\}", apiClient.escapeString(neighborId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getBgpNeighborRoutesValidateBeforeCall(String logicalRouterId, String neighborId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling getBgpNeighborRoutes(Async)");
        }
        // verify the required parameter 'neighborId' is set
        if (neighborId == null) {
            throw new ApiException("Missing the required parameter 'neighborId' when calling getBgpNeighborRoutes(Async)");
        }
        
        com.squareup.okhttp.Call call = getBgpNeighborRoutesCall(logicalRouterId, neighborId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get BGP neighbor learned routes
     * Returns routes learned by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled. It always returns realtime response. 
     * @param logicalRouterId  (required)
     * @param neighborId  (required)
     * @return BgpNeighborRouteDetails
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public BgpNeighborRouteDetails getBgpNeighborRoutes(String logicalRouterId, String neighborId) throws ApiException {
        ApiResponse<BgpNeighborRouteDetails> resp = getBgpNeighborRoutesWithHttpInfo(logicalRouterId, neighborId);
        return resp.getData();
    }

    /**
     * Get BGP neighbor learned routes
     * Returns routes learned by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled. It always returns realtime response. 
     * @param logicalRouterId  (required)
     * @param neighborId  (required)
     * @return ApiResponse&lt;BgpNeighborRouteDetails&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<BgpNeighborRouteDetails> getBgpNeighborRoutesWithHttpInfo(String logicalRouterId, String neighborId) throws ApiException {
        com.squareup.okhttp.Call call = getBgpNeighborRoutesValidateBeforeCall(logicalRouterId, neighborId, null, null);
        Type localVarReturnType = new TypeToken<BgpNeighborRouteDetails>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get BGP neighbor learned routes (asynchronously)
     * Returns routes learned by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled. It always returns realtime response. 
     * @param logicalRouterId  (required)
     * @param neighborId  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getBgpNeighborRoutesAsync(String logicalRouterId, String neighborId, final ApiCallback<BgpNeighborRouteDetails> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getBgpNeighborRoutesValidateBeforeCall(logicalRouterId, neighborId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<BgpNeighborRouteDetails>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getBgpNeighborRoutesInCsvFormatCsv
     * @param logicalRouterId  (required)
     * @param neighborId  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getBgpNeighborRoutesInCsvFormatCsvCall(String logicalRouterId, String neighborId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}/routing/bgp/neighbors/{neighbor-id}/routes?format=csv"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()))
            .replaceAll("\\{" + "neighbor-id" + "\\}", apiClient.escapeString(neighborId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/csv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getBgpNeighborRoutesInCsvFormatCsvValidateBeforeCall(String logicalRouterId, String neighborId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling getBgpNeighborRoutesInCsvFormatCsv(Async)");
        }
        // verify the required parameter 'neighborId' is set
        if (neighborId == null) {
            throw new ApiException("Missing the required parameter 'neighborId' when calling getBgpNeighborRoutesInCsvFormatCsv(Async)");
        }
        
        com.squareup.okhttp.Call call = getBgpNeighborRoutesInCsvFormatCsvCall(logicalRouterId, neighborId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get BGP neighbor learned routes in CSV format 
     * Returns routes learned by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled in CSV format. It always returns realtime response. 
     * @param logicalRouterId  (required)
     * @param neighborId  (required)
     * @return BgpNeighborRouteDetailsInCsvFormat
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public BgpNeighborRouteDetailsInCsvFormat getBgpNeighborRoutesInCsvFormatCsv(String logicalRouterId, String neighborId) throws ApiException {
        ApiResponse<BgpNeighborRouteDetailsInCsvFormat> resp = getBgpNeighborRoutesInCsvFormatCsvWithHttpInfo(logicalRouterId, neighborId);
        return resp.getData();
    }

    /**
     * Get BGP neighbor learned routes in CSV format 
     * Returns routes learned by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled in CSV format. It always returns realtime response. 
     * @param logicalRouterId  (required)
     * @param neighborId  (required)
     * @return ApiResponse&lt;BgpNeighborRouteDetailsInCsvFormat&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<BgpNeighborRouteDetailsInCsvFormat> getBgpNeighborRoutesInCsvFormatCsvWithHttpInfo(String logicalRouterId, String neighborId) throws ApiException {
        com.squareup.okhttp.Call call = getBgpNeighborRoutesInCsvFormatCsvValidateBeforeCall(logicalRouterId, neighborId, null, null);
        Type localVarReturnType = new TypeToken<BgpNeighborRouteDetailsInCsvFormat>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get BGP neighbor learned routes in CSV format  (asynchronously)
     * Returns routes learned by BGP neighbor from all edge transport nodes on which this neighbor is currently enabled in CSV format. It always returns realtime response. 
     * @param logicalRouterId  (required)
     * @param neighborId  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getBgpNeighborRoutesInCsvFormatCsvAsync(String logicalRouterId, String neighborId, final ApiCallback<BgpNeighborRouteDetailsInCsvFormat> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getBgpNeighborRoutesInCsvFormatCsvValidateBeforeCall(logicalRouterId, neighborId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<BgpNeighborRouteDetailsInCsvFormat>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getBgpNeighborsStatus
     * @param logicalRouterId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId Transport node id (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getBgpNeighborsStatusCall(String logicalRouterId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}/routing/bgp/neighbors/status"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (cursor != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cursor", cursor));
        if (includedFields != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("included_fields", includedFields));
        if (pageSize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page_size", pageSize));
        if (sortAscending != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_ascending", sortAscending));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_by", sortBy));
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
        if (transportNodeId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_node_id", transportNodeId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getBgpNeighborsStatusValidateBeforeCall(String logicalRouterId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling getBgpNeighborsStatus(Async)");
        }
        
        com.squareup.okhttp.Call call = getBgpNeighborsStatusCall(logicalRouterId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get the status of all the BGP neighbors for the Logical Router of the given id
     * Returns the status of all the BGP neighbors for the Logical Router of the given id. To get BGP neighbors status for the logical router from particular node, parameter \&quot;transport_node_id&#x3D;&lt;transportnode_id&gt;\&quot; needs to be specified. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source.
     * @param logicalRouterId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId Transport node id (optional)
     * @return BgpNeighborsStatusListResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public BgpNeighborsStatusListResult getBgpNeighborsStatus(String logicalRouterId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId) throws ApiException {
        ApiResponse<BgpNeighborsStatusListResult> resp = getBgpNeighborsStatusWithHttpInfo(logicalRouterId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId);
        return resp.getData();
    }

    /**
     * Get the status of all the BGP neighbors for the Logical Router of the given id
     * Returns the status of all the BGP neighbors for the Logical Router of the given id. To get BGP neighbors status for the logical router from particular node, parameter \&quot;transport_node_id&#x3D;&lt;transportnode_id&gt;\&quot; needs to be specified. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source.
     * @param logicalRouterId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId Transport node id (optional)
     * @return ApiResponse&lt;BgpNeighborsStatusListResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<BgpNeighborsStatusListResult> getBgpNeighborsStatusWithHttpInfo(String logicalRouterId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId) throws ApiException {
        com.squareup.okhttp.Call call = getBgpNeighborsStatusValidateBeforeCall(logicalRouterId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId, null, null);
        Type localVarReturnType = new TypeToken<BgpNeighborsStatusListResult>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get the status of all the BGP neighbors for the Logical Router of the given id (asynchronously)
     * Returns the status of all the BGP neighbors for the Logical Router of the given id. To get BGP neighbors status for the logical router from particular node, parameter \&quot;transport_node_id&#x3D;&lt;transportnode_id&gt;\&quot; needs to be specified. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source.
     * @param logicalRouterId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId Transport node id (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getBgpNeighborsStatusAsync(String logicalRouterId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId, final ApiCallback<BgpNeighborsStatusListResult> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getBgpNeighborsStatusValidateBeforeCall(logicalRouterId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<BgpNeighborsStatusListResult>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalRouterForwardingTable
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param networkPrefix IPv4 or IPv6 CIDR Block (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalRouterForwardingTableCall(String logicalRouterId, String transportNodeId, String cursor, String includedFields, String networkPrefix, Long pageSize, Boolean sortAscending, String sortBy, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}/routing/forwarding-table"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (cursor != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cursor", cursor));
        if (includedFields != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("included_fields", includedFields));
        if (networkPrefix != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("network_prefix", networkPrefix));
        if (pageSize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page_size", pageSize));
        if (sortAscending != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_ascending", sortAscending));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_by", sortBy));
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
        if (transportNodeId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_node_id", transportNodeId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalRouterForwardingTableValidateBeforeCall(String logicalRouterId, String transportNodeId, String cursor, String includedFields, String networkPrefix, Long pageSize, Boolean sortAscending, String sortBy, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling getLogicalRouterForwardingTable(Async)");
        }
        // verify the required parameter 'transportNodeId' is set
        if (transportNodeId == null) {
            throw new ApiException("Missing the required parameter 'transportNodeId' when calling getLogicalRouterForwardingTable(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalRouterForwardingTableCall(logicalRouterId, transportNodeId, cursor, includedFields, networkPrefix, pageSize, sortAscending, sortBy, source, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get FIB table on a specified node for a logical router
     * Returns the FIB for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. To filter the result by network address, paramter \&quot;network_prefix&#x3D;&lt;a.b.c.d/mask&gt;\&quot; needs to be specified. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param networkPrefix IPv4 or IPv6 CIDR Block (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @return LogicalRouterRouteTable
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalRouterRouteTable getLogicalRouterForwardingTable(String logicalRouterId, String transportNodeId, String cursor, String includedFields, String networkPrefix, Long pageSize, Boolean sortAscending, String sortBy, String source) throws ApiException {
        ApiResponse<LogicalRouterRouteTable> resp = getLogicalRouterForwardingTableWithHttpInfo(logicalRouterId, transportNodeId, cursor, includedFields, networkPrefix, pageSize, sortAscending, sortBy, source);
        return resp.getData();
    }

    /**
     * Get FIB table on a specified node for a logical router
     * Returns the FIB for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. To filter the result by network address, paramter \&quot;network_prefix&#x3D;&lt;a.b.c.d/mask&gt;\&quot; needs to be specified. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param networkPrefix IPv4 or IPv6 CIDR Block (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @return ApiResponse&lt;LogicalRouterRouteTable&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalRouterRouteTable> getLogicalRouterForwardingTableWithHttpInfo(String logicalRouterId, String transportNodeId, String cursor, String includedFields, String networkPrefix, Long pageSize, Boolean sortAscending, String sortBy, String source) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalRouterForwardingTableValidateBeforeCall(logicalRouterId, transportNodeId, cursor, includedFields, networkPrefix, pageSize, sortAscending, sortBy, source, null, null);
        Type localVarReturnType = new TypeToken<LogicalRouterRouteTable>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get FIB table on a specified node for a logical router (asynchronously)
     * Returns the FIB for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. To filter the result by network address, paramter \&quot;network_prefix&#x3D;&lt;a.b.c.d/mask&gt;\&quot; needs to be specified. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param networkPrefix IPv4 or IPv6 CIDR Block (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalRouterForwardingTableAsync(String logicalRouterId, String transportNodeId, String cursor, String includedFields, String networkPrefix, Long pageSize, Boolean sortAscending, String sortBy, String source, final ApiCallback<LogicalRouterRouteTable> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalRouterForwardingTableValidateBeforeCall(logicalRouterId, transportNodeId, cursor, includedFields, networkPrefix, pageSize, sortAscending, sortBy, source, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalRouterRouteTable>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalRouterForwardingTableInCsvFormatCsv
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param networkPrefix IPv4 or IPv6 CIDR Block (optional)
     * @param source Data source type. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalRouterForwardingTableInCsvFormatCsvCall(String logicalRouterId, String transportNodeId, String networkPrefix, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}/routing/forwarding-table?format=csv"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (networkPrefix != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("network_prefix", networkPrefix));
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
        if (transportNodeId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_node_id", transportNodeId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/csv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalRouterForwardingTableInCsvFormatCsvValidateBeforeCall(String logicalRouterId, String transportNodeId, String networkPrefix, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling getLogicalRouterForwardingTableInCsvFormatCsv(Async)");
        }
        // verify the required parameter 'transportNodeId' is set
        if (transportNodeId == null) {
            throw new ApiException("Missing the required parameter 'transportNodeId' when calling getLogicalRouterForwardingTableInCsvFormatCsv(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalRouterForwardingTableInCsvFormatCsvCall(logicalRouterId, transportNodeId, networkPrefix, source, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get FIB table on a specified node for a logical router
     * Returns the FIB table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. To filter the result by network address, paramter \&quot;network_prefix&#x3D;&lt;a.b.c.d/mask&gt;\&quot; needs to be specified. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param networkPrefix IPv4 or IPv6 CIDR Block (optional)
     * @param source Data source type. (optional)
     * @return LogicalRouterRouteTableInCsvFormat
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalRouterRouteTableInCsvFormat getLogicalRouterForwardingTableInCsvFormatCsv(String logicalRouterId, String transportNodeId, String networkPrefix, String source) throws ApiException {
        ApiResponse<LogicalRouterRouteTableInCsvFormat> resp = getLogicalRouterForwardingTableInCsvFormatCsvWithHttpInfo(logicalRouterId, transportNodeId, networkPrefix, source);
        return resp.getData();
    }

    /**
     * Get FIB table on a specified node for a logical router
     * Returns the FIB table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. To filter the result by network address, paramter \&quot;network_prefix&#x3D;&lt;a.b.c.d/mask&gt;\&quot; needs to be specified. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param networkPrefix IPv4 or IPv6 CIDR Block (optional)
     * @param source Data source type. (optional)
     * @return ApiResponse&lt;LogicalRouterRouteTableInCsvFormat&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalRouterRouteTableInCsvFormat> getLogicalRouterForwardingTableInCsvFormatCsvWithHttpInfo(String logicalRouterId, String transportNodeId, String networkPrefix, String source) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalRouterForwardingTableInCsvFormatCsvValidateBeforeCall(logicalRouterId, transportNodeId, networkPrefix, source, null, null);
        Type localVarReturnType = new TypeToken<LogicalRouterRouteTableInCsvFormat>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get FIB table on a specified node for a logical router (asynchronously)
     * Returns the FIB table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. To filter the result by network address, paramter \&quot;network_prefix&#x3D;&lt;a.b.c.d/mask&gt;\&quot; needs to be specified. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param networkPrefix IPv4 or IPv6 CIDR Block (optional)
     * @param source Data source type. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalRouterForwardingTableInCsvFormatCsvAsync(String logicalRouterId, String transportNodeId, String networkPrefix, String source, final ApiCallback<LogicalRouterRouteTableInCsvFormat> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalRouterForwardingTableInCsvFormatCsvValidateBeforeCall(logicalRouterId, transportNodeId, networkPrefix, source, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalRouterRouteTableInCsvFormat>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalRouterRouteTable
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalRouterRouteTableCall(String logicalRouterId, String transportNodeId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}/routing/route-table"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (cursor != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cursor", cursor));
        if (includedFields != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("included_fields", includedFields));
        if (pageSize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page_size", pageSize));
        if (sortAscending != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_ascending", sortAscending));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_by", sortBy));
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
        if (transportNodeId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_node_id", transportNodeId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalRouterRouteTableValidateBeforeCall(String logicalRouterId, String transportNodeId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling getLogicalRouterRouteTable(Async)");
        }
        // verify the required parameter 'transportNodeId' is set
        if (transportNodeId == null) {
            throw new ApiException("Missing the required parameter 'transportNodeId' when calling getLogicalRouterRouteTable(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalRouterRouteTableCall(logicalRouterId, transportNodeId, cursor, includedFields, pageSize, sortAscending, sortBy, source, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get route table on a given node for a logical router
     * Deprecated - Please use /logical-routers/&lt;logical-router-id&gt;/routing/routing-table for RIB and /logical-routers/&lt;logical-router-id&gt;/routing/forwarding-table for FIB. Returns the route table for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @return LogicalRouterRouteTable
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalRouterRouteTable getLogicalRouterRouteTable(String logicalRouterId, String transportNodeId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source) throws ApiException {
        ApiResponse<LogicalRouterRouteTable> resp = getLogicalRouterRouteTableWithHttpInfo(logicalRouterId, transportNodeId, cursor, includedFields, pageSize, sortAscending, sortBy, source);
        return resp.getData();
    }

    /**
     * Get route table on a given node for a logical router
     * Deprecated - Please use /logical-routers/&lt;logical-router-id&gt;/routing/routing-table for RIB and /logical-routers/&lt;logical-router-id&gt;/routing/forwarding-table for FIB. Returns the route table for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @return ApiResponse&lt;LogicalRouterRouteTable&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalRouterRouteTable> getLogicalRouterRouteTableWithHttpInfo(String logicalRouterId, String transportNodeId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalRouterRouteTableValidateBeforeCall(logicalRouterId, transportNodeId, cursor, includedFields, pageSize, sortAscending, sortBy, source, null, null);
        Type localVarReturnType = new TypeToken<LogicalRouterRouteTable>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get route table on a given node for a logical router (asynchronously)
     * Deprecated - Please use /logical-routers/&lt;logical-router-id&gt;/routing/routing-table for RIB and /logical-routers/&lt;logical-router-id&gt;/routing/forwarding-table for FIB. Returns the route table for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalRouterRouteTableAsync(String logicalRouterId, String transportNodeId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, final ApiCallback<LogicalRouterRouteTable> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalRouterRouteTableValidateBeforeCall(logicalRouterId, transportNodeId, cursor, includedFields, pageSize, sortAscending, sortBy, source, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalRouterRouteTable>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalRouterRouteTableInCsvFormatCsv
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param source Data source type. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalRouterRouteTableInCsvFormatCsvCall(String logicalRouterId, String transportNodeId, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}/routing/route-table?format=csv"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
        if (transportNodeId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_node_id", transportNodeId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/csv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalRouterRouteTableInCsvFormatCsvValidateBeforeCall(String logicalRouterId, String transportNodeId, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling getLogicalRouterRouteTableInCsvFormatCsv(Async)");
        }
        // verify the required parameter 'transportNodeId' is set
        if (transportNodeId == null) {
            throw new ApiException("Missing the required parameter 'transportNodeId' when calling getLogicalRouterRouteTableInCsvFormatCsv(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalRouterRouteTableInCsvFormatCsvCall(logicalRouterId, transportNodeId, source, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get route table on a node for a logical router
     * Deprecated - Please use /logical-routers/&lt;logical-router-id&gt;/routing/routing-table for RIB and /logical-routers/&lt;logical-router-id&gt;/routing/forwarding-table for FIB. Returns the route table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param source Data source type. (optional)
     * @return LogicalRouterRouteTableInCsvFormat
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalRouterRouteTableInCsvFormat getLogicalRouterRouteTableInCsvFormatCsv(String logicalRouterId, String transportNodeId, String source) throws ApiException {
        ApiResponse<LogicalRouterRouteTableInCsvFormat> resp = getLogicalRouterRouteTableInCsvFormatCsvWithHttpInfo(logicalRouterId, transportNodeId, source);
        return resp.getData();
    }

    /**
     * Get route table on a node for a logical router
     * Deprecated - Please use /logical-routers/&lt;logical-router-id&gt;/routing/routing-table for RIB and /logical-routers/&lt;logical-router-id&gt;/routing/forwarding-table for FIB. Returns the route table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param source Data source type. (optional)
     * @return ApiResponse&lt;LogicalRouterRouteTableInCsvFormat&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalRouterRouteTableInCsvFormat> getLogicalRouterRouteTableInCsvFormatCsvWithHttpInfo(String logicalRouterId, String transportNodeId, String source) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalRouterRouteTableInCsvFormatCsvValidateBeforeCall(logicalRouterId, transportNodeId, source, null, null);
        Type localVarReturnType = new TypeToken<LogicalRouterRouteTableInCsvFormat>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get route table on a node for a logical router (asynchronously)
     * Deprecated - Please use /logical-routers/&lt;logical-router-id&gt;/routing/routing-table for RIB and /logical-routers/&lt;logical-router-id&gt;/routing/forwarding-table for FIB. Returns the route table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param source Data source type. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalRouterRouteTableInCsvFormatCsvAsync(String logicalRouterId, String transportNodeId, String source, final ApiCallback<LogicalRouterRouteTableInCsvFormat> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalRouterRouteTableInCsvFormatCsvValidateBeforeCall(logicalRouterId, transportNodeId, source, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalRouterRouteTableInCsvFormat>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalRouterRoutingTable
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param networkPrefix IPv4 or IPv6 CIDR Block (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param routeSource Route source filter parameter (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalRouterRoutingTableCall(String logicalRouterId, String transportNodeId, String cursor, String includedFields, String networkPrefix, Long pageSize, String routeSource, Boolean sortAscending, String sortBy, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}/routing/routing-table"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (cursor != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cursor", cursor));
        if (includedFields != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("included_fields", includedFields));
        if (networkPrefix != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("network_prefix", networkPrefix));
        if (pageSize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page_size", pageSize));
        if (routeSource != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("route_source", routeSource));
        if (sortAscending != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_ascending", sortAscending));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_by", sortBy));
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
        if (transportNodeId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_node_id", transportNodeId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalRouterRoutingTableValidateBeforeCall(String logicalRouterId, String transportNodeId, String cursor, String includedFields, String networkPrefix, Long pageSize, String routeSource, Boolean sortAscending, String sortBy, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling getLogicalRouterRoutingTable(Async)");
        }
        // verify the required parameter 'transportNodeId' is set
        if (transportNodeId == null) {
            throw new ApiException("Missing the required parameter 'transportNodeId' when calling getLogicalRouterRoutingTable(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalRouterRoutingTableCall(logicalRouterId, transportNodeId, cursor, includedFields, networkPrefix, pageSize, routeSource, sortAscending, sortBy, source, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get RIB table on a specified node for a logical router
     * Returns the route table(RIB) for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. To filter the result by network address, parameter \&quot;network_prefix&#x3D;&lt;a.b.c.d/mask&gt;\&quot; needs to be specified. To filter the result by route source, parameter \&quot;route_source&#x3D;&lt;source_type&gt;\&quot; needs to be specified where source_type can be BGP, STATIC, CONNECTED, NSX_STATIC, TIER1_NAT or TIER0_NAT. It is also possible to filter the RIB table using both network address and route source filter together. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param networkPrefix IPv4 or IPv6 CIDR Block (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param routeSource Route source filter parameter (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @return LogicalRouterRouteTable
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalRouterRouteTable getLogicalRouterRoutingTable(String logicalRouterId, String transportNodeId, String cursor, String includedFields, String networkPrefix, Long pageSize, String routeSource, Boolean sortAscending, String sortBy, String source) throws ApiException {
        ApiResponse<LogicalRouterRouteTable> resp = getLogicalRouterRoutingTableWithHttpInfo(logicalRouterId, transportNodeId, cursor, includedFields, networkPrefix, pageSize, routeSource, sortAscending, sortBy, source);
        return resp.getData();
    }

    /**
     * Get RIB table on a specified node for a logical router
     * Returns the route table(RIB) for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. To filter the result by network address, parameter \&quot;network_prefix&#x3D;&lt;a.b.c.d/mask&gt;\&quot; needs to be specified. To filter the result by route source, parameter \&quot;route_source&#x3D;&lt;source_type&gt;\&quot; needs to be specified where source_type can be BGP, STATIC, CONNECTED, NSX_STATIC, TIER1_NAT or TIER0_NAT. It is also possible to filter the RIB table using both network address and route source filter together. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param networkPrefix IPv4 or IPv6 CIDR Block (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param routeSource Route source filter parameter (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @return ApiResponse&lt;LogicalRouterRouteTable&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalRouterRouteTable> getLogicalRouterRoutingTableWithHttpInfo(String logicalRouterId, String transportNodeId, String cursor, String includedFields, String networkPrefix, Long pageSize, String routeSource, Boolean sortAscending, String sortBy, String source) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalRouterRoutingTableValidateBeforeCall(logicalRouterId, transportNodeId, cursor, includedFields, networkPrefix, pageSize, routeSource, sortAscending, sortBy, source, null, null);
        Type localVarReturnType = new TypeToken<LogicalRouterRouteTable>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get RIB table on a specified node for a logical router (asynchronously)
     * Returns the route table(RIB) for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. To filter the result by network address, parameter \&quot;network_prefix&#x3D;&lt;a.b.c.d/mask&gt;\&quot; needs to be specified. To filter the result by route source, parameter \&quot;route_source&#x3D;&lt;source_type&gt;\&quot; needs to be specified where source_type can be BGP, STATIC, CONNECTED, NSX_STATIC, TIER1_NAT or TIER0_NAT. It is also possible to filter the RIB table using both network address and route source filter together. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param networkPrefix IPv4 or IPv6 CIDR Block (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param routeSource Route source filter parameter (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalRouterRoutingTableAsync(String logicalRouterId, String transportNodeId, String cursor, String includedFields, String networkPrefix, Long pageSize, String routeSource, Boolean sortAscending, String sortBy, String source, final ApiCallback<LogicalRouterRouteTable> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalRouterRoutingTableValidateBeforeCall(logicalRouterId, transportNodeId, cursor, includedFields, networkPrefix, pageSize, routeSource, sortAscending, sortBy, source, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalRouterRouteTable>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalRouterRoutingTableInCsvFormatCsv
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param networkPrefix IPv4 or IPv6 CIDR Block (optional)
     * @param routeSource Route source filter parameter (optional)
     * @param source Data source type. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalRouterRoutingTableInCsvFormatCsvCall(String logicalRouterId, String transportNodeId, String networkPrefix, String routeSource, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}/routing/routing-table?format=csv"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (networkPrefix != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("network_prefix", networkPrefix));
        if (routeSource != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("route_source", routeSource));
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
        if (transportNodeId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_node_id", transportNodeId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/csv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalRouterRoutingTableInCsvFormatCsvValidateBeforeCall(String logicalRouterId, String transportNodeId, String networkPrefix, String routeSource, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling getLogicalRouterRoutingTableInCsvFormatCsv(Async)");
        }
        // verify the required parameter 'transportNodeId' is set
        if (transportNodeId == null) {
            throw new ApiException("Missing the required parameter 'transportNodeId' when calling getLogicalRouterRoutingTableInCsvFormatCsv(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalRouterRoutingTableInCsvFormatCsvCall(logicalRouterId, transportNodeId, networkPrefix, routeSource, source, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get RIB table on a specified node for a logical router
     * Returns the route table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. To filter the result by network address, paramter \&quot;network_prefix&#x3D;&lt;a.b.c.d/mask&gt;\&quot; needs to be specified. To filter the result by route source, parameter \&quot;route_source&#x3D;&lt;source_type&gt;\&quot; needs to be specified where source_type can be BGP, STATIC, CONNECTED, NSX_STATIC, TIER1_NAT or TIER0_NAT. It is also possible to filter the RIB table using both network address and route source filter together. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param networkPrefix IPv4 or IPv6 CIDR Block (optional)
     * @param routeSource Route source filter parameter (optional)
     * @param source Data source type. (optional)
     * @return LogicalRouterRouteTableInCsvFormat
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalRouterRouteTableInCsvFormat getLogicalRouterRoutingTableInCsvFormatCsv(String logicalRouterId, String transportNodeId, String networkPrefix, String routeSource, String source) throws ApiException {
        ApiResponse<LogicalRouterRouteTableInCsvFormat> resp = getLogicalRouterRoutingTableInCsvFormatCsvWithHttpInfo(logicalRouterId, transportNodeId, networkPrefix, routeSource, source);
        return resp.getData();
    }

    /**
     * Get RIB table on a specified node for a logical router
     * Returns the route table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. To filter the result by network address, paramter \&quot;network_prefix&#x3D;&lt;a.b.c.d/mask&gt;\&quot; needs to be specified. To filter the result by route source, parameter \&quot;route_source&#x3D;&lt;source_type&gt;\&quot; needs to be specified where source_type can be BGP, STATIC, CONNECTED, NSX_STATIC, TIER1_NAT or TIER0_NAT. It is also possible to filter the RIB table using both network address and route source filter together. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param networkPrefix IPv4 or IPv6 CIDR Block (optional)
     * @param routeSource Route source filter parameter (optional)
     * @param source Data source type. (optional)
     * @return ApiResponse&lt;LogicalRouterRouteTableInCsvFormat&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalRouterRouteTableInCsvFormat> getLogicalRouterRoutingTableInCsvFormatCsvWithHttpInfo(String logicalRouterId, String transportNodeId, String networkPrefix, String routeSource, String source) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalRouterRoutingTableInCsvFormatCsvValidateBeforeCall(logicalRouterId, transportNodeId, networkPrefix, routeSource, source, null, null);
        Type localVarReturnType = new TypeToken<LogicalRouterRouteTableInCsvFormat>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get RIB table on a specified node for a logical router (asynchronously)
     * Returns the route table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \&quot;transport_node_id&#x3D;&lt;transport-node-id&gt;\&quot; is required. To filter the result by network address, paramter \&quot;network_prefix&#x3D;&lt;a.b.c.d/mask&gt;\&quot; needs to be specified. To filter the result by route source, parameter \&quot;route_source&#x3D;&lt;source_type&gt;\&quot; needs to be specified where source_type can be BGP, STATIC, CONNECTED, NSX_STATIC, TIER1_NAT or TIER0_NAT. It is also possible to filter the RIB table using both network address and route source filter together. Query parameter \&quot;source&#x3D;realtime\&quot; is the only supported source. 
     * @param logicalRouterId  (required)
     * @param transportNodeId TransportNode Id (required)
     * @param networkPrefix IPv4 or IPv6 CIDR Block (optional)
     * @param routeSource Route source filter parameter (optional)
     * @param source Data source type. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalRouterRoutingTableInCsvFormatCsvAsync(String logicalRouterId, String transportNodeId, String networkPrefix, String routeSource, String source, final ApiCallback<LogicalRouterRouteTableInCsvFormat> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalRouterRoutingTableInCsvFormatCsvValidateBeforeCall(logicalRouterId, transportNodeId, networkPrefix, routeSource, source, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalRouterRouteTableInCsvFormat>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalRouterState
     * @param logicalRouterId  (required)
     * @param barrierId  (optional)
     * @param requestId Realization request ID (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalRouterStateCall(String logicalRouterId, Long barrierId, String requestId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}/state"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (barrierId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("barrier_id", barrierId));
        if (requestId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("request_id", requestId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalRouterStateValidateBeforeCall(String logicalRouterId, Long barrierId, String requestId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling getLogicalRouterState(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalRouterStateCall(logicalRouterId, barrierId, requestId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get the Realized State of a Logical Router
     * Return realized state information of a logical router. Any configuration update that affects the logical router can use this API to get its realized state by passing a request_id returned by the configuration change operation. e.g. Update configuration of logical router, static routes, etc. 
     * @param logicalRouterId  (required)
     * @param barrierId  (optional)
     * @param requestId Realization request ID (optional)
     * @return LogicalRouterState
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalRouterState getLogicalRouterState(String logicalRouterId, Long barrierId, String requestId) throws ApiException {
        ApiResponse<LogicalRouterState> resp = getLogicalRouterStateWithHttpInfo(logicalRouterId, barrierId, requestId);
        return resp.getData();
    }

    /**
     * Get the Realized State of a Logical Router
     * Return realized state information of a logical router. Any configuration update that affects the logical router can use this API to get its realized state by passing a request_id returned by the configuration change operation. e.g. Update configuration of logical router, static routes, etc. 
     * @param logicalRouterId  (required)
     * @param barrierId  (optional)
     * @param requestId Realization request ID (optional)
     * @return ApiResponse&lt;LogicalRouterState&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalRouterState> getLogicalRouterStateWithHttpInfo(String logicalRouterId, Long barrierId, String requestId) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalRouterStateValidateBeforeCall(logicalRouterId, barrierId, requestId, null, null);
        Type localVarReturnType = new TypeToken<LogicalRouterState>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get the Realized State of a Logical Router (asynchronously)
     * Return realized state information of a logical router. Any configuration update that affects the logical router can use this API to get its realized state by passing a request_id returned by the configuration change operation. e.g. Update configuration of logical router, static routes, etc. 
     * @param logicalRouterId  (required)
     * @param barrierId  (optional)
     * @param requestId Realization request ID (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalRouterStateAsync(String logicalRouterId, Long barrierId, String requestId, final ApiCallback<LogicalRouterState> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalRouterStateValidateBeforeCall(logicalRouterId, barrierId, requestId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalRouterState>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalRouterStatus
     * @param logicalRouterId  (required)
     * @param source Data source type. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalRouterStatusCall(String logicalRouterId, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}/status"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalRouterStatusValidateBeforeCall(String logicalRouterId, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling getLogicalRouterStatus(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalRouterStatusCall(logicalRouterId, source, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get the status for the Logical Router of the given id
     * Returns status for the Logical Router of the given id.
     * @param logicalRouterId  (required)
     * @param source Data source type. (optional)
     * @return LogicalRouterStatus
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalRouterStatus getLogicalRouterStatus(String logicalRouterId, String source) throws ApiException {
        ApiResponse<LogicalRouterStatus> resp = getLogicalRouterStatusWithHttpInfo(logicalRouterId, source);
        return resp.getData();
    }

    /**
     * Get the status for the Logical Router of the given id
     * Returns status for the Logical Router of the given id.
     * @param logicalRouterId  (required)
     * @param source Data source type. (optional)
     * @return ApiResponse&lt;LogicalRouterStatus&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalRouterStatus> getLogicalRouterStatusWithHttpInfo(String logicalRouterId, String source) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalRouterStatusValidateBeforeCall(logicalRouterId, source, null, null);
        Type localVarReturnType = new TypeToken<LogicalRouterStatus>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get the status for the Logical Router of the given id (asynchronously)
     * Returns status for the Logical Router of the given id.
     * @param logicalRouterId  (required)
     * @param source Data source type. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalRouterStatusAsync(String logicalRouterId, String source, final ApiCallback<LogicalRouterStatus> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalRouterStatusValidateBeforeCall(logicalRouterId, source, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalRouterStatus>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalServiceRouterClusterState
     * @param logicalRouterId  (required)
     * @param barrierId  (optional)
     * @param requestId Realization request ID (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalServiceRouterClusterStateCall(String logicalRouterId, Long barrierId, String requestId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}/service-cluster/state"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (barrierId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("barrier_id", barrierId));
        if (requestId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("request_id", requestId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalServiceRouterClusterStateValidateBeforeCall(String logicalRouterId, Long barrierId, String requestId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling getLogicalServiceRouterClusterState(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalServiceRouterClusterStateCall(logicalRouterId, barrierId, requestId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get the Realized State of a Logical Service Router Cluster
     * Return realized state information of a logical service router cluster. Any configuration update that affects the logical service router cluster can use this API to get its realized state by passing a request_id returned by the configuration change operation. e.g. Update configuration of nat, bgp, bfd, etc. 
     * @param logicalRouterId  (required)
     * @param barrierId  (optional)
     * @param requestId Realization request ID (optional)
     * @return LogicalServiceRouterClusterState
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalServiceRouterClusterState getLogicalServiceRouterClusterState(String logicalRouterId, Long barrierId, String requestId) throws ApiException {
        ApiResponse<LogicalServiceRouterClusterState> resp = getLogicalServiceRouterClusterStateWithHttpInfo(logicalRouterId, barrierId, requestId);
        return resp.getData();
    }

    /**
     * Get the Realized State of a Logical Service Router Cluster
     * Return realized state information of a logical service router cluster. Any configuration update that affects the logical service router cluster can use this API to get its realized state by passing a request_id returned by the configuration change operation. e.g. Update configuration of nat, bgp, bfd, etc. 
     * @param logicalRouterId  (required)
     * @param barrierId  (optional)
     * @param requestId Realization request ID (optional)
     * @return ApiResponse&lt;LogicalServiceRouterClusterState&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalServiceRouterClusterState> getLogicalServiceRouterClusterStateWithHttpInfo(String logicalRouterId, Long barrierId, String requestId) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalServiceRouterClusterStateValidateBeforeCall(logicalRouterId, barrierId, requestId, null, null);
        Type localVarReturnType = new TypeToken<LogicalServiceRouterClusterState>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get the Realized State of a Logical Service Router Cluster (asynchronously)
     * Return realized state information of a logical service router cluster. Any configuration update that affects the logical service router cluster can use this API to get its realized state by passing a request_id returned by the configuration change operation. e.g. Update configuration of nat, bgp, bfd, etc. 
     * @param logicalRouterId  (required)
     * @param barrierId  (optional)
     * @param requestId Realization request ID (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalServiceRouterClusterStateAsync(String logicalRouterId, Long barrierId, String requestId, final ApiCallback<LogicalServiceRouterClusterState> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalServiceRouterClusterStateValidateBeforeCall(logicalRouterId, barrierId, requestId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalServiceRouterClusterState>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for listLogicalRouters
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param routerType Type of Logical Router (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call listLogicalRoutersCall(String cursor, String includedFields, Long pageSize, String routerType, Boolean sortAscending, String sortBy, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-routers";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (cursor != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cursor", cursor));
        if (includedFields != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("included_fields", includedFields));
        if (pageSize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page_size", pageSize));
        if (routerType != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("router_type", routerType));
        if (sortAscending != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_ascending", sortAscending));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_by", sortBy));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call listLogicalRoutersValidateBeforeCall(String cursor, String includedFields, Long pageSize, String routerType, Boolean sortAscending, String sortBy, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        com.squareup.okhttp.Call call = listLogicalRoutersCall(cursor, includedFields, pageSize, routerType, sortAscending, sortBy, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * List Logical Routers
     * Returns information about all logical routers, including the UUID, internal and external transit network addresses, and the router type (TIER0 or TIER1). You can get information for only TIER0 routers or only the TIER1 routers by including the router_type query parameter. 
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param routerType Type of Logical Router (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @return LogicalRouterListResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalRouterListResult listLogicalRouters(String cursor, String includedFields, Long pageSize, String routerType, Boolean sortAscending, String sortBy) throws ApiException {
        ApiResponse<LogicalRouterListResult> resp = listLogicalRoutersWithHttpInfo(cursor, includedFields, pageSize, routerType, sortAscending, sortBy);
        return resp.getData();
    }

    /**
     * List Logical Routers
     * Returns information about all logical routers, including the UUID, internal and external transit network addresses, and the router type (TIER0 or TIER1). You can get information for only TIER0 routers or only the TIER1 routers by including the router_type query parameter. 
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param routerType Type of Logical Router (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @return ApiResponse&lt;LogicalRouterListResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalRouterListResult> listLogicalRoutersWithHttpInfo(String cursor, String includedFields, Long pageSize, String routerType, Boolean sortAscending, String sortBy) throws ApiException {
        com.squareup.okhttp.Call call = listLogicalRoutersValidateBeforeCall(cursor, includedFields, pageSize, routerType, sortAscending, sortBy, null, null);
        Type localVarReturnType = new TypeToken<LogicalRouterListResult>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * List Logical Routers (asynchronously)
     * Returns information about all logical routers, including the UUID, internal and external transit network addresses, and the router type (TIER0 or TIER1). You can get information for only TIER0 routers or only the TIER1 routers by including the router_type query parameter. 
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param routerType Type of Logical Router (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call listLogicalRoutersAsync(String cursor, String includedFields, Long pageSize, String routerType, Boolean sortAscending, String sortBy, final ApiCallback<LogicalRouterListResult> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = listLogicalRoutersValidateBeforeCall(cursor, includedFields, pageSize, routerType, sortAscending, sortBy, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalRouterListResult>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for reAllocateServiceRoutersReallocate
     * @param body  (required)
     * @param logicalRouterId  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call reAllocateServiceRoutersReallocateCall(ServiceRouterAllocationConfig body, String logicalRouterId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}?action=reallocate"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call reAllocateServiceRoutersReallocateValidateBeforeCall(ServiceRouterAllocationConfig body, String logicalRouterId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling reAllocateServiceRoutersReallocate(Async)");
        }
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling reAllocateServiceRoutersReallocate(Async)");
        }
        
        com.squareup.okhttp.Call call = reAllocateServiceRoutersReallocateCall(body, logicalRouterId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Re allocate edge node placement of TIER1 service routers
     * API to re allocate edge node placement for TIER1 logical router. You can re-allocate service routers of TIER1 in same edge cluster or different edge cluster. You can also place edge nodes manually and provide maximum two indices for HA mode ACTIVE_STANDBY. To re-allocate on new edge cluster you must have existing edge cluster for TIER1 logical router. This will be disruptive operation and all existing statistics of logical router will be remove. 
     * @param body  (required)
     * @param logicalRouterId  (required)
     * @return LogicalRouter
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalRouter reAllocateServiceRoutersReallocate(ServiceRouterAllocationConfig body, String logicalRouterId) throws ApiException {
        ApiResponse<LogicalRouter> resp = reAllocateServiceRoutersReallocateWithHttpInfo(body, logicalRouterId);
        return resp.getData();
    }

    /**
     * Re allocate edge node placement of TIER1 service routers
     * API to re allocate edge node placement for TIER1 logical router. You can re-allocate service routers of TIER1 in same edge cluster or different edge cluster. You can also place edge nodes manually and provide maximum two indices for HA mode ACTIVE_STANDBY. To re-allocate on new edge cluster you must have existing edge cluster for TIER1 logical router. This will be disruptive operation and all existing statistics of logical router will be remove. 
     * @param body  (required)
     * @param logicalRouterId  (required)
     * @return ApiResponse&lt;LogicalRouter&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalRouter> reAllocateServiceRoutersReallocateWithHttpInfo(ServiceRouterAllocationConfig body, String logicalRouterId) throws ApiException {
        com.squareup.okhttp.Call call = reAllocateServiceRoutersReallocateValidateBeforeCall(body, logicalRouterId, null, null);
        Type localVarReturnType = new TypeToken<LogicalRouter>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Re allocate edge node placement of TIER1 service routers (asynchronously)
     * API to re allocate edge node placement for TIER1 logical router. You can re-allocate service routers of TIER1 in same edge cluster or different edge cluster. You can also place edge nodes manually and provide maximum two indices for HA mode ACTIVE_STANDBY. To re-allocate on new edge cluster you must have existing edge cluster for TIER1 logical router. This will be disruptive operation and all existing statistics of logical router will be remove. 
     * @param body  (required)
     * @param logicalRouterId  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call reAllocateServiceRoutersReallocateAsync(ServiceRouterAllocationConfig body, String logicalRouterId, final ApiCallback<LogicalRouter> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = reAllocateServiceRoutersReallocateValidateBeforeCall(body, logicalRouterId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalRouter>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for reProcessLogicalRouterReprocess
     * @param logicalRouterId  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call reProcessLogicalRouterReprocessCall(String logicalRouterId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}?action=reprocess"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call reProcessLogicalRouterReprocessValidateBeforeCall(String logicalRouterId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling reProcessLogicalRouterReprocess(Async)");
        }
        
        com.squareup.okhttp.Call call = reProcessLogicalRouterReprocessCall(logicalRouterId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Reprocesses a logical router configuration and publish updates to controller
     * Reprocess logical router configuration and configuration of related entities like logical router ports, static routing, etc. Any missing Updates are published to controller. 
     * @param logicalRouterId  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void reProcessLogicalRouterReprocess(String logicalRouterId) throws ApiException {
        reProcessLogicalRouterReprocessWithHttpInfo(logicalRouterId);
    }

    /**
     * Reprocesses a logical router configuration and publish updates to controller
     * Reprocess logical router configuration and configuration of related entities like logical router ports, static routing, etc. Any missing Updates are published to controller. 
     * @param logicalRouterId  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> reProcessLogicalRouterReprocessWithHttpInfo(String logicalRouterId) throws ApiException {
        com.squareup.okhttp.Call call = reProcessLogicalRouterReprocessValidateBeforeCall(logicalRouterId, null, null);
        return apiClient.execute(call);
    }

    /**
     * Reprocesses a logical router configuration and publish updates to controller (asynchronously)
     * Reprocess logical router configuration and configuration of related entities like logical router ports, static routing, etc. Any missing Updates are published to controller. 
     * @param logicalRouterId  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call reProcessLogicalRouterReprocessAsync(String logicalRouterId, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = reProcessLogicalRouterReprocessValidateBeforeCall(logicalRouterId, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for readLogicalRouter
     * @param logicalRouterId  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call readLogicalRouterCall(String logicalRouterId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call readLogicalRouterValidateBeforeCall(String logicalRouterId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling readLogicalRouter(Async)");
        }
        
        com.squareup.okhttp.Call call = readLogicalRouterCall(logicalRouterId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Read Logical Router
     * Returns information about the specified logical router.
     * @param logicalRouterId  (required)
     * @return LogicalRouter
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalRouter readLogicalRouter(String logicalRouterId) throws ApiException {
        ApiResponse<LogicalRouter> resp = readLogicalRouterWithHttpInfo(logicalRouterId);
        return resp.getData();
    }

    /**
     * Read Logical Router
     * Returns information about the specified logical router.
     * @param logicalRouterId  (required)
     * @return ApiResponse&lt;LogicalRouter&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalRouter> readLogicalRouterWithHttpInfo(String logicalRouterId) throws ApiException {
        com.squareup.okhttp.Call call = readLogicalRouterValidateBeforeCall(logicalRouterId, null, null);
        Type localVarReturnType = new TypeToken<LogicalRouter>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Read Logical Router (asynchronously)
     * Returns information about the specified logical router.
     * @param logicalRouterId  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call readLogicalRouterAsync(String logicalRouterId, final ApiCallback<LogicalRouter> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = readLogicalRouterValidateBeforeCall(logicalRouterId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalRouter>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for updateLogicalRouter
     * @param body  (required)
     * @param logicalRouterId  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call updateLogicalRouterCall(LogicalRouter body, String logicalRouterId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/logical-routers/{logical-router-id}"
            .replaceAll("\\{" + "logical-router-id" + "\\}", apiClient.escapeString(logicalRouterId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call updateLogicalRouterValidateBeforeCall(LogicalRouter body, String logicalRouterId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling updateLogicalRouter(Async)");
        }
        // verify the required parameter 'logicalRouterId' is set
        if (logicalRouterId == null) {
            throw new ApiException("Missing the required parameter 'logicalRouterId' when calling updateLogicalRouter(Async)");
        }
        
        com.squareup.okhttp.Call call = updateLogicalRouterCall(body, logicalRouterId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Update a Logical Router
     * Modifies the specified logical router. Modifiable attributes include the internal_transit_network, external_transit_networks, and edge_cluster_id (for TIER0 routers). 
     * @param body  (required)
     * @param logicalRouterId  (required)
     * @return LogicalRouter
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalRouter updateLogicalRouter(LogicalRouter body, String logicalRouterId) throws ApiException {
        ApiResponse<LogicalRouter> resp = updateLogicalRouterWithHttpInfo(body, logicalRouterId);
        return resp.getData();
    }

    /**
     * Update a Logical Router
     * Modifies the specified logical router. Modifiable attributes include the internal_transit_network, external_transit_networks, and edge_cluster_id (for TIER0 routers). 
     * @param body  (required)
     * @param logicalRouterId  (required)
     * @return ApiResponse&lt;LogicalRouter&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalRouter> updateLogicalRouterWithHttpInfo(LogicalRouter body, String logicalRouterId) throws ApiException {
        com.squareup.okhttp.Call call = updateLogicalRouterValidateBeforeCall(body, logicalRouterId, null, null);
        Type localVarReturnType = new TypeToken<LogicalRouter>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update a Logical Router (asynchronously)
     * Modifies the specified logical router. Modifiable attributes include the internal_transit_network, external_transit_networks, and edge_cluster_id (for TIER0 routers). 
     * @param body  (required)
     * @param logicalRouterId  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call updateLogicalRouterAsync(LogicalRouter body, String logicalRouterId, final ApiCallback<LogicalRouter> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = updateLogicalRouterValidateBeforeCall(body, logicalRouterId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalRouter>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
