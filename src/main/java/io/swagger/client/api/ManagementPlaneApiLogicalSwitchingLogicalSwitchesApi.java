/*
 * NSX-T Manager API
 * VMware NSX-T Manager REST API
 *
 * OpenAPI spec version: 2.5.1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api;

import io.swagger.client.ApiCallback;
import io.swagger.client.ApiClient;
import io.swagger.client.ApiException;
import io.swagger.client.ApiResponse;
import io.swagger.client.Configuration;
import io.swagger.client.Pair;
import io.swagger.client.ProgressRequestBody;
import io.swagger.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.swagger.client.model.ApiError;
import io.swagger.client.model.LogicalSwitch;
import io.swagger.client.model.LogicalSwitchListResult;
import io.swagger.client.model.LogicalSwitchState;
import io.swagger.client.model.LogicalSwitchStateListResult;
import io.swagger.client.model.LogicalSwitchStatistics;
import io.swagger.client.model.LogicalSwitchStatus;
import io.swagger.client.model.LogicalSwitchStatusSummary;
import io.swagger.client.model.MacAddressCsvListResult;
import io.swagger.client.model.MacAddressListResult;
import io.swagger.client.model.VtepCsvListResult;
import io.swagger.client.model.VtepListResult;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ManagementPlaneApiLogicalSwitchingLogicalSwitchesApi {
    private ApiClient apiClient;

    public ManagementPlaneApiLogicalSwitchingLogicalSwitchesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ManagementPlaneApiLogicalSwitchingLogicalSwitchesApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for createLogicalSwitch
     * @param body  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call createLogicalSwitchCall(LogicalSwitch body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/logical-switches";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call createLogicalSwitchValidateBeforeCall(LogicalSwitch body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling createLogicalSwitch(Async)");
        }
        
        com.squareup.okhttp.Call call = createLogicalSwitchCall(body, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Create a Logical Switch
     * Creates a new logical switch. The request must include the transport_zone_id, display_name, and admin_state (UP or DOWN). The replication_mode (MTEP or SOURCE) is required for overlay logical switches, but not for VLAN-based logical switches. A vlan needs to be provided for VLAN-based logical switches 
     * @param body  (required)
     * @return LogicalSwitch
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalSwitch createLogicalSwitch(LogicalSwitch body) throws ApiException {
        ApiResponse<LogicalSwitch> resp = createLogicalSwitchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Create a Logical Switch
     * Creates a new logical switch. The request must include the transport_zone_id, display_name, and admin_state (UP or DOWN). The replication_mode (MTEP or SOURCE) is required for overlay logical switches, but not for VLAN-based logical switches. A vlan needs to be provided for VLAN-based logical switches 
     * @param body  (required)
     * @return ApiResponse&lt;LogicalSwitch&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalSwitch> createLogicalSwitchWithHttpInfo(LogicalSwitch body) throws ApiException {
        com.squareup.okhttp.Call call = createLogicalSwitchValidateBeforeCall(body, null, null);
        Type localVarReturnType = new TypeToken<LogicalSwitch>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Create a Logical Switch (asynchronously)
     * Creates a new logical switch. The request must include the transport_zone_id, display_name, and admin_state (UP or DOWN). The replication_mode (MTEP or SOURCE) is required for overlay logical switches, but not for VLAN-based logical switches. A vlan needs to be provided for VLAN-based logical switches 
     * @param body  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call createLogicalSwitchAsync(LogicalSwitch body, final ApiCallback<LogicalSwitch> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = createLogicalSwitchValidateBeforeCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalSwitch>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for deleteLogicalSwitch
     * @param lswitchId  (required)
     * @param cascade Delete a Logical Switch and all the logical ports in it, if none of the logical ports have any attachment.  (optional)
     * @param detach Force delete a logical switch (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call deleteLogicalSwitchCall(String lswitchId, Boolean cascade, Boolean detach, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-switches/{lswitch-id}"
            .replaceAll("\\{" + "lswitch-id" + "\\}", apiClient.escapeString(lswitchId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (cascade != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cascade", cascade));
        if (detach != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("detach", detach));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call deleteLogicalSwitchValidateBeforeCall(String lswitchId, Boolean cascade, Boolean detach, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'lswitchId' is set
        if (lswitchId == null) {
            throw new ApiException("Missing the required parameter 'lswitchId' when calling deleteLogicalSwitch(Async)");
        }
        
        com.squareup.okhttp.Call call = deleteLogicalSwitchCall(lswitchId, cascade, detach, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Delete a Logical Switch
     * Removes a logical switch from the associated overlay or VLAN transport zone. By default, a logical switch cannot be deleted if there are logical ports on the switch, or it is added to a NSGroup. Cascade option can be used to delete all ports and the logical switch. Detach option can be used to delete the logical switch forcibly. 
     * @param lswitchId  (required)
     * @param cascade Delete a Logical Switch and all the logical ports in it, if none of the logical ports have any attachment.  (optional)
     * @param detach Force delete a logical switch (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void deleteLogicalSwitch(String lswitchId, Boolean cascade, Boolean detach) throws ApiException {
        deleteLogicalSwitchWithHttpInfo(lswitchId, cascade, detach);
    }

    /**
     * Delete a Logical Switch
     * Removes a logical switch from the associated overlay or VLAN transport zone. By default, a logical switch cannot be deleted if there are logical ports on the switch, or it is added to a NSGroup. Cascade option can be used to delete all ports and the logical switch. Detach option can be used to delete the logical switch forcibly. 
     * @param lswitchId  (required)
     * @param cascade Delete a Logical Switch and all the logical ports in it, if none of the logical ports have any attachment.  (optional)
     * @param detach Force delete a logical switch (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> deleteLogicalSwitchWithHttpInfo(String lswitchId, Boolean cascade, Boolean detach) throws ApiException {
        com.squareup.okhttp.Call call = deleteLogicalSwitchValidateBeforeCall(lswitchId, cascade, detach, null, null);
        return apiClient.execute(call);
    }

    /**
     * Delete a Logical Switch (asynchronously)
     * Removes a logical switch from the associated overlay or VLAN transport zone. By default, a logical switch cannot be deleted if there are logical ports on the switch, or it is added to a NSGroup. Cascade option can be used to delete all ports and the logical switch. Detach option can be used to delete the logical switch forcibly. 
     * @param lswitchId  (required)
     * @param cascade Delete a Logical Switch and all the logical ports in it, if none of the logical ports have any attachment.  (optional)
     * @param detach Force delete a logical switch (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call deleteLogicalSwitchAsync(String lswitchId, Boolean cascade, Boolean detach, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = deleteLogicalSwitchValidateBeforeCall(lswitchId, cascade, detach, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for getLogicalSwitch
     * @param lswitchId  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalSwitchCall(String lswitchId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-switches/{lswitch-id}"
            .replaceAll("\\{" + "lswitch-id" + "\\}", apiClient.escapeString(lswitchId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalSwitchValidateBeforeCall(String lswitchId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'lswitchId' is set
        if (lswitchId == null) {
            throw new ApiException("Missing the required parameter 'lswitchId' when calling getLogicalSwitch(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalSwitchCall(lswitchId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get Logical Switch associated with the provided id (lswitch-id)
     * Returns information about the specified logical switch Id.
     * @param lswitchId  (required)
     * @return LogicalSwitch
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalSwitch getLogicalSwitch(String lswitchId) throws ApiException {
        ApiResponse<LogicalSwitch> resp = getLogicalSwitchWithHttpInfo(lswitchId);
        return resp.getData();
    }

    /**
     * Get Logical Switch associated with the provided id (lswitch-id)
     * Returns information about the specified logical switch Id.
     * @param lswitchId  (required)
     * @return ApiResponse&lt;LogicalSwitch&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalSwitch> getLogicalSwitchWithHttpInfo(String lswitchId) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalSwitchValidateBeforeCall(lswitchId, null, null);
        Type localVarReturnType = new TypeToken<LogicalSwitch>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Logical Switch associated with the provided id (lswitch-id) (asynchronously)
     * Returns information about the specified logical switch Id.
     * @param lswitchId  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalSwitchAsync(String lswitchId, final ApiCallback<LogicalSwitch> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalSwitchValidateBeforeCall(lswitchId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalSwitch>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalSwitchMacTable
     * @param lswitchId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalSwitchMacTableCall(String lswitchId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-switches/{lswitch-id}/mac-table"
            .replaceAll("\\{" + "lswitch-id" + "\\}", apiClient.escapeString(lswitchId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (cursor != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cursor", cursor));
        if (includedFields != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("included_fields", includedFields));
        if (pageSize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page_size", pageSize));
        if (sortAscending != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_ascending", sortAscending));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_by", sortBy));
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
        if (transportNodeId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_node_id", transportNodeId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalSwitchMacTableValidateBeforeCall(String lswitchId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'lswitchId' is set
        if (lswitchId == null) {
            throw new ApiException("Missing the required parameter 'lswitchId' when calling getLogicalSwitchMacTable(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalSwitchMacTableCall(lswitchId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get MAC Table for Logical Switch of the Given ID (lswitch-id)
     * Returns MAC table of a specified logical switch from the given transport node if a transport node id is given in the query parameter from the Central Controller Plane. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. 
     * @param lswitchId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @return MacAddressListResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public MacAddressListResult getLogicalSwitchMacTable(String lswitchId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId) throws ApiException {
        ApiResponse<MacAddressListResult> resp = getLogicalSwitchMacTableWithHttpInfo(lswitchId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId);
        return resp.getData();
    }

    /**
     * Get MAC Table for Logical Switch of the Given ID (lswitch-id)
     * Returns MAC table of a specified logical switch from the given transport node if a transport node id is given in the query parameter from the Central Controller Plane. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. 
     * @param lswitchId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @return ApiResponse&lt;MacAddressListResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<MacAddressListResult> getLogicalSwitchMacTableWithHttpInfo(String lswitchId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalSwitchMacTableValidateBeforeCall(lswitchId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId, null, null);
        Type localVarReturnType = new TypeToken<MacAddressListResult>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get MAC Table for Logical Switch of the Given ID (lswitch-id) (asynchronously)
     * Returns MAC table of a specified logical switch from the given transport node if a transport node id is given in the query parameter from the Central Controller Plane. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. 
     * @param lswitchId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalSwitchMacTableAsync(String lswitchId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId, final ApiCallback<MacAddressListResult> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalSwitchMacTableValidateBeforeCall(lswitchId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<MacAddressListResult>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalSwitchMacTableInCsvFormatCsv
     * @param lswitchId  (required)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalSwitchMacTableInCsvFormatCsvCall(String lswitchId, String source, String transportNodeId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-switches/{lswitch-id}/mac-table?format=csv"
            .replaceAll("\\{" + "lswitch-id" + "\\}", apiClient.escapeString(lswitchId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
        if (transportNodeId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_node_id", transportNodeId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/csv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalSwitchMacTableInCsvFormatCsvValidateBeforeCall(String lswitchId, String source, String transportNodeId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'lswitchId' is set
        if (lswitchId == null) {
            throw new ApiException("Missing the required parameter 'lswitchId' when calling getLogicalSwitchMacTableInCsvFormatCsv(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalSwitchMacTableInCsvFormatCsvCall(lswitchId, source, transportNodeId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get MAC Table for Logical Switch of the Given ID (lswitch-id)
     * Returns MAC table of a specified logical switch in CSV format from the given transport node if a transport node id is given in the query parameter from the Central Controller Plane. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. 
     * @param lswitchId  (required)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @return MacAddressCsvListResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public MacAddressCsvListResult getLogicalSwitchMacTableInCsvFormatCsv(String lswitchId, String source, String transportNodeId) throws ApiException {
        ApiResponse<MacAddressCsvListResult> resp = getLogicalSwitchMacTableInCsvFormatCsvWithHttpInfo(lswitchId, source, transportNodeId);
        return resp.getData();
    }

    /**
     * Get MAC Table for Logical Switch of the Given ID (lswitch-id)
     * Returns MAC table of a specified logical switch in CSV format from the given transport node if a transport node id is given in the query parameter from the Central Controller Plane. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. 
     * @param lswitchId  (required)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @return ApiResponse&lt;MacAddressCsvListResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<MacAddressCsvListResult> getLogicalSwitchMacTableInCsvFormatCsvWithHttpInfo(String lswitchId, String source, String transportNodeId) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalSwitchMacTableInCsvFormatCsvValidateBeforeCall(lswitchId, source, transportNodeId, null, null);
        Type localVarReturnType = new TypeToken<MacAddressCsvListResult>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get MAC Table for Logical Switch of the Given ID (lswitch-id) (asynchronously)
     * Returns MAC table of a specified logical switch in CSV format from the given transport node if a transport node id is given in the query parameter from the Central Controller Plane. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. 
     * @param lswitchId  (required)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalSwitchMacTableInCsvFormatCsvAsync(String lswitchId, String source, String transportNodeId, final ApiCallback<MacAddressCsvListResult> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalSwitchMacTableInCsvFormatCsvValidateBeforeCall(lswitchId, source, transportNodeId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<MacAddressCsvListResult>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalSwitchState
     * @param lswitchId  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalSwitchStateCall(String lswitchId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-switches/{lswitch-id}/state"
            .replaceAll("\\{" + "lswitch-id" + "\\}", apiClient.escapeString(lswitchId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalSwitchStateValidateBeforeCall(String lswitchId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'lswitchId' is set
        if (lswitchId == null) {
            throw new ApiException("Missing the required parameter 'lswitchId' when calling getLogicalSwitchState(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalSwitchStateCall(lswitchId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get the realized state associated with provided logical switch id
     * Returns current state of the logical switch configuration and details of only out-of-sync transport nodes. 
     * @param lswitchId  (required)
     * @return LogicalSwitchState
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalSwitchState getLogicalSwitchState(String lswitchId) throws ApiException {
        ApiResponse<LogicalSwitchState> resp = getLogicalSwitchStateWithHttpInfo(lswitchId);
        return resp.getData();
    }

    /**
     * Get the realized state associated with provided logical switch id
     * Returns current state of the logical switch configuration and details of only out-of-sync transport nodes. 
     * @param lswitchId  (required)
     * @return ApiResponse&lt;LogicalSwitchState&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalSwitchState> getLogicalSwitchStateWithHttpInfo(String lswitchId) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalSwitchStateValidateBeforeCall(lswitchId, null, null);
        Type localVarReturnType = new TypeToken<LogicalSwitchState>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get the realized state associated with provided logical switch id (asynchronously)
     * Returns current state of the logical switch configuration and details of only out-of-sync transport nodes. 
     * @param lswitchId  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalSwitchStateAsync(String lswitchId, final ApiCallback<LogicalSwitchState> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalSwitchStateValidateBeforeCall(lswitchId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalSwitchState>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalSwitchStatistics
     * @param lswitchId  (required)
     * @param source Data source type. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalSwitchStatisticsCall(String lswitchId, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-switches/{lswitch-id}/statistics"
            .replaceAll("\\{" + "lswitch-id" + "\\}", apiClient.escapeString(lswitchId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalSwitchStatisticsValidateBeforeCall(String lswitchId, String source, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'lswitchId' is set
        if (lswitchId == null) {
            throw new ApiException("Missing the required parameter 'lswitchId' when calling getLogicalSwitchStatistics(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalSwitchStatisticsCall(lswitchId, source, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get Statistics for Logical Switch of the Given ID (lswitch-id)
     * Returns statistics  of a specified logical switch. The query parameter \&quot;source&#x3D;realtime\&quot; is not supported. 
     * @param lswitchId  (required)
     * @param source Data source type. (optional)
     * @return LogicalSwitchStatistics
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalSwitchStatistics getLogicalSwitchStatistics(String lswitchId, String source) throws ApiException {
        ApiResponse<LogicalSwitchStatistics> resp = getLogicalSwitchStatisticsWithHttpInfo(lswitchId, source);
        return resp.getData();
    }

    /**
     * Get Statistics for Logical Switch of the Given ID (lswitch-id)
     * Returns statistics  of a specified logical switch. The query parameter \&quot;source&#x3D;realtime\&quot; is not supported. 
     * @param lswitchId  (required)
     * @param source Data source type. (optional)
     * @return ApiResponse&lt;LogicalSwitchStatistics&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalSwitchStatistics> getLogicalSwitchStatisticsWithHttpInfo(String lswitchId, String source) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalSwitchStatisticsValidateBeforeCall(lswitchId, source, null, null);
        Type localVarReturnType = new TypeToken<LogicalSwitchStatistics>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Statistics for Logical Switch of the Given ID (lswitch-id) (asynchronously)
     * Returns statistics  of a specified logical switch. The query parameter \&quot;source&#x3D;realtime\&quot; is not supported. 
     * @param lswitchId  (required)
     * @param source Data source type. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalSwitchStatisticsAsync(String lswitchId, String source, final ApiCallback<LogicalSwitchStatistics> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalSwitchStatisticsValidateBeforeCall(lswitchId, source, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalSwitchStatistics>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalSwitchStatus
     * @param lswitchId  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalSwitchStatusCall(String lswitchId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-switches/{lswitch-id}/summary"
            .replaceAll("\\{" + "lswitch-id" + "\\}", apiClient.escapeString(lswitchId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalSwitchStatusValidateBeforeCall(String lswitchId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'lswitchId' is set
        if (lswitchId == null) {
            throw new ApiException("Missing the required parameter 'lswitchId' when calling getLogicalSwitchStatus(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalSwitchStatusCall(lswitchId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get Logical Switch runtime status info for a given logical switch
     * Returns the number of ports assigned to a logical switch.
     * @param lswitchId  (required)
     * @return LogicalSwitchStatus
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalSwitchStatus getLogicalSwitchStatus(String lswitchId) throws ApiException {
        ApiResponse<LogicalSwitchStatus> resp = getLogicalSwitchStatusWithHttpInfo(lswitchId);
        return resp.getData();
    }

    /**
     * Get Logical Switch runtime status info for a given logical switch
     * Returns the number of ports assigned to a logical switch.
     * @param lswitchId  (required)
     * @return ApiResponse&lt;LogicalSwitchStatus&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalSwitchStatus> getLogicalSwitchStatusWithHttpInfo(String lswitchId) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalSwitchStatusValidateBeforeCall(lswitchId, null, null);
        Type localVarReturnType = new TypeToken<LogicalSwitchStatus>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Logical Switch runtime status info for a given logical switch (asynchronously)
     * Returns the number of ports assigned to a logical switch.
     * @param lswitchId  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalSwitchStatusAsync(String lswitchId, final ApiCallback<LogicalSwitchStatus> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalSwitchStatusValidateBeforeCall(lswitchId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalSwitchStatus>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalSwitchStatusSummary
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param diagnostic Flag to enable showing of transit logical switch. (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param switchingProfileId Switching Profile identifier (optional)
     * @param transportType Mode of transport supported in the transport zone for this logical switch (optional)
     * @param transportZoneId Transport zone identifier (optional)
     * @param uplinkTeamingPolicyName The logical switch&#x27;s uplink teaming policy name (optional)
     * @param vlan Virtual Local Area Network Identifier (optional)
     * @param vni VNI of the OVERLAY LogicalSwitch(es) to return. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalSwitchStatusSummaryCall(String cursor, Boolean diagnostic, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String switchingProfileId, String transportType, String transportZoneId, String uplinkTeamingPolicyName, Long vlan, Integer vni, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-switches/status";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (cursor != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cursor", cursor));
        if (diagnostic != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("diagnostic", diagnostic));
        if (includedFields != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("included_fields", includedFields));
        if (pageSize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page_size", pageSize));
        if (sortAscending != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_ascending", sortAscending));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_by", sortBy));
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
        if (switchingProfileId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("switching_profile_id", switchingProfileId));
        if (transportType != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_type", transportType));
        if (transportZoneId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_zone_id", transportZoneId));
        if (uplinkTeamingPolicyName != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("uplink_teaming_policy_name", uplinkTeamingPolicyName));
        if (vlan != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("vlan", vlan));
        if (vni != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("vni", vni));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalSwitchStatusSummaryValidateBeforeCall(String cursor, Boolean diagnostic, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String switchingProfileId, String transportType, String transportZoneId, String uplinkTeamingPolicyName, Long vlan, Integer vni, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        com.squareup.okhttp.Call call = getLogicalSwitchStatusSummaryCall(cursor, diagnostic, includedFields, pageSize, sortAscending, sortBy, source, switchingProfileId, transportType, transportZoneId, uplinkTeamingPolicyName, vlan, vni, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get Status Summary of All Logical Switches in the System
     * Returns Operational status of all logical switches. The query parameter \&quot;source&#x3D;realtime\&quot; is not supported. 
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param diagnostic Flag to enable showing of transit logical switch. (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param switchingProfileId Switching Profile identifier (optional)
     * @param transportType Mode of transport supported in the transport zone for this logical switch (optional)
     * @param transportZoneId Transport zone identifier (optional)
     * @param uplinkTeamingPolicyName The logical switch&#x27;s uplink teaming policy name (optional)
     * @param vlan Virtual Local Area Network Identifier (optional)
     * @param vni VNI of the OVERLAY LogicalSwitch(es) to return. (optional)
     * @return LogicalSwitchStatusSummary
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalSwitchStatusSummary getLogicalSwitchStatusSummary(String cursor, Boolean diagnostic, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String switchingProfileId, String transportType, String transportZoneId, String uplinkTeamingPolicyName, Long vlan, Integer vni) throws ApiException {
        ApiResponse<LogicalSwitchStatusSummary> resp = getLogicalSwitchStatusSummaryWithHttpInfo(cursor, diagnostic, includedFields, pageSize, sortAscending, sortBy, source, switchingProfileId, transportType, transportZoneId, uplinkTeamingPolicyName, vlan, vni);
        return resp.getData();
    }

    /**
     * Get Status Summary of All Logical Switches in the System
     * Returns Operational status of all logical switches. The query parameter \&quot;source&#x3D;realtime\&quot; is not supported. 
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param diagnostic Flag to enable showing of transit logical switch. (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param switchingProfileId Switching Profile identifier (optional)
     * @param transportType Mode of transport supported in the transport zone for this logical switch (optional)
     * @param transportZoneId Transport zone identifier (optional)
     * @param uplinkTeamingPolicyName The logical switch&#x27;s uplink teaming policy name (optional)
     * @param vlan Virtual Local Area Network Identifier (optional)
     * @param vni VNI of the OVERLAY LogicalSwitch(es) to return. (optional)
     * @return ApiResponse&lt;LogicalSwitchStatusSummary&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalSwitchStatusSummary> getLogicalSwitchStatusSummaryWithHttpInfo(String cursor, Boolean diagnostic, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String switchingProfileId, String transportType, String transportZoneId, String uplinkTeamingPolicyName, Long vlan, Integer vni) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalSwitchStatusSummaryValidateBeforeCall(cursor, diagnostic, includedFields, pageSize, sortAscending, sortBy, source, switchingProfileId, transportType, transportZoneId, uplinkTeamingPolicyName, vlan, vni, null, null);
        Type localVarReturnType = new TypeToken<LogicalSwitchStatusSummary>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Status Summary of All Logical Switches in the System (asynchronously)
     * Returns Operational status of all logical switches. The query parameter \&quot;source&#x3D;realtime\&quot; is not supported. 
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param diagnostic Flag to enable showing of transit logical switch. (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param switchingProfileId Switching Profile identifier (optional)
     * @param transportType Mode of transport supported in the transport zone for this logical switch (optional)
     * @param transportZoneId Transport zone identifier (optional)
     * @param uplinkTeamingPolicyName The logical switch&#x27;s uplink teaming policy name (optional)
     * @param vlan Virtual Local Area Network Identifier (optional)
     * @param vni VNI of the OVERLAY LogicalSwitch(es) to return. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalSwitchStatusSummaryAsync(String cursor, Boolean diagnostic, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String switchingProfileId, String transportType, String transportZoneId, String uplinkTeamingPolicyName, Long vlan, Integer vni, final ApiCallback<LogicalSwitchStatusSummary> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalSwitchStatusSummaryValidateBeforeCall(cursor, diagnostic, includedFields, pageSize, sortAscending, sortBy, source, switchingProfileId, transportType, transportZoneId, uplinkTeamingPolicyName, vlan, vni, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalSwitchStatusSummary>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalSwitchVtepTable
     * @param lswitchId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalSwitchVtepTableCall(String lswitchId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-switches/{lswitch-id}/vtep-table"
            .replaceAll("\\{" + "lswitch-id" + "\\}", apiClient.escapeString(lswitchId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (cursor != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cursor", cursor));
        if (includedFields != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("included_fields", includedFields));
        if (pageSize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page_size", pageSize));
        if (sortAscending != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_ascending", sortAscending));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_by", sortBy));
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
        if (transportNodeId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_node_id", transportNodeId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalSwitchVtepTableValidateBeforeCall(String lswitchId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'lswitchId' is set
        if (lswitchId == null) {
            throw new ApiException("Missing the required parameter 'lswitchId' when calling getLogicalSwitchVtepTable(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalSwitchVtepTableCall(lswitchId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get virtual tunnel endpoint table for logical switch of the given ID (lswitch-id) 
     * Returns the virtual tunnel endpoint table of a specified logical switch from the given transport node if a transport node id is given in the query parameter, from the Central Controller Plane. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. 
     * @param lswitchId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @return VtepListResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public VtepListResult getLogicalSwitchVtepTable(String lswitchId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId) throws ApiException {
        ApiResponse<VtepListResult> resp = getLogicalSwitchVtepTableWithHttpInfo(lswitchId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId);
        return resp.getData();
    }

    /**
     * Get virtual tunnel endpoint table for logical switch of the given ID (lswitch-id) 
     * Returns the virtual tunnel endpoint table of a specified logical switch from the given transport node if a transport node id is given in the query parameter, from the Central Controller Plane. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. 
     * @param lswitchId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @return ApiResponse&lt;VtepListResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<VtepListResult> getLogicalSwitchVtepTableWithHttpInfo(String lswitchId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalSwitchVtepTableValidateBeforeCall(lswitchId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId, null, null);
        Type localVarReturnType = new TypeToken<VtepListResult>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get virtual tunnel endpoint table for logical switch of the given ID (lswitch-id)  (asynchronously)
     * Returns the virtual tunnel endpoint table of a specified logical switch from the given transport node if a transport node id is given in the query parameter, from the Central Controller Plane. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. 
     * @param lswitchId  (required)
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalSwitchVtepTableAsync(String lswitchId, String cursor, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String source, String transportNodeId, final ApiCallback<VtepListResult> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalSwitchVtepTableValidateBeforeCall(lswitchId, cursor, includedFields, pageSize, sortAscending, sortBy, source, transportNodeId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<VtepListResult>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getLogicalSwitchVtepTableInCsvFormatCsv
     * @param lswitchId  (required)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getLogicalSwitchVtepTableInCsvFormatCsvCall(String lswitchId, String source, String transportNodeId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-switches/{lswitch-id}/vtep-table?format=csv"
            .replaceAll("\\{" + "lswitch-id" + "\\}", apiClient.escapeString(lswitchId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (source != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
        if (transportNodeId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_node_id", transportNodeId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/csv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getLogicalSwitchVtepTableInCsvFormatCsvValidateBeforeCall(String lswitchId, String source, String transportNodeId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'lswitchId' is set
        if (lswitchId == null) {
            throw new ApiException("Missing the required parameter 'lswitchId' when calling getLogicalSwitchVtepTableInCsvFormatCsv(Async)");
        }
        
        com.squareup.okhttp.Call call = getLogicalSwitchVtepTableInCsvFormatCsvCall(lswitchId, source, transportNodeId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Get virtual tunnel endpoint table for logical switch of the given ID (lswitch-id) 
     * Returns virtual tunnel endpoint table of a specified logical switch in CSV format from the given transport node if a transport node id is given in the query parameter from the Central Controller Plane. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. 
     * @param lswitchId  (required)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @return VtepCsvListResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public VtepCsvListResult getLogicalSwitchVtepTableInCsvFormatCsv(String lswitchId, String source, String transportNodeId) throws ApiException {
        ApiResponse<VtepCsvListResult> resp = getLogicalSwitchVtepTableInCsvFormatCsvWithHttpInfo(lswitchId, source, transportNodeId);
        return resp.getData();
    }

    /**
     * Get virtual tunnel endpoint table for logical switch of the given ID (lswitch-id) 
     * Returns virtual tunnel endpoint table of a specified logical switch in CSV format from the given transport node if a transport node id is given in the query parameter from the Central Controller Plane. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. 
     * @param lswitchId  (required)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @return ApiResponse&lt;VtepCsvListResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<VtepCsvListResult> getLogicalSwitchVtepTableInCsvFormatCsvWithHttpInfo(String lswitchId, String source, String transportNodeId) throws ApiException {
        com.squareup.okhttp.Call call = getLogicalSwitchVtepTableInCsvFormatCsvValidateBeforeCall(lswitchId, source, transportNodeId, null, null);
        Type localVarReturnType = new TypeToken<VtepCsvListResult>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get virtual tunnel endpoint table for logical switch of the given ID (lswitch-id)  (asynchronously)
     * Returns virtual tunnel endpoint table of a specified logical switch in CSV format from the given transport node if a transport node id is given in the query parameter from the Central Controller Plane. The query parameter \&quot;source&#x3D;cached\&quot; is not supported. 
     * @param lswitchId  (required)
     * @param source Data source type. (optional)
     * @param transportNodeId TransportNode Id (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getLogicalSwitchVtepTableInCsvFormatCsvAsync(String lswitchId, String source, String transportNodeId, final ApiCallback<VtepCsvListResult> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getLogicalSwitchVtepTableInCsvFormatCsvValidateBeforeCall(lswitchId, source, transportNodeId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<VtepCsvListResult>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for listLogicalSwitches
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param diagnostic Flag to enable showing of transit logical switch. (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param switchingProfileId Switching Profile identifier (optional)
     * @param transportType Mode of transport supported in the transport zone for this logical switch (optional)
     * @param transportZoneId Transport zone identifier (optional)
     * @param uplinkTeamingPolicyName The logical switch&#x27;s uplink teaming policy name (optional)
     * @param vlan Virtual Local Area Network Identifier (optional)
     * @param vni VNI of the OVERLAY LogicalSwitch(es) to return. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call listLogicalSwitchesCall(String cursor, Boolean diagnostic, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String switchingProfileId, String transportType, String transportZoneId, String uplinkTeamingPolicyName, Long vlan, Integer vni, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-switches";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (cursor != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cursor", cursor));
        if (diagnostic != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("diagnostic", diagnostic));
        if (includedFields != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("included_fields", includedFields));
        if (pageSize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page_size", pageSize));
        if (sortAscending != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_ascending", sortAscending));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort_by", sortBy));
        if (switchingProfileId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("switching_profile_id", switchingProfileId));
        if (transportType != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_type", transportType));
        if (transportZoneId != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("transport_zone_id", transportZoneId));
        if (uplinkTeamingPolicyName != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("uplink_teaming_policy_name", uplinkTeamingPolicyName));
        if (vlan != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("vlan", vlan));
        if (vni != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("vni", vni));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call listLogicalSwitchesValidateBeforeCall(String cursor, Boolean diagnostic, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String switchingProfileId, String transportType, String transportZoneId, String uplinkTeamingPolicyName, Long vlan, Integer vni, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        com.squareup.okhttp.Call call = listLogicalSwitchesCall(cursor, diagnostic, includedFields, pageSize, sortAscending, sortBy, switchingProfileId, transportType, transportZoneId, uplinkTeamingPolicyName, vlan, vni, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * List all Logical Switches
     * Returns information about all configured logical switches.
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param diagnostic Flag to enable showing of transit logical switch. (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param switchingProfileId Switching Profile identifier (optional)
     * @param transportType Mode of transport supported in the transport zone for this logical switch (optional)
     * @param transportZoneId Transport zone identifier (optional)
     * @param uplinkTeamingPolicyName The logical switch&#x27;s uplink teaming policy name (optional)
     * @param vlan Virtual Local Area Network Identifier (optional)
     * @param vni VNI of the OVERLAY LogicalSwitch(es) to return. (optional)
     * @return LogicalSwitchListResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalSwitchListResult listLogicalSwitches(String cursor, Boolean diagnostic, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String switchingProfileId, String transportType, String transportZoneId, String uplinkTeamingPolicyName, Long vlan, Integer vni) throws ApiException {
        ApiResponse<LogicalSwitchListResult> resp = listLogicalSwitchesWithHttpInfo(cursor, diagnostic, includedFields, pageSize, sortAscending, sortBy, switchingProfileId, transportType, transportZoneId, uplinkTeamingPolicyName, vlan, vni);
        return resp.getData();
    }

    /**
     * List all Logical Switches
     * Returns information about all configured logical switches.
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param diagnostic Flag to enable showing of transit logical switch. (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param switchingProfileId Switching Profile identifier (optional)
     * @param transportType Mode of transport supported in the transport zone for this logical switch (optional)
     * @param transportZoneId Transport zone identifier (optional)
     * @param uplinkTeamingPolicyName The logical switch&#x27;s uplink teaming policy name (optional)
     * @param vlan Virtual Local Area Network Identifier (optional)
     * @param vni VNI of the OVERLAY LogicalSwitch(es) to return. (optional)
     * @return ApiResponse&lt;LogicalSwitchListResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalSwitchListResult> listLogicalSwitchesWithHttpInfo(String cursor, Boolean diagnostic, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String switchingProfileId, String transportType, String transportZoneId, String uplinkTeamingPolicyName, Long vlan, Integer vni) throws ApiException {
        com.squareup.okhttp.Call call = listLogicalSwitchesValidateBeforeCall(cursor, diagnostic, includedFields, pageSize, sortAscending, sortBy, switchingProfileId, transportType, transportZoneId, uplinkTeamingPolicyName, vlan, vni, null, null);
        Type localVarReturnType = new TypeToken<LogicalSwitchListResult>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * List all Logical Switches (asynchronously)
     * Returns information about all configured logical switches.
     * @param cursor Opaque cursor to be used for getting next page of records (supplied by current result page) (optional)
     * @param diagnostic Flag to enable showing of transit logical switch. (optional)
     * @param includedFields Comma separated list of fields that should be included in query result (optional)
     * @param pageSize Maximum number of results to return in this page (server may return fewer) (optional)
     * @param sortAscending  (optional)
     * @param sortBy Field by which records are sorted (optional)
     * @param switchingProfileId Switching Profile identifier (optional)
     * @param transportType Mode of transport supported in the transport zone for this logical switch (optional)
     * @param transportZoneId Transport zone identifier (optional)
     * @param uplinkTeamingPolicyName The logical switch&#x27;s uplink teaming policy name (optional)
     * @param vlan Virtual Local Area Network Identifier (optional)
     * @param vni VNI of the OVERLAY LogicalSwitch(es) to return. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call listLogicalSwitchesAsync(String cursor, Boolean diagnostic, String includedFields, Long pageSize, Boolean sortAscending, String sortBy, String switchingProfileId, String transportType, String transportZoneId, String uplinkTeamingPolicyName, Long vlan, Integer vni, final ApiCallback<LogicalSwitchListResult> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = listLogicalSwitchesValidateBeforeCall(cursor, diagnostic, includedFields, pageSize, sortAscending, sortBy, switchingProfileId, transportType, transportZoneId, uplinkTeamingPolicyName, vlan, vni, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalSwitchListResult>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for listLogicalSwitchesByState
     * @param status Realized state of logical switches (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call listLogicalSwitchesByStateCall(String status, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/logical-switches/state";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (status != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("status", status));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call listLogicalSwitchesByStateValidateBeforeCall(String status, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        com.squareup.okhttp.Call call = listLogicalSwitchesByStateCall(status, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * List logical switches by realized state
     * Returns a list of logical switches states that have realized state as provided as query parameter. 
     * @param status Realized state of logical switches (optional)
     * @return LogicalSwitchStateListResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalSwitchStateListResult listLogicalSwitchesByState(String status) throws ApiException {
        ApiResponse<LogicalSwitchStateListResult> resp = listLogicalSwitchesByStateWithHttpInfo(status);
        return resp.getData();
    }

    /**
     * List logical switches by realized state
     * Returns a list of logical switches states that have realized state as provided as query parameter. 
     * @param status Realized state of logical switches (optional)
     * @return ApiResponse&lt;LogicalSwitchStateListResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalSwitchStateListResult> listLogicalSwitchesByStateWithHttpInfo(String status) throws ApiException {
        com.squareup.okhttp.Call call = listLogicalSwitchesByStateValidateBeforeCall(status, null, null);
        Type localVarReturnType = new TypeToken<LogicalSwitchStateListResult>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * List logical switches by realized state (asynchronously)
     * Returns a list of logical switches states that have realized state as provided as query parameter. 
     * @param status Realized state of logical switches (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call listLogicalSwitchesByStateAsync(String status, final ApiCallback<LogicalSwitchStateListResult> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = listLogicalSwitchesByStateValidateBeforeCall(status, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalSwitchStateListResult>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for updateLogicalSwitch
     * @param body  (required)
     * @param lswitchId  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call updateLogicalSwitchCall(LogicalSwitch body, String lswitchId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/logical-switches/{lswitch-id}"
            .replaceAll("\\{" + "lswitch-id" + "\\}", apiClient.escapeString(lswitchId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call updateLogicalSwitchValidateBeforeCall(LogicalSwitch body, String lswitchId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling updateLogicalSwitch(Async)");
        }
        // verify the required parameter 'lswitchId' is set
        if (lswitchId == null) {
            throw new ApiException("Missing the required parameter 'lswitchId' when calling updateLogicalSwitch(Async)");
        }
        
        com.squareup.okhttp.Call call = updateLogicalSwitchCall(body, lswitchId, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Update a Logical Switch
     * Modifies attributes of an existing logical switch. Modifiable attributes include admin_state, replication_mode, switching_profile_ids and VLAN spec. You cannot modify the original transport_zone_id. 
     * @param body  (required)
     * @param lswitchId  (required)
     * @return LogicalSwitch
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public LogicalSwitch updateLogicalSwitch(LogicalSwitch body, String lswitchId) throws ApiException {
        ApiResponse<LogicalSwitch> resp = updateLogicalSwitchWithHttpInfo(body, lswitchId);
        return resp.getData();
    }

    /**
     * Update a Logical Switch
     * Modifies attributes of an existing logical switch. Modifiable attributes include admin_state, replication_mode, switching_profile_ids and VLAN spec. You cannot modify the original transport_zone_id. 
     * @param body  (required)
     * @param lswitchId  (required)
     * @return ApiResponse&lt;LogicalSwitch&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<LogicalSwitch> updateLogicalSwitchWithHttpInfo(LogicalSwitch body, String lswitchId) throws ApiException {
        com.squareup.okhttp.Call call = updateLogicalSwitchValidateBeforeCall(body, lswitchId, null, null);
        Type localVarReturnType = new TypeToken<LogicalSwitch>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update a Logical Switch (asynchronously)
     * Modifies attributes of an existing logical switch. Modifiable attributes include admin_state, replication_mode, switching_profile_ids and VLAN spec. You cannot modify the original transport_zone_id. 
     * @param body  (required)
     * @param lswitchId  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call updateLogicalSwitchAsync(LogicalSwitch body, String lswitchId, final ApiCallback<LogicalSwitch> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = updateLogicalSwitchValidateBeforeCall(body, lswitchId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<LogicalSwitch>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
